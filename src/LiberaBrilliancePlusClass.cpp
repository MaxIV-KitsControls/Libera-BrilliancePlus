/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass.cpp) ENABLED START -----*/
static const char *RcsId      = "$Id:  $";
static const char *TagName    = "$Name:  $";
static const char *CvsPath    = "$Source:  $";
static const char *SvnPath    = "$HeadURL:  $";
static const char *HttpServer = "http://www.esrf.eu/computing/cs/tango/tango_doc/ds_doc/";
//=============================================================================
//
// file :        LiberaBrilliancePlusClass.cpp
//
// description : C++ source for the LiberaBrilliancePlusClass.
//               A singleton class derived from DeviceClass.
//               It implements the command and attribute list
//               and all properties and methods required
//               by the LiberaBrilliancePlus once per process.
//
// project :     Libera BPM Device Server
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <LiberaBrilliancePlusClass.h>

/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass.cpp

//-------------------------------------------------------------------
/**
 *	Create LiberaBrilliancePlusClass singleton and
 *	return it in a C function for Python usage
 */
//-------------------------------------------------------------------
extern "C" {
#ifdef _TG_WINDOWS_

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_LiberaBrilliancePlus_class(const char *name) {
		return LiberaBrilliancePlus_ns::LiberaBrilliancePlusClass::init(name);
	}
}

namespace LiberaBrilliancePlus_ns
{
//===================================================================
//	Initialize pointer for singleton pattern
//===================================================================
LiberaBrilliancePlusClass *LiberaBrilliancePlusClass::_instance = NULL;

//--------------------------------------------------------
/**
 * method : 		LiberaBrilliancePlusClass::LiberaBrilliancePlusClass(string &s)
 * description : 	constructor for the LiberaBrilliancePlusClass
 *
 * @param s	The class name
 */
//--------------------------------------------------------
LiberaBrilliancePlusClass::LiberaBrilliancePlusClass(string &s):Tango::DeviceClass(s)
{
	cout2 << "Entering LiberaBrilliancePlusClass constructor" << endl;
	set_default_property();
	get_class_property();
	write_class_property();

	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::constructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::constructor

	cout2 << "Leaving LiberaBrilliancePlusClass constructor" << endl;
}

//--------------------------------------------------------
/**
 * method : 		LiberaBrilliancePlusClass::~LiberaBrilliancePlusClass()
 * description : 	destructor for the LiberaBrilliancePlusClass
 */
//--------------------------------------------------------
LiberaBrilliancePlusClass::~LiberaBrilliancePlusClass()
{
	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::destructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::destructor

	_instance = NULL;
}


//--------------------------------------------------------
/**
 * method : 		LiberaBrilliancePlusClass::init
 * description : 	Create the object if not already done.
 *                  Otherwise, just return a pointer to the object
 *
 * @param	name	The class name
 */
//--------------------------------------------------------
LiberaBrilliancePlusClass *LiberaBrilliancePlusClass::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new LiberaBrilliancePlusClass(s);
		}
		catch (bad_alloc &)
		{
			throw;
		}		
	}		
	return _instance;
}

//--------------------------------------------------------
/**
 * method : 		LiberaBrilliancePlusClass::instance
 * description : 	Check if object already created,
 *                  and return a pointer to the object
 */
//--------------------------------------------------------
LiberaBrilliancePlusClass *LiberaBrilliancePlusClass::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}



//===================================================================
//	Command execution method calls
//===================================================================
//--------------------------------------------------------
/**
 * method : 		GetParametersClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetParametersClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetParametersClass::execute(): arrived" << endl;
	return insert((static_cast<LiberaBrilliancePlus *>(device))->get_parameters());
}

//--------------------------------------------------------
/**
 * method : 		UnfreezeDDBufferClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *UnfreezeDDBufferClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "UnfreezeDDBufferClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->unfreeze_ddbuffer());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		EnableDDBufferFreezingClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *EnableDDBufferFreezingClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "EnableDDBufferFreezingClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->enable_ddbuffer_freezing());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		DisableDDBufferFreezingClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *DisableDDBufferFreezingClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "DisableDDBufferFreezingClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->disable_ddbuffer_freezing());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		EnableDDClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *EnableDDClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "EnableDDClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->enable_dd());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		DisableDDClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *DisableDDClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "DisableDDClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->disable_dd());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		EnableSAClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *EnableSAClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "EnableSAClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->enable_sa());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		DisableSAClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *DisableSAClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "DisableSAClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->disable_sa());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ResetPMNotificationClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ResetPMNotificationClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ResetPMNotificationClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->reset_pmnotification());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ResetInterlockNotificationClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ResetInterlockNotificationClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ResetInterlockNotificationClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->reset_interlock_notification());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SetInterlockConfigurationClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SetInterlockConfigurationClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "SetInterlockConfigurationClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->set_interlock_configuration());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		EnableADCClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *EnableADCClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "EnableADCClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->enable_adc());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		DisableADCClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *DisableADCClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "DisableADCClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->disable_adc());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SetTimeOnNextTriggerClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SetTimeOnNextTriggerClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "SetTimeOnNextTriggerClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->set_time_on_next_trigger());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ReadFADataClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ReadFADataClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "ReadFADataClass::execute(): arrived" << endl;
	const Tango::DevVarLongArray *argin;
	extract(in_any, argin);
	return insert((static_cast<LiberaBrilliancePlus *>(device))->read_fadata(argin));
}

//--------------------------------------------------------
/**
 * method : 		WriteFADataClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *WriteFADataClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "WriteFADataClass::execute(): arrived" << endl;
	const Tango::DevVarLongArray *argin;
	extract(in_any, argin);
	((static_cast<LiberaBrilliancePlus *>(device))->write_fadata(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SaveDSCParametersClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SaveDSCParametersClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "SaveDSCParametersClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->save_dscparameters());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ReloadSystemPropertiesClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ReloadSystemPropertiesClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ReloadSystemPropertiesClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->reload_system_properties());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SetRefIncoherenceClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SetRefIncoherenceClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "SetRefIncoherenceClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->set_ref_incoherence());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		MagicCommandClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *MagicCommandClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "MagicCommandClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	return insert((static_cast<LiberaBrilliancePlus *>(device))->magic_command(argin));
}

//--------------------------------------------------------
/**
 * method : 		EnableTDBufferFreezingClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *EnableTDBufferFreezingClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "EnableTDBufferFreezingClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->enable_tdbuffer_freezing());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		DisableTDBufferFreezingClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *DisableTDBufferFreezingClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "DisableTDBufferFreezingClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->disable_tdbuffer_freezing());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		EnableTDClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *EnableTDClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "EnableTDClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->enable_td());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		DisableTDClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *DisableTDClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "DisableTDClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->disable_td());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		UnfreezeTDBufferClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *UnfreezeTDBufferClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "UnfreezeTDBufferClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->unfreeze_tdbuffer());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		EnableSPClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *EnableSPClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "EnableSPClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->enable_sp());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		DisableSPClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *DisableSPClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "DisableSPClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->disable_sp());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		StartSynchronizationClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *StartSynchronizationClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "StartSynchronizationClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->start_synchronization());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		AnnounceSynchronizationClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *AnnounceSynchronizationClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "AnnounceSynchronizationClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->announce_synchronization());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ForceInitSettingsClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ForceInitSettingsClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ForceInitSettingsClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->force_init_settings());
	return new CORBA::Any();
}


//===================================================================
//	Properties management
//===================================================================
//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::get_class_property()
 *	Description : Get the class property for specified name.
 */
//--------------------------------------------------------
Tango::DbDatum LiberaBrilliancePlusClass::get_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, returns  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::get_default_device_property()
 *	Description : Return the default value for device property.
 */
//--------------------------------------------------------
Tango::DbDatum LiberaBrilliancePlusClass::get_default_device_property(string &prop_name)
{
	for (unsigned int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::get_default_class_property()
 *	Description : Return the default value for class property.
 */
//--------------------------------------------------------
Tango::DbDatum LiberaBrilliancePlusClass::get_default_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::get_class_property()
 *	Description : Read database to initialize class property data members.
 */
//--------------------------------------------------------
void LiberaBrilliancePlusClass::get_class_property()
{
	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::get_class_property_before) ENABLED START -----*/
	
	//	Initialize class property data members
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::get_class_property_before
	//	Read class properties from database.
	cl_prop.push_back(Tango::DbDatum("InterlockConfiguration"));
	cl_prop.push_back(Tango::DbDatum("EnableDDOptionalData"));
	cl_prop.push_back(Tango::DbDatum("EnableSAOptionalData"));
	cl_prop.push_back(Tango::DbDatum("EnableSAHistoryOptionalData"));
	cl_prop.push_back(Tango::DbDatum("EnableADCOptionalData"));
	cl_prop.push_back(Tango::DbDatum("Institute"));
	cl_prop.push_back(Tango::DbDatum("EnableTDOptionalData"));
	
	//	Call database and extract values
	if (Tango::Util::instance()->_UseDb==true)
		get_db_class()->get_property(cl_prop);
	Tango::DbDatum	def_prop;
	int	i = -1;

	//	Try to extract InterlockConfiguration value
	if (cl_prop[++i].is_empty()==false)	cl_prop[i]  >>  interlockConfiguration;
	else
	{
		//	Check default value for InterlockConfiguration
		def_prop = get_default_class_property(cl_prop[i].name);
		if (def_prop.is_empty()==false)
		{
			def_prop    >>  interlockConfiguration;
			cl_prop[i]  <<  interlockConfiguration;
		}
	}
	//	Try to extract EnableDDOptionalData value
	if (cl_prop[++i].is_empty()==false)	cl_prop[i]  >>  enableDDOptionalData;
	else
	{
		//	Check default value for EnableDDOptionalData
		def_prop = get_default_class_property(cl_prop[i].name);
		if (def_prop.is_empty()==false)
		{
			def_prop    >>  enableDDOptionalData;
			cl_prop[i]  <<  enableDDOptionalData;
		}
	}
	//	Try to extract EnableSAOptionalData value
	if (cl_prop[++i].is_empty()==false)	cl_prop[i]  >>  enableSAOptionalData;
	else
	{
		//	Check default value for EnableSAOptionalData
		def_prop = get_default_class_property(cl_prop[i].name);
		if (def_prop.is_empty()==false)
		{
			def_prop    >>  enableSAOptionalData;
			cl_prop[i]  <<  enableSAOptionalData;
		}
	}
	//	Try to extract EnableSAHistoryOptionalData value
	if (cl_prop[++i].is_empty()==false)	cl_prop[i]  >>  enableSAHistoryOptionalData;
	else
	{
		//	Check default value for EnableSAHistoryOptionalData
		def_prop = get_default_class_property(cl_prop[i].name);
		if (def_prop.is_empty()==false)
		{
			def_prop    >>  enableSAHistoryOptionalData;
			cl_prop[i]  <<  enableSAHistoryOptionalData;
		}
	}
	//	Try to extract EnableADCOptionalData value
	if (cl_prop[++i].is_empty()==false)	cl_prop[i]  >>  enableADCOptionalData;
	else
	{
		//	Check default value for EnableADCOptionalData
		def_prop = get_default_class_property(cl_prop[i].name);
		if (def_prop.is_empty()==false)
		{
			def_prop    >>  enableADCOptionalData;
			cl_prop[i]  <<  enableADCOptionalData;
		}
	}
	//	Try to extract Institute value
	if (cl_prop[++i].is_empty()==false)	cl_prop[i]  >>  institute;
	else
	{
		//	Check default value for Institute
		def_prop = get_default_class_property(cl_prop[i].name);
		if (def_prop.is_empty()==false)
		{
			def_prop    >>  institute;
			cl_prop[i]  <<  institute;
		}
	}
	//	Try to extract EnableTDOptionalData value
	if (cl_prop[++i].is_empty()==false)	cl_prop[i]  >>  enableTDOptionalData;
	else
	{
		//	Check default value for EnableTDOptionalData
		def_prop = get_default_class_property(cl_prop[i].name);
		if (def_prop.is_empty()==false)
		{
			def_prop    >>  enableTDOptionalData;
			cl_prop[i]  <<  enableTDOptionalData;
		}
	}
	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::get_class_property_after) ENABLED START -----*/
	
	//	Check class property data members init
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::get_class_property_after

}

//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::set_default_property()
 *	Description : Set default property (class and device) for wizard.
 *                For each property, add to wizard property name and description.
 *                If default value has been set, add it to wizard property and
 *                store it in a DbDatum.
 */
//--------------------------------------------------------
void LiberaBrilliancePlusClass::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;
	vector<string>	vect_data;

	//	Set Default Class Properties
	prop_name = "InterlockConfiguration";
	prop_desc = "The user defined interlock configuration. This is the configuration that should be applied on the Libera in case the device `finds`\nthe Libera in its default startup configuration when it is itself starting up or executing its Init TANGO command. This configuration\ncan also be applied using the dedicated ``SetInterlockConfiguration`` expert command.\nParameters mapping:\n[0] Interlock : mode - [0]: disabled, [1]: enabled, [3]: enabled with gain dependency\n[1] Interlock : threshold : X low in mm\n[2] Interlock : threshold : X high in mm\n[3] Interlock : threshold : Z low in mm (i.e. Y low in the Libera terminology)\n[4] Interlock : threshold : Z high in mm (i.e. Y high in the Libera terminology)\n[5] Interlock : overflow limit (ADC threshold)\n[6] Interlock : overflow duration (num of overloaded ADC samples before raising intlck)\n[7] Interlock : gain limit in dBm  (intlck not active under this limit) - valid range is [-60, 0]";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		cl_def_prop.push_back(data);
		add_wiz_class_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_class_prop(prop_name, prop_desc);
	prop_name = "EnableDDOptionalData";
	prop_desc = "Enables/Disables  DD optional data (IxDD and QxDD)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		cl_def_prop.push_back(data);
		add_wiz_class_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_class_prop(prop_name, prop_desc);
	prop_name = "EnableSAOptionalData";
	prop_desc = "Enables/disables SA optional Data (currently not used)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		cl_def_prop.push_back(data);
		add_wiz_class_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_class_prop(prop_name, prop_desc);
	prop_name = "EnableSAHistoryOptionalData";
	prop_desc = "Enables/disables SA History optional data (sum history)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		cl_def_prop.push_back(data);
		add_wiz_class_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_class_prop(prop_name, prop_desc);
	prop_name = "EnableADCOptionalData";
	prop_desc = "Enables/disables ADC optional data (currently not used)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		cl_def_prop.push_back(data);
		add_wiz_class_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_class_prop(prop_name, prop_desc);
	prop_name = "Institute";
	prop_desc = "0: TANGO_INSTITUTE (GENERIC)\n1: ALBA\n2: ESRF\n3: ELETTRA\n4: SOLEIL";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		cl_def_prop.push_back(data);
		add_wiz_class_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_class_prop(prop_name, prop_desc);
	prop_name = "EnableTDOptionalData";
	prop_desc = "Enables/Disables  TD optional data (IxDD and QxDD)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		cl_def_prop.push_back(data);
		add_wiz_class_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_class_prop(prop_name, prop_desc);

	//	Set Default device Properties
	prop_name = "LiberaIpAddr";
	prop_desc = "The Libera IP address [no default value]";
	prop_def  = "127.0.0.1";
	vect_data.clear();
	vect_data.push_back("127.0.0.1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "LiberaPort";
	prop_desc = "The port on which the generic server handles external requests. Defaults to 23721.";
	prop_def  = "23271";
	vect_data.clear();
	vect_data.push_back("23271");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DefaultDDBufferSize";
	prop_desc = "Default [or initial] value for attribute DDBufferSize [in samples]. Defaults to 1024.";
	prop_def  = "1024";
	vect_data.clear();
	vect_data.push_back("1024");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Switches";
	prop_desc = "Switches configuration. The valid range is [0..15]. Defaults to 3.";
	prop_def  = "3";
	vect_data.clear();
	vect_data.push_back("3");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "LiberaMulticastIpAddr";
	prop_desc = "Asynch. notifications (e.g. trigger events) will be send to this addr [no default value]";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Location";
	prop_desc = "The BPM location [TL1, BOOSTER, TL2 or STORAGE_RING]. No default value.";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableExternalTrigger";
	prop_desc = "Enables (or not) the external trigger source.\nInlfuences the TANGO device behaviour not the Libera itself. Defaults to false.";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DDTaskActivityPeriod";
	prop_desc = "Specify the watch-dog (1) or data reading period (2) in ms.\nMust be in the rangec [500, 25000] ms. Defaults to 1000.\n(1) : external trigger enabled - (2) : external trigger disabled.";
	prop_def  = "1000";
	vect_data.clear();
	vect_data.push_back("1000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "SATaskActivityPeriod";
	prop_desc = "Specify the watch-dog (1) or data reading period (2) in ms.\nMust be in the range [100, 25000] ms. Defaults to 100.";
	prop_def  = "100";
	vect_data.clear();
	vect_data.push_back("100");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableDD";
	prop_desc = "Specifies whether or not the DD data source should be enabled at startup. Defaults to false.";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableSA";
	prop_desc = "Specifies whether or not the SA data source should be enabled at startup. Defaults to false.";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "SAHistoryLength";
	prop_desc = "SA history buffer length [in samples]. Defaults to 8196.";
	prop_def  = "512";
	vect_data.clear();
	vect_data.push_back("512");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DDDecimationFactor";
	prop_desc = "The DD decimation factor.\nAllowed values : 1 (no decimation) or 64 (for the so called booster normal mode)";
	prop_def  = "1";
	vect_data.clear();
	vect_data.push_back("1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableAutoSwitchingIfSAEnabled";
	prop_desc = "When set to TRUE, auto-switching is automattically enabled when the SA data source is itself enabled";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableDSCIfAutoSwitchingEnabled";
	prop_desc = "When set to TRUE, the Digital Signal Conditioning is automattically enabled when the auto-switching is itself enabled";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DefaultSAStatNumSamples";
	prop_desc = "Default number of SA history samples to use form RMS pos. computation.\nDefaults to 10 (last second in the SA history).";
	prop_def  = "256";
	vect_data.clear();
	vect_data.push_back("256");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DefaultADCBufferSize";
	prop_desc = "Default [or initial] value for attribute ADCBufferSize [in samples]. Defaults to 1024.";
	prop_def  = "1024";
	vect_data.clear();
	vect_data.push_back("1024");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ADCTaskActivityPeriod";
	prop_desc = "Specifies the data reading period in ms.\nMust be in the range [500, 25000] ms. Defaults to 1000.";
	prop_def  = "1000";
	vect_data.clear();
	vect_data.push_back("1000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableADC";
	prop_desc = "Specifies whether or not the ADC data source should be enabled at startup. Defaults to false.";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DefaultTimePhaseValue";
	prop_desc = "Default value for the machine time phase. Its valid range is [0, RfSfRatio - 1] where\nRfSfRatio is a machine dependent system property.";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "InterlockConfiguration";
	prop_desc = "The user defined interlock configuration. This is the configuration that should be applied on the Libera in case the device `finds`\nthe Libera in its default startup configuration when it is itself starting up or executing its Init TANGO command. This configuration\ncan also be applied using the dedicated `SetInterlockConfiguration` expert command.\nParameters mapping:\n[0] Interlock : mode - [0]: disabled, [1]: enabled, [3]: enabled with gain dependency\n[1] Interlock : threshold : X low in mm\n[2] Interlock : threshold : X high in mm\n[3] Interlock : threshold : Z low in mm (i.e. Y low in the Libera terminology)\n[4] Interlock : threshold : Z high in mm (i.e. Y high in the Libera terminology)\n[5] Interlock : overflow limit (ADC threshold)\n[6] Interlock : overflow duration (num of overloaded ADC samples before raising intlck)\n[7] Interlock : gain limit in dBm  (intlck not active under this limit) - valid range is [-60, 0]";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableDDOptionalData";
	prop_desc = "Enables/Disables  DD optional data (IxDD and QxDD)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableSAOptionalData";
	prop_desc = "Enables/disables SA optional Data (currently not used)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableSAHistoryOptionalData";
	prop_desc = "Enables/disables SA History optional data (sum history)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableADCOptionalData";
	prop_desc = "Enables/disables ADC optional data (currently not used)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Institute";
	prop_desc = "0: TANGO_INSTITUTE (GENERIC)\n1: ALBA\n2: ESRF\n3: ELETTRA\n4: SOLEIL";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "MaxDDBufferSizeWhenDecimationEnabled";
	prop_desc = "Max. DD buffer size when decimation enabled on DD data source.\nDefaults to 10000";
	prop_def  = "16384";
	vect_data.clear();
	vect_data.push_back("16384");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "PassBBAOffsetsToFPGA";
	prop_desc = "Controls wether or not the BBA offsets are taken into account when computing the offsets passed to the FPGA process";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "FADataCacheRefreshPeriod";
	prop_desc = "The <FA Data> cache refresh period in msecs.\nDefaults to 500 ms (2Hz).";
	prop_def  = "500";
	vect_data.clear();
	vect_data.push_back("500");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "LiberaBoard";
	prop_desc = "BPM board ID within the chassis [raf3,raf4,raf5 or raf6]";
	prop_def  = "raf5";
	vect_data.clear();
	vect_data.push_back("raf5");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableTDOptionalData";
	prop_desc = "Enables/Disables  TD optional data (IxTD and QxTD)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DefaultTDBufferSize";
	prop_desc = "Default [or initial] value for attribute TDBufferSize [in samples]. Defaults to 1024.";
	prop_def  = "1024";
	vect_data.clear();
	vect_data.push_back("1024");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableTD";
	prop_desc = "Specifies whether or not the TD data source should be enabled at startup. Defaults to false.";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "TDTaskActivityPeriod";
	prop_desc = "Specify the watch-dog (1) or data reading period (2) in ms.\nMust be in the rangec [500, 25000] ms. Defaults to 1000.\n(1) : external trigger enabled - (2) : external trigger disabled.";
	prop_def  = "1000";
	vect_data.clear();
	vect_data.push_back("1000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "TDDecimationFactor";
	prop_desc = "The DD decimation factor.\nAllowed values : 1 (no decimation) or 64 (for the so called booster normal mode)";
	prop_def  = "1";
	vect_data.clear();
	vect_data.push_back("1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "MaxTDBufferSizeWhenDecimationEnabled";
	prop_desc = "Max. TD buffer size when decimation enabled on DD data source.\nDefaults to 10000";
	prop_def  = "16384";
	vect_data.clear();
	vect_data.push_back("16384");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "MCDecoderSwitch";
	prop_desc = "MC-Config property - MC decoder switch: Enumeration (off,on,debug)";
	prop_def  = "1";
	vect_data.clear();
	vect_data.push_back("1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "MCSource";
	prop_desc = "Trigger line source selection - (Off,External,Internal,Pulse,LXI,RTC)";
	prop_def  = "5";
	vect_data.clear();
	vect_data.push_back("5");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T0Direction";
	prop_desc = "t0 port direction -  (Input,Output)";
	prop_def  = "1";
	vect_data.clear();
	vect_data.push_back("1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T0OutType";
	prop_desc = "t0 port type -  (Off,Trigger,T3,SFP)";
	prop_def  = "3";
	vect_data.clear();
	vect_data.push_back("3");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T0State";
	prop_desc = "state of active signal: high (logical 1) or low (logical 0)";
	prop_def  = "1";
	vect_data.clear();
	vect_data.push_back("1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T1Source";
	prop_desc = "Enumeration Value (Off,External,Internal,Pulse,LXI,RTC)";
	prop_def  = "5";
	vect_data.clear();
	vect_data.push_back("5");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T2Source";
	prop_desc = "Enumeration Value (Off,External,Internal,Pulse,LXI,RTC)";
	prop_def  = "5";
	vect_data.clear();
	vect_data.push_back("5");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "MgtOut";
	prop_desc = "Enumeration Value (off,sfp_in,debug,connectors)";
	prop_def  = "3";
	vect_data.clear();
	vect_data.push_back("3");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "MCinMask";
	prop_desc = "MC Masking array (in_mask) contains 16-bit entries that select the relevant bits from the 16-bit accelerators timing system.";
	prop_def  = "256";
	vect_data.clear();
	vect_data.push_back("256");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "MCinFunction";
	prop_desc = "MC Function array (in_function) contains 16-bit entries that define the value of masked bits.";
	prop_def  = "256";
	vect_data.clear();
	vect_data.push_back("256");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T0inMask";
	prop_desc = "T0 Masking array (in_mask) contains 16-bit entries that select the relevant bits from the 16-bit accelerators timing system.";
	prop_def  = "51";
	vect_data.clear();
	vect_data.push_back("51");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T1inMask";
	prop_desc = "T1 Masking array (in_mask) contains 16-bit entries that select the relevant bits from the 16-bit accelerators timing system.";
	prop_def  = "255";
	vect_data.clear();
	vect_data.push_back("255");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T2inMask";
	prop_desc = "T2 Masking array (in_mask) contains 16-bit entries that select the relevant bits from the 16-bit accelerators timing system.";
	prop_def  = "255";
	vect_data.clear();
	vect_data.push_back("255");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T0inFunction";
	prop_desc = "T0 Function array (in_function) contains 16-bit entries that define the value of masked bits.";
	prop_def  = "255";
	vect_data.clear();
	vect_data.push_back("255");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T1inFunction";
	prop_desc = "T1 Function array (in_function) contains 16-bit entries that define the value of masked bits.";
	prop_def  = "51";
	vect_data.clear();
	vect_data.push_back("51");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T2inFunction";
	prop_desc = "T2 Function array (in_function) contains 16-bit entries that define the value of masked bits.";
	prop_def  = "80";
	vect_data.clear();
	vect_data.push_back("80");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T0Duration";
	prop_desc = "Duration of signal active pulse";
	prop_def  = "100000000";
	vect_data.clear();
	vect_data.push_back("100000000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T0Delay";
	prop_desc = "Delay before transmission starts, set in cycles at fSFP";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "InterlockID";
	prop_desc = "oversaturation or X-Y orbit threshold";
	prop_def  = "1";
	vect_data.clear();
	vect_data.push_back("1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableSP";
	prop_desc = "Specifies whether or not the Single Pass data source should be enabled at startup. Defaults to false.";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DefaultSPBufferSize";
	prop_desc = "Default [or initial] value for attribute Single Pass BufferSize [in samples]. Defaults to 1024.";
	prop_def  = "1024";
	vect_data.clear();
	vect_data.push_back("1024");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "PMCapture";
	prop_desc = "PM functionality Enable/Disable";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "PMOffset";
	prop_desc = "PM Offset";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DefaultPMBufferSize";
	prop_desc = "PM buffer capacity";
	prop_def  = "524288";
	vect_data.clear();
	vect_data.push_back("524288");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T1EdgeFalling";
	prop_desc = "T1 Edge Falling";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T2EdgeFalling";
	prop_desc = "T2 Edge Falling";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T1EdgeRising";
	prop_desc = "T2 Edge Falling";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T2EdgeRising";
	prop_desc = "T2 Edge Falling";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "PMSource";
	prop_desc = "source of the PM event (external,interlock,limits)";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T1Direction";
	prop_desc = "t1 port direction -  (Input,Output)";
	prop_def  = "1";
	vect_data.clear();
	vect_data.push_back("1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T2Direction";
	prop_desc = "t2 port direction -  (Input,Output)";
	prop_def  = "1";
	vect_data.clear();
	vect_data.push_back("1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "XminLimit";
	prop_desc = "X interlock min limit";
	prop_def  = "-1";
	vect_data.clear();
	vect_data.push_back("-1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "YminLimit";
	prop_desc = "Y interlock min limit";
	prop_def  = "-1";
	vect_data.clear();
	vect_data.push_back("-1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "XmaxLimit";
	prop_desc = "X interlock max limit";
	prop_def  = "1";
	vect_data.clear();
	vect_data.push_back("1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "YmaxLimit";
	prop_desc = "Y interlock max limit";
	prop_def  = "1";
	vect_data.clear();
	vect_data.push_back("1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "InterlockEnable";
	prop_desc = "Specifies whether or not the Interlock should be enabled at startup.";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T1ID";
	prop_desc = "T1 Optical event ID";
	prop_def  = "21";
	vect_data.clear();
	vect_data.push_back("21");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "T2ID";
	prop_desc = "T2 Optical event ID";
	prop_def  = "62";
	vect_data.clear();
	vect_data.push_back("62");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
}

//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::write_class_property()
 *	Description : Set class description fields as property in database
 */
//--------------------------------------------------------
void LiberaBrilliancePlusClass::write_class_property()
{
	//	First time, check if database used
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("Libera BPM Device Server");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("IT Libera BPM Device Server.");
	str_desc.push_back("The interface should be the same as for the Brillance model.");
	description << str_desc;
	data.push_back(description);

	//	put cvs or svn location
	string	filename("LiberaBrilliancePlus");
	filename += "Class.cpp";

	// check for cvs information
	string	src_path(CvsPath);
	start = src_path.find("/");
	if (start!=string::npos)
	{
		end   = src_path.find(filename);
		if (end>start)
		{
			string	strloc = src_path.substr(start, end-start);
			//	Check if specific repository
			start = strloc.find("/cvsroot/");
			if (start!=string::npos && start>0)
			{
				string	repository = strloc.substr(0, start);
				if (repository.find("/segfs/")!=string::npos)
					strloc = "ESRF:" + strloc.substr(start, strloc.length()-start);
			}
			Tango::DbDatum	cvs_loc("cvs_location");
			cvs_loc << strloc;
			data.push_back(cvs_loc);
		}
	}

	// check for svn information
	else
	{
		string	src_path(SvnPath);
		start = src_path.find("://");
		if (start!=string::npos)
		{
			end = src_path.find(filename);
			if (end>start)
			{
				header = "$HeadURL: ";
				start = header.length();
				string	strloc = src_path.substr(start, (end-start));
				
				Tango::DbDatum	svn_loc("svn_location");
				svn_loc << strloc;
				data.push_back(svn_loc);
			}
		}
	}

	//	Get CVS or SVN revision tag
	
	// CVS tag
	string	tagname(TagName);
	header = "$Name: ";
	start = header.length();
	string	endstr(" $");
	
	end   = tagname.find(endstr);
	if (end!=string::npos && end>start)
	{
		string	strtag = tagname.substr(start, end-start);
		Tango::DbDatum	cvs_tag("cvs_tag");
		cvs_tag << strtag;
		data.push_back(cvs_tag);
	}
	
	// SVN tag
	string	svnpath(SvnPath);
	header = "$HeadURL: ";
	start = header.length();
	
	end   = svnpath.find(endstr);
	if (end!=string::npos && end>start)
	{
		string	strloc = svnpath.substr(start, end-start);
		
		string tagstr ("/tags/");
		start = strloc.find(tagstr);
		if ( start!=string::npos )
		{
			start = start + tagstr.length();
			end   = strloc.find(filename);
			string	strtag = strloc.substr(start, end-start-1);
			
			Tango::DbDatum	svn_tag("svn_tag");
			svn_tag << strtag;
			data.push_back(svn_tag);
		}
	}

	//	Get URL location
	string	httpServ(HttpServer);
	if (httpServ.length()>0)
	{
		Tango::DbDatum	db_doc_url("doc_url");
		db_doc_url << httpServ;
		data.push_back(db_doc_url);
	}

	//  Put inheritance
	Tango::DbDatum	inher_datum("InheritedFrom");
	vector<string> inheritance;
	inheritance.push_back("TANGO_BASE_CLASS");
	inher_datum << inheritance;
	data.push_back(inher_datum);

	//	Call database and and values
	get_db_class()->put_property(data);
}

//===================================================================
//	Factory methods
//===================================================================

//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::device_factory()
 *	Description : Create the device object(s)
 *                and store them in the device list
 */
//--------------------------------------------------------
void LiberaBrilliancePlusClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{
	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::device_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::device_factory_before

	//	Create devices and add it into the device list
	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
		device_list.push_back(new LiberaBrilliancePlus(this, (*devlist_ptr)[i]));
	}

	//	Manage dynamic attributes if any
	erase_dynamic_attributes(devlist_ptr, get_class_attr()->get_attr_list());

	//	Export devices to the outside world
	for (unsigned long i=1 ; i<=devlist_ptr->length() ; i++)
	{
		//	Add dynamic attributes if any
		LiberaBrilliancePlus *dev = static_cast<LiberaBrilliancePlus *>(device_list[device_list.size()-i]);
		dev->add_dynamic_attributes();

		//	Check before if database used.
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(dev);
		else
			export_device(dev, dev->get_name().c_str());
	}

	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::device_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::device_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::attribute_factory()
 *	Description : Create the attribute object(s)
 *                and store them in the attribute list
 */
//--------------------------------------------------------
void LiberaBrilliancePlusClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::attribute_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::attribute_factory_before
	//	Attribute : LiberaModel
	LiberaModelAttrib	*liberamodel = new LiberaModelAttrib();
	Tango::UserDefaultAttrProp	liberamodel_prop;
	liberamodel_prop.set_description("The Libera Model: 0:Electron, 1:Brillance, 2:Photon");
	liberamodel_prop.set_label("Libera Model");
	liberamodel_prop.set_unit("[0:e-, 1:br, 2:ph]");
	//	standard_unit	not set for LiberaModel
	//	display_unit	not set for LiberaModel
	liberamodel_prop.set_format("%d");
	//	max_value	not set for LiberaModel
	//	min_value	not set for LiberaModel
	//	max_alarm	not set for LiberaModel
	//	min_alarm	not set for LiberaModel
	//	max_warning	not set for LiberaModel
	//	min_warning	not set for LiberaModel
	//	delta_t	not set for LiberaModel
	//	delta_val	not set for LiberaModel
	
	liberamodel->set_default_properties(liberamodel_prop);
	//	Not Polled
	liberamodel->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(liberamodel);

	//	Attribute : DDEnabled
	DDEnabledAttrib	*ddenabled = new DDEnabledAttrib();
	Tango::UserDefaultAttrProp	ddenabled_prop;
	ddenabled_prop.set_description("DD data source activation flag");
	ddenabled_prop.set_label("DD Enabled");
	ddenabled_prop.set_unit("n/a");
	ddenabled_prop.set_standard_unit("n/a");
	ddenabled_prop.set_display_unit("n/a");
	//	format	not set for DDEnabled
	//	max_value	not set for DDEnabled
	//	min_value	not set for DDEnabled
	//	max_alarm	not set for DDEnabled
	//	min_alarm	not set for DDEnabled
	//	max_warning	not set for DDEnabled
	//	min_warning	not set for DDEnabled
	//	delta_t	not set for DDEnabled
	//	delta_val	not set for DDEnabled
	
	ddenabled->set_default_properties(ddenabled_prop);
	//	Not Polled
	ddenabled->set_disp_level(Tango::OPERATOR);
	ddenabled->set_memorized();
	ddenabled->set_memorized_init(true);
	att_list.push_back(ddenabled);

	//	Attribute : DDBufferSize
	DDBufferSizeAttrib	*ddbuffersize = new DDBufferSizeAttrib();
	Tango::UserDefaultAttrProp	ddbuffersize_prop;
	ddbuffersize_prop.set_description("The number of samples to be read on DD data source.\nInfluences the size of the associated attributes [such as XPosDD for instance].");
	ddbuffersize_prop.set_label("DD Buffer Size");
	ddbuffersize_prop.set_unit("turns");
	//	standard_unit	not set for DDBufferSize
	//	display_unit	not set for DDBufferSize
	ddbuffersize_prop.set_format("%5d");
	ddbuffersize_prop.set_max_value("65535");
	ddbuffersize_prop.set_min_value("2");
	//	max_alarm	not set for DDBufferSize
	//	min_alarm	not set for DDBufferSize
	//	max_warning	not set for DDBufferSize
	//	min_warning	not set for DDBufferSize
	//	delta_t	not set for DDBufferSize
	//	delta_val	not set for DDBufferSize
	
	ddbuffersize->set_default_properties(ddbuffersize_prop);
	//	Not Polled
	ddbuffersize->set_disp_level(Tango::OPERATOR);
	ddbuffersize->set_memorized();
	ddbuffersize->set_memorized_init(true);
	att_list.push_back(ddbuffersize);

	//	Attribute : DDDecimationFactor
	DDDecimationFactorAttrib	*dddecimationfactor = new DDDecimationFactorAttrib();
	Tango::UserDefaultAttrProp	dddecimationfactor_prop;
	dddecimationfactor_prop.set_description("The DD decimation factor");
	dddecimationfactor_prop.set_label("DD Decim. Factor");
	dddecimationfactor_prop.set_unit("samples");
	//	standard_unit	not set for DDDecimationFactor
	//	display_unit	not set for DDDecimationFactor
	dddecimationfactor_prop.set_format("%3d");
	dddecimationfactor_prop.set_max_value("256");
	dddecimationfactor_prop.set_min_value("1");
	//	max_alarm	not set for DDDecimationFactor
	//	min_alarm	not set for DDDecimationFactor
	//	max_warning	not set for DDDecimationFactor
	//	min_warning	not set for DDDecimationFactor
	//	delta_t	not set for DDDecimationFactor
	//	delta_val	not set for DDDecimationFactor
	
	dddecimationfactor->set_default_properties(dddecimationfactor_prop);
	//	Not Polled
	dddecimationfactor->set_disp_level(Tango::OPERATOR);
	dddecimationfactor->set_memorized();
	dddecimationfactor->set_memorized_init(true);
	att_list.push_back(dddecimationfactor);

	//	Attribute : DDTriggerOffset
	DDTriggerOffsetAttrib	*ddtriggeroffset = new DDTriggerOffsetAttrib();
	Tango::UserDefaultAttrProp	ddtriggeroffset_prop;
	ddtriggeroffset_prop.set_description("DD data offset in num. of turns");
	ddtriggeroffset_prop.set_label("DD Trigger Offset");
	ddtriggeroffset_prop.set_unit("turns");
	//	standard_unit	not set for DDTriggerOffset
	//	display_unit	not set for DDTriggerOffset
	ddtriggeroffset_prop.set_format("%6d");
	//	max_value	not set for DDTriggerOffset
	//	min_value	not set for DDTriggerOffset
	//	max_alarm	not set for DDTriggerOffset
	//	min_alarm	not set for DDTriggerOffset
	//	max_warning	not set for DDTriggerOffset
	//	min_warning	not set for DDTriggerOffset
	//	delta_t	not set for DDTriggerOffset
	//	delta_val	not set for DDTriggerOffset
	
	ddtriggeroffset->set_default_properties(ddtriggeroffset_prop);
	//	Not Polled
	ddtriggeroffset->set_disp_level(Tango::OPERATOR);
	ddtriggeroffset->set_memorized();
	ddtriggeroffset->set_memorized_init(true);
	att_list.push_back(ddtriggeroffset);

	//	Attribute : DDBufferFreezingEnabled
	DDBufferFreezingEnabledAttrib	*ddbufferfreezingenabled = new DDBufferFreezingEnabledAttrib();
	Tango::UserDefaultAttrProp	ddbufferfreezingenabled_prop;
	ddbufferfreezingenabled_prop.set_description("DD buffer freezing activation flag");
	ddbufferfreezingenabled_prop.set_label("DD Buffer Freezing Enabled");
	ddbufferfreezingenabled_prop.set_unit("n/a");
	ddbufferfreezingenabled_prop.set_standard_unit("n/a");
	ddbufferfreezingenabled_prop.set_display_unit("n/a");
	//	format	not set for DDBufferFreezingEnabled
	//	max_value	not set for DDBufferFreezingEnabled
	//	min_value	not set for DDBufferFreezingEnabled
	//	max_alarm	not set for DDBufferFreezingEnabled
	//	min_alarm	not set for DDBufferFreezingEnabled
	//	max_warning	not set for DDBufferFreezingEnabled
	//	min_warning	not set for DDBufferFreezingEnabled
	//	delta_t	not set for DDBufferFreezingEnabled
	//	delta_val	not set for DDBufferFreezingEnabled
	
	ddbufferfreezingenabled->set_default_properties(ddbufferfreezingenabled_prop);
	//	Not Polled
	ddbufferfreezingenabled->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ddbufferfreezingenabled);

	//	Attribute : DDBufferFrozen
	DDBufferFrozenAttrib	*ddbufferfrozen = new DDBufferFrozenAttrib();
	Tango::UserDefaultAttrProp	ddbufferfrozen_prop;
	ddbufferfrozen_prop.set_description("DD buffer status");
	ddbufferfrozen_prop.set_label("DD Buffer Frozen");
	ddbufferfrozen_prop.set_unit("n/a");
	ddbufferfrozen_prop.set_standard_unit("n/a");
	ddbufferfrozen_prop.set_display_unit("n/a");
	//	format	not set for DDBufferFrozen
	//	max_value	not set for DDBufferFrozen
	//	min_value	not set for DDBufferFrozen
	//	max_alarm	not set for DDBufferFrozen
	//	min_alarm	not set for DDBufferFrozen
	//	max_warning	not set for DDBufferFrozen
	//	min_warning	not set for DDBufferFrozen
	//	delta_t	not set for DDBufferFrozen
	//	delta_val	not set for DDBufferFrozen
	
	ddbufferfrozen->set_default_properties(ddbufferfrozen_prop);
	//	Not Polled
	ddbufferfrozen->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ddbufferfrozen);

	//	Attribute : DDTriggerCounter
	DDTriggerCounterAttrib	*ddtriggercounter = new DDTriggerCounterAttrib();
	Tango::UserDefaultAttrProp	ddtriggercounter_prop;
	ddtriggercounter_prop.set_description("Number of trigger notifications received since last device <init> ");
	ddtriggercounter_prop.set_label("Trig.Counter");
	ddtriggercounter_prop.set_unit("a.u.");
	ddtriggercounter_prop.set_standard_unit("a.u.");
	ddtriggercounter_prop.set_display_unit("a.u.");
	ddtriggercounter_prop.set_format("%8d");
	//	max_value	not set for DDTriggerCounter
	//	min_value	not set for DDTriggerCounter
	//	max_alarm	not set for DDTriggerCounter
	//	min_alarm	not set for DDTriggerCounter
	//	max_warning	not set for DDTriggerCounter
	//	min_warning	not set for DDTriggerCounter
	//	delta_t	not set for DDTriggerCounter
	//	delta_val	not set for DDTriggerCounter
	
	ddtriggercounter->set_default_properties(ddtriggercounter_prop);
	//	Not Polled
	ddtriggercounter->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ddtriggercounter);

	//	Attribute : ExternalTriggerEnabled
	ExternalTriggerEnabledAttrib	*externaltriggerenabled = new ExternalTriggerEnabledAttrib();
	Tango::UserDefaultAttrProp	externaltriggerenabled_prop;
	externaltriggerenabled_prop.set_description("External trigger activation flag");
	externaltriggerenabled_prop.set_label("Ext. Trig. Enabled");
	externaltriggerenabled_prop.set_unit("n/a");
	externaltriggerenabled_prop.set_standard_unit("n/a");
	externaltriggerenabled_prop.set_display_unit("n/a");
	//	format	not set for ExternalTriggerEnabled
	//	max_value	not set for ExternalTriggerEnabled
	//	min_value	not set for ExternalTriggerEnabled
	//	max_alarm	not set for ExternalTriggerEnabled
	//	min_alarm	not set for ExternalTriggerEnabled
	//	max_warning	not set for ExternalTriggerEnabled
	//	min_warning	not set for ExternalTriggerEnabled
	//	delta_t	not set for ExternalTriggerEnabled
	//	delta_val	not set for ExternalTriggerEnabled
	
	externaltriggerenabled->set_default_properties(externaltriggerenabled_prop);
	//	Not Polled
	externaltriggerenabled->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(externaltriggerenabled);

	//	Attribute : ExternalTriggerDelay
	ExternalTriggerDelayAttrib	*externaltriggerdelay = new ExternalTriggerDelayAttrib();
	Tango::UserDefaultAttrProp	externaltriggerdelay_prop;
	externaltriggerdelay_prop.set_description("Sets the delay on the external trigger arrival. \nThe delay is set in steps of ADC samples (~ 9 ns).");
	externaltriggerdelay_prop.set_label("External Trigger Delay");
	externaltriggerdelay_prop.set_unit("ADC samples");
	//	standard_unit	not set for ExternalTriggerDelay
	//	display_unit	not set for ExternalTriggerDelay
	externaltriggerdelay_prop.set_format("%6d");
	//	max_value	not set for ExternalTriggerDelay
	externaltriggerdelay_prop.set_min_value("0");
	//	max_alarm	not set for ExternalTriggerDelay
	//	min_alarm	not set for ExternalTriggerDelay
	//	max_warning	not set for ExternalTriggerDelay
	//	min_warning	not set for ExternalTriggerDelay
	//	delta_t	not set for ExternalTriggerDelay
	//	delta_val	not set for ExternalTriggerDelay
	
	externaltriggerdelay->set_default_properties(externaltriggerdelay_prop);
	//	Not Polled
	externaltriggerdelay->set_disp_level(Tango::OPERATOR);
	externaltriggerdelay->set_memorized();
	externaltriggerdelay->set_memorized_init(true);
	att_list.push_back(externaltriggerdelay);

	//	Attribute : SAEnabled
	SAEnabledAttrib	*saenabled = new SAEnabledAttrib();
	Tango::UserDefaultAttrProp	saenabled_prop;
	saenabled_prop.set_description("SA data source activation flag");
	saenabled_prop.set_label("SA Enabled");
	saenabled_prop.set_unit("n/a");
	saenabled_prop.set_standard_unit("n/a");
	saenabled_prop.set_display_unit("n/a");
	//	format	not set for SAEnabled
	//	max_value	not set for SAEnabled
	//	min_value	not set for SAEnabled
	//	max_alarm	not set for SAEnabled
	//	min_alarm	not set for SAEnabled
	//	max_warning	not set for SAEnabled
	//	min_warning	not set for SAEnabled
	//	delta_t	not set for SAEnabled
	//	delta_val	not set for SAEnabled
	
	saenabled->set_default_properties(saenabled_prop);
	//	Not Polled
	saenabled->set_disp_level(Tango::OPERATOR);
	saenabled->set_memorized();
	saenabled->set_memorized_init(true);
	att_list.push_back(saenabled);

	//	Attribute : VaSA
	VaSAAttrib	*vasa = new VaSAAttrib();
	Tango::UserDefaultAttrProp	vasa_prop;
	vasa_prop.set_description("Slow Acquisition: Va");
	vasa_prop.set_label("SA Va");
	vasa_prop.set_unit("a.u.");
	vasa_prop.set_standard_unit("a.u.");
	vasa_prop.set_display_unit("a.u.");
	vasa_prop.set_format("%10.0f");
	//	max_value	not set for VaSA
	//	min_value	not set for VaSA
	//	max_alarm	not set for VaSA
	//	min_alarm	not set for VaSA
	//	max_warning	not set for VaSA
	//	min_warning	not set for VaSA
	//	delta_t	not set for VaSA
	//	delta_val	not set for VaSA
	
	vasa->set_default_properties(vasa_prop);
	//	Not Polled
	vasa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vasa);

	//	Attribute : VbSA
	VbSAAttrib	*vbsa = new VbSAAttrib();
	Tango::UserDefaultAttrProp	vbsa_prop;
	vbsa_prop.set_description("Slow Acquisition: Vb");
	vbsa_prop.set_label("SA Vb");
	vbsa_prop.set_unit("a.u.");
	vbsa_prop.set_standard_unit("a.u.");
	vbsa_prop.set_display_unit("a.u.");
	vbsa_prop.set_format("%10.0f");
	//	max_value	not set for VbSA
	//	min_value	not set for VbSA
	//	max_alarm	not set for VbSA
	//	min_alarm	not set for VbSA
	//	max_warning	not set for VbSA
	//	min_warning	not set for VbSA
	//	delta_t	not set for VbSA
	//	delta_val	not set for VbSA
	
	vbsa->set_default_properties(vbsa_prop);
	//	Not Polled
	vbsa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vbsa);

	//	Attribute : VcSA
	VcSAAttrib	*vcsa = new VcSAAttrib();
	Tango::UserDefaultAttrProp	vcsa_prop;
	vcsa_prop.set_description("Slow Acquisition: Vc");
	vcsa_prop.set_label("SA Vc");
	vcsa_prop.set_unit("a.u.");
	vcsa_prop.set_standard_unit("a.u.");
	vcsa_prop.set_display_unit("a.u.");
	vcsa_prop.set_format("%10.0f");
	//	max_value	not set for VcSA
	//	min_value	not set for VcSA
	//	max_alarm	not set for VcSA
	//	min_alarm	not set for VcSA
	//	max_warning	not set for VcSA
	//	min_warning	not set for VcSA
	//	delta_t	not set for VcSA
	//	delta_val	not set for VcSA
	
	vcsa->set_default_properties(vcsa_prop);
	//	Not Polled
	vcsa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vcsa);

	//	Attribute : VdSA
	VdSAAttrib	*vdsa = new VdSAAttrib();
	Tango::UserDefaultAttrProp	vdsa_prop;
	vdsa_prop.set_description("Slow Acquisition: Vd");
	vdsa_prop.set_label("SA Vd");
	vdsa_prop.set_unit("a.u.");
	vdsa_prop.set_standard_unit("a.u.");
	vdsa_prop.set_display_unit("a.u.");
	vdsa_prop.set_format("%10.0f");
	//	max_value	not set for VdSA
	//	min_value	not set for VdSA
	//	max_alarm	not set for VdSA
	//	min_alarm	not set for VdSA
	//	max_warning	not set for VdSA
	//	min_warning	not set for VdSA
	//	delta_t	not set for VdSA
	//	delta_val	not set for VdSA
	
	vdsa->set_default_properties(vdsa_prop);
	//	Not Polled
	vdsa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vdsa);

	//	Attribute : XPosSA
	XPosSAAttrib	*xpossa = new XPosSAAttrib();
	Tango::UserDefaultAttrProp	xpossa_prop;
	xpossa_prop.set_description("Slow Acquisition: X");
	xpossa_prop.set_label("X.Pos.SA");
	xpossa_prop.set_unit("mm");
	//	standard_unit	not set for XPosSA
	//	display_unit	not set for XPosSA
	xpossa_prop.set_format("%8.2f");
	//	max_value	not set for XPosSA
	//	min_value	not set for XPosSA
	//	max_alarm	not set for XPosSA
	//	min_alarm	not set for XPosSA
	//	max_warning	not set for XPosSA
	//	min_warning	not set for XPosSA
	//	delta_t	not set for XPosSA
	//	delta_val	not set for XPosSA
	
	xpossa->set_default_properties(xpossa_prop);
	//	Not Polled
	xpossa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xpossa);

	//	Attribute : YPosSA
	YPosSAAttrib	*ypossa = new YPosSAAttrib();
	Tango::UserDefaultAttrProp	ypossa_prop;
	ypossa_prop.set_description("Slow Acquisition: Y");
	ypossa_prop.set_label("Y.Pos.SA");
	ypossa_prop.set_unit("mm");
	//	standard_unit	not set for YPosSA
	//	display_unit	not set for YPosSA
	ypossa_prop.set_format("%8.2f");
	//	max_value	not set for YPosSA
	//	min_value	not set for YPosSA
	//	max_alarm	not set for YPosSA
	//	min_alarm	not set for YPosSA
	//	max_warning	not set for YPosSA
	//	min_warning	not set for YPosSA
	//	delta_t	not set for YPosSA
	//	delta_val	not set for YPosSA
	
	ypossa->set_default_properties(ypossa_prop);
	//	Not Polled
	ypossa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ypossa);

	//	Attribute : SumSA
	SumSAAttrib	*sumsa = new SumSAAttrib();
	Tango::UserDefaultAttrProp	sumsa_prop;
	sumsa_prop.set_description("Slow Acquisition: Sum");
	sumsa_prop.set_label("Sum SA");
	sumsa_prop.set_unit("a.u.");
	//	standard_unit	not set for SumSA
	//	display_unit	not set for SumSA
	sumsa_prop.set_format("%10.0f");
	//	max_value	not set for SumSA
	//	min_value	not set for SumSA
	//	max_alarm	not set for SumSA
	//	min_alarm	not set for SumSA
	//	max_warning	not set for SumSA
	//	min_warning	not set for SumSA
	//	delta_t	not set for SumSA
	//	delta_val	not set for SumSA
	
	sumsa->set_default_properties(sumsa_prop);
	//	Not Polled
	sumsa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(sumsa);

	//	Attribute : QuadSA
	QuadSAAttrib	*quadsa = new QuadSAAttrib();
	Tango::UserDefaultAttrProp	quadsa_prop;
	quadsa_prop.set_description("Slow Acquisition: Quad");
	quadsa_prop.set_label("Quad SA");
	quadsa_prop.set_unit("a.u.");
	//	standard_unit	not set for QuadSA
	//	display_unit	not set for QuadSA
	quadsa_prop.set_format("%8.4f");
	//	max_value	not set for QuadSA
	//	min_value	not set for QuadSA
	//	max_alarm	not set for QuadSA
	//	min_alarm	not set for QuadSA
	//	max_warning	not set for QuadSA
	//	min_warning	not set for QuadSA
	//	delta_t	not set for QuadSA
	//	delta_val	not set for QuadSA
	
	quadsa->set_default_properties(quadsa_prop);
	//	Not Polled
	quadsa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(quadsa);

	//	Attribute : CxSA
	CxSAAttrib	*cxsa = new CxSAAttrib();
	Tango::UserDefaultAttrProp	cxsa_prop;
	cxsa_prop.set_description("FOFB X correction sent to the power supply");
	cxsa_prop.set_label("FOFB X Correction");
	cxsa_prop.set_unit("a.u.");
	//	standard_unit	not set for CxSA
	//	display_unit	not set for CxSA
	cxsa_prop.set_format("%8d");
	//	max_value	not set for CxSA
	//	min_value	not set for CxSA
	//	max_alarm	not set for CxSA
	//	min_alarm	not set for CxSA
	//	max_warning	not set for CxSA
	//	min_warning	not set for CxSA
	//	delta_t	not set for CxSA
	//	delta_val	not set for CxSA
	
	cxsa->set_default_properties(cxsa_prop);
	//	Not Polled
	cxsa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(cxsa);

	//	Attribute : CySA
	CySAAttrib	*cysa = new CySAAttrib();
	Tango::UserDefaultAttrProp	cysa_prop;
	cysa_prop.set_description("FOFB Y correction sent to the power supply");
	cysa_prop.set_label("FOFB Y Correction");
	cysa_prop.set_unit("a.u.");
	//	standard_unit	not set for CySA
	//	display_unit	not set for CySA
	cysa_prop.set_format("%8d");
	//	max_value	not set for CySA
	//	min_value	not set for CySA
	//	max_alarm	not set for CySA
	//	min_alarm	not set for CySA
	//	max_warning	not set for CySA
	//	min_warning	not set for CySA
	//	delta_t	not set for CySA
	//	delta_val	not set for CySA
	
	cysa->set_default_properties(cysa_prop);
	//	Not Polled
	cysa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(cysa);

	//	Attribute : SAStatNumSamples
	SAStatNumSamplesAttrib	*sastatnumsamples = new SAStatNumSamplesAttrib();
	Tango::UserDefaultAttrProp	sastatnumsamples_prop;
	sastatnumsamples_prop.set_description("The number of sample in SA history used to compute the SA statistics\n(Mean, RMS, Peak pos). The most recent samples will be used.\nThe valid range is [2, SAHistoryLength property value].\n");
	sastatnumsamples_prop.set_label("SA Stats.Num.Samples.");
	sastatnumsamples_prop.set_unit("samples");
	//	standard_unit	not set for SAStatNumSamples
	//	display_unit	not set for SAStatNumSamples
	sastatnumsamples_prop.set_format("%5d");
	sastatnumsamples_prop.set_max_value("65535");
	sastatnumsamples_prop.set_min_value("2");
	//	max_alarm	not set for SAStatNumSamples
	//	min_alarm	not set for SAStatNumSamples
	//	max_warning	not set for SAStatNumSamples
	//	min_warning	not set for SAStatNumSamples
	//	delta_t	not set for SAStatNumSamples
	//	delta_val	not set for SAStatNumSamples
	
	sastatnumsamples->set_default_properties(sastatnumsamples_prop);
	//	Not Polled
	sastatnumsamples->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(sastatnumsamples);

	//	Attribute : XMeanPosSA
	XMeanPosSAAttrib	*xmeanpossa = new XMeanPosSAAttrib();
	Tango::UserDefaultAttrProp	xmeanpossa_prop;
	xmeanpossa_prop.set_description("Slow Acquisition:  arithmetic average from history values");
	xmeanpossa_prop.set_label("SA X Mean Pos.");
	xmeanpossa_prop.set_unit("mm");
	//	standard_unit	not set for XMeanPosSA
	//	display_unit	not set for XMeanPosSA
	xmeanpossa_prop.set_format("%8.4f");
	//	max_value	not set for XMeanPosSA
	//	min_value	not set for XMeanPosSA
	//	max_alarm	not set for XMeanPosSA
	//	min_alarm	not set for XMeanPosSA
	//	max_warning	not set for XMeanPosSA
	//	min_warning	not set for XMeanPosSA
	//	delta_t	not set for XMeanPosSA
	//	delta_val	not set for XMeanPosSA
	
	xmeanpossa->set_default_properties(xmeanpossa_prop);
	//	Not Polled
	xmeanpossa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xmeanpossa);

	//	Attribute : YMeanPosSA
	YMeanPosSAAttrib	*ymeanpossa = new YMeanPosSAAttrib();
	Tango::UserDefaultAttrProp	ymeanpossa_prop;
	ymeanpossa_prop.set_description("Slow Acquisition:  arithmetic average from history values");
	ymeanpossa_prop.set_label("SA Y Mean Pos.");
	ymeanpossa_prop.set_unit("mm");
	//	standard_unit	not set for YMeanPosSA
	//	display_unit	not set for YMeanPosSA
	ymeanpossa_prop.set_format("%8.4f");
	//	max_value	not set for YMeanPosSA
	//	min_value	not set for YMeanPosSA
	//	max_alarm	not set for YMeanPosSA
	//	min_alarm	not set for YMeanPosSA
	//	max_warning	not set for YMeanPosSA
	//	min_warning	not set for YMeanPosSA
	//	delta_t	not set for YMeanPosSA
	//	delta_val	not set for YMeanPosSA
	
	ymeanpossa->set_default_properties(ymeanpossa_prop);
	//	Not Polled
	ymeanpossa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ymeanpossa);

	//	Attribute : XRMSPosSA
	XRMSPosSAAttrib	*xrmspossa = new XRMSPosSAAttrib();
	Tango::UserDefaultAttrProp	xrmspossa_prop;
	xrmspossa_prop.set_description("Slow Acquisition:  X root mean square from histry samples sqrt(Xi^2-mean^2)/N^2");
	xrmspossa_prop.set_label("SA X RMS Pos.");
	xrmspossa_prop.set_unit("um");
	//	standard_unit	not set for XRMSPosSA
	//	display_unit	not set for XRMSPosSA
	xrmspossa_prop.set_format("%8.2f");
	//	max_value	not set for XRMSPosSA
	//	min_value	not set for XRMSPosSA
	//	max_alarm	not set for XRMSPosSA
	//	min_alarm	not set for XRMSPosSA
	//	max_warning	not set for XRMSPosSA
	//	min_warning	not set for XRMSPosSA
	//	delta_t	not set for XRMSPosSA
	//	delta_val	not set for XRMSPosSA
	
	xrmspossa->set_default_properties(xrmspossa_prop);
	//	Not Polled
	xrmspossa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xrmspossa);

	//	Attribute : YRMSPosSA
	YRMSPosSAAttrib	*yrmspossa = new YRMSPosSAAttrib();
	Tango::UserDefaultAttrProp	yrmspossa_prop;
	yrmspossa_prop.set_description("Slow Acquisition: Y root mean square from histry samples sqrt(Xi^2-mean^2)/N^2.");
	yrmspossa_prop.set_label("SA Y RMS Pos.");
	yrmspossa_prop.set_unit("um");
	//	standard_unit	not set for YRMSPosSA
	//	display_unit	not set for YRMSPosSA
	yrmspossa_prop.set_format("%8.2f");
	//	max_value	not set for YRMSPosSA
	//	min_value	not set for YRMSPosSA
	//	max_alarm	not set for YRMSPosSA
	//	min_alarm	not set for YRMSPosSA
	//	max_warning	not set for YRMSPosSA
	//	min_warning	not set for YRMSPosSA
	//	delta_t	not set for YRMSPosSA
	//	delta_val	not set for YRMSPosSA
	
	yrmspossa->set_default_properties(yrmspossa_prop);
	//	Not Polled
	yrmspossa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(yrmspossa);

	//	Attribute : XPeakPosSA
	XPeakPosSAAttrib	*xpeakpossa = new XPeakPosSAAttrib();
	Tango::UserDefaultAttrProp	xpeakpossa_prop;
	xpeakpossa_prop.set_description("Slow Acquisition: X difference between max and min value from history");
	xpeakpossa_prop.set_label("X.Peak.Pos.SA");
	xpeakpossa_prop.set_unit("um");
	//	standard_unit	not set for XPeakPosSA
	//	display_unit	not set for XPeakPosSA
	xpeakpossa_prop.set_format("%8.2f");
	//	max_value	not set for XPeakPosSA
	//	min_value	not set for XPeakPosSA
	//	max_alarm	not set for XPeakPosSA
	//	min_alarm	not set for XPeakPosSA
	//	max_warning	not set for XPeakPosSA
	//	min_warning	not set for XPeakPosSA
	//	delta_t	not set for XPeakPosSA
	//	delta_val	not set for XPeakPosSA
	
	xpeakpossa->set_default_properties(xpeakpossa_prop);
	//	Not Polled
	xpeakpossa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xpeakpossa);

	//	Attribute : YPeakPosSA
	YPeakPosSAAttrib	*ypeakpossa = new YPeakPosSAAttrib();
	Tango::UserDefaultAttrProp	ypeakpossa_prop;
	ypeakpossa_prop.set_description("Slow Acquisition: Y difference between max and min value from history");
	ypeakpossa_prop.set_label("Y.Peak.Pos.SA");
	ypeakpossa_prop.set_unit("um");
	//	standard_unit	not set for YPeakPosSA
	//	display_unit	not set for YPeakPosSA
	ypeakpossa_prop.set_format("%8.2f");
	//	max_value	not set for YPeakPosSA
	//	min_value	not set for YPeakPosSA
	//	max_alarm	not set for YPeakPosSA
	//	min_alarm	not set for YPeakPosSA
	//	max_warning	not set for YPeakPosSA
	//	min_warning	not set for YPeakPosSA
	//	delta_t	not set for YPeakPosSA
	//	delta_val	not set for YPeakPosSA
	
	ypeakpossa->set_default_properties(ypeakpossa_prop);
	//	Not Polled
	ypeakpossa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ypeakpossa);

	//	Attribute : SumMeanSA
	SumMeanSAAttrib	*summeansa = new SumMeanSAAttrib();
	Tango::UserDefaultAttrProp	summeansa_prop;
	summeansa_prop.set_description("SA: mean of sum");
	summeansa_prop.set_label("SA Sum Mean");
	summeansa_prop.set_unit("a.u.");
	summeansa_prop.set_standard_unit("a.u.");
	summeansa_prop.set_display_unit("a.u.");
	summeansa_prop.set_format("%8.1f");
	//	max_value	not set for SumMeanSA
	//	min_value	not set for SumMeanSA
	//	max_alarm	not set for SumMeanSA
	//	min_alarm	not set for SumMeanSA
	//	max_warning	not set for SumMeanSA
	//	min_warning	not set for SumMeanSA
	//	delta_t	not set for SumMeanSA
	//	delta_val	not set for SumMeanSA
	
	summeansa->set_default_properties(summeansa_prop);
	//	Not Polled
	summeansa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(summeansa);

	//	Attribute : ADCEnabled
	ADCEnabledAttrib	*adcenabled = new ADCEnabledAttrib();
	Tango::UserDefaultAttrProp	adcenabled_prop;
	adcenabled_prop.set_description("ADC data source activation flag");
	adcenabled_prop.set_label("ADC Enabled");
	adcenabled_prop.set_unit("n/a");
	adcenabled_prop.set_standard_unit("n/a");
	adcenabled_prop.set_display_unit("n/a");
	//	format	not set for ADCEnabled
	//	max_value	not set for ADCEnabled
	//	min_value	not set for ADCEnabled
	//	max_alarm	not set for ADCEnabled
	//	min_alarm	not set for ADCEnabled
	//	max_warning	not set for ADCEnabled
	//	min_warning	not set for ADCEnabled
	//	delta_t	not set for ADCEnabled
	//	delta_val	not set for ADCEnabled
	
	adcenabled->set_default_properties(adcenabled_prop);
	//	Not Polled
	adcenabled->set_disp_level(Tango::OPERATOR);
	adcenabled->set_memorized();
	adcenabled->set_memorized_init(true);
	att_list.push_back(adcenabled);

	//	Attribute : ADCBufferSize
	ADCBufferSizeAttrib	*adcbuffersize = new ADCBufferSizeAttrib();
	Tango::UserDefaultAttrProp	adcbuffersize_prop;
	adcbuffersize_prop.set_description("The number of samples to be read on ADC data source.\nInfluences the size of the associated attributes [such as ADCChannelA for instance].");
	adcbuffersize_prop.set_label("ADC Buffer Size");
	adcbuffersize_prop.set_unit("samples");
	//	standard_unit	not set for ADCBufferSize
	//	display_unit	not set for ADCBufferSize
	adcbuffersize_prop.set_format("%5d");
	adcbuffersize_prop.set_max_value("65535");
	adcbuffersize_prop.set_min_value("8");
	//	max_alarm	not set for ADCBufferSize
	//	min_alarm	not set for ADCBufferSize
	//	max_warning	not set for ADCBufferSize
	//	min_warning	not set for ADCBufferSize
	//	delta_t	not set for ADCBufferSize
	//	delta_val	not set for ADCBufferSize
	
	adcbuffersize->set_default_properties(adcbuffersize_prop);
	//	Not Polled
	adcbuffersize->set_disp_level(Tango::OPERATOR);
	adcbuffersize->set_memorized();
	adcbuffersize->set_memorized_init(true);
	att_list.push_back(adcbuffersize);

	//	Attribute : PMOffset
	PMOffsetAttrib	*pmoffset = new PMOffsetAttrib();
	Tango::UserDefaultAttrProp	pmoffset_prop;
	pmoffset_prop.set_description("Offset relative to the post mortem event setting. \nSet value is in turns, e.g. 1024 would mean that post mortem \nacquisition is starting 1024 turns after the post mortem trigger \nwas received.");
	pmoffset_prop.set_label("Post Mortem Offset");
	pmoffset_prop.set_unit("samples");
	//	standard_unit	not set for PMOffset
	//	display_unit	not set for PMOffset
	pmoffset_prop.set_format("%3d");
	pmoffset_prop.set_max_value("10000");
	pmoffset_prop.set_min_value("-10000");
	//	max_alarm	not set for PMOffset
	//	min_alarm	not set for PMOffset
	//	max_warning	not set for PMOffset
	//	min_warning	not set for PMOffset
	//	delta_t	not set for PMOffset
	//	delta_val	not set for PMOffset
	
	pmoffset->set_default_properties(pmoffset_prop);
	//	Not Polled
	pmoffset->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(pmoffset);

	//	Attribute : PMNotified
	PMNotifiedAttrib	*pmnotified = new PMNotifiedAttrib();
	Tango::UserDefaultAttrProp	pmnotified_prop;
	pmnotified_prop.set_description("Post Moterm notification flag");
	pmnotified_prop.set_label("Post Moterm Notified");
	pmnotified_prop.set_unit("n/a");
	//	standard_unit	not set for PMNotified
	//	display_unit	not set for PMNotified
	//	format	not set for PMNotified
	//	max_value	not set for PMNotified
	//	min_value	not set for PMNotified
	//	max_alarm	not set for PMNotified
	//	min_alarm	not set for PMNotified
	//	max_warning	not set for PMNotified
	//	min_warning	not set for PMNotified
	//	delta_t	not set for PMNotified
	//	delta_val	not set for PMNotified
	
	pmnotified->set_default_properties(pmnotified_prop);
	//	Not Polled
	pmnotified->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(pmnotified);

	//	Attribute : PMNotificationCounter
	PMNotificationCounterAttrib	*pmnotificationcounter = new PMNotificationCounterAttrib();
	Tango::UserDefaultAttrProp	pmnotificationcounter_prop;
	pmnotificationcounter_prop.set_description("Number a PM event recieved since last Init");
	pmnotificationcounter_prop.set_label("PM Notif. Counter");
	//	unit	not set for PMNotificationCounter
	//	standard_unit	not set for PMNotificationCounter
	//	display_unit	not set for PMNotificationCounter
	pmnotificationcounter_prop.set_format("%8d");
	//	max_value	not set for PMNotificationCounter
	//	min_value	not set for PMNotificationCounter
	//	max_alarm	not set for PMNotificationCounter
	//	min_alarm	not set for PMNotificationCounter
	//	max_warning	not set for PMNotificationCounter
	//	min_warning	not set for PMNotificationCounter
	//	delta_t	not set for PMNotificationCounter
	//	delta_val	not set for PMNotificationCounter
	
	pmnotificationcounter->set_default_properties(pmnotificationcounter_prop);
	//	Not Polled
	pmnotificationcounter->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(pmnotificationcounter);

	//	Attribute : InterlockXNotified
	InterlockXNotifiedAttrib	*interlockxnotified = new InterlockXNotifiedAttrib();
	Tango::UserDefaultAttrProp	interlockxnotified_prop;
	interlockxnotified_prop.set_description("Sets to 1 if X position trip caused the Interlock event.");
	//	label	not set for InterlockXNotified
	//	unit	not set for InterlockXNotified
	//	standard_unit	not set for InterlockXNotified
	//	display_unit	not set for InterlockXNotified
	//	format	not set for InterlockXNotified
	//	max_value	not set for InterlockXNotified
	//	min_value	not set for InterlockXNotified
	//	max_alarm	not set for InterlockXNotified
	//	min_alarm	not set for InterlockXNotified
	//	max_warning	not set for InterlockXNotified
	//	min_warning	not set for InterlockXNotified
	//	delta_t	not set for InterlockXNotified
	//	delta_val	not set for InterlockXNotified
	
	interlockxnotified->set_default_properties(interlockxnotified_prop);
	//	Not Polled
	interlockxnotified->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(interlockxnotified);

	//	Attribute : InterlockYNotified
	InterlockYNotifiedAttrib	*interlockynotified = new InterlockYNotifiedAttrib();
	Tango::UserDefaultAttrProp	interlockynotified_prop;
	interlockynotified_prop.set_description("Sets to 1 if Yposition trip caused the Interlock event.");
	//	label	not set for InterlockYNotified
	//	unit	not set for InterlockYNotified
	//	standard_unit	not set for InterlockYNotified
	//	display_unit	not set for InterlockYNotified
	//	format	not set for InterlockYNotified
	//	max_value	not set for InterlockYNotified
	//	min_value	not set for InterlockYNotified
	//	max_alarm	not set for InterlockYNotified
	//	min_alarm	not set for InterlockYNotified
	//	max_warning	not set for InterlockYNotified
	//	min_warning	not set for InterlockYNotified
	//	delta_t	not set for InterlockYNotified
	//	delta_val	not set for InterlockYNotified
	
	interlockynotified->set_default_properties(interlockynotified_prop);
	//	Not Polled
	interlockynotified->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(interlockynotified);

	//	Attribute : InterlockAttnNotified
	InterlockAttnNotifiedAttrib	*interlockattnnotified = new InterlockAttnNotifiedAttrib();
	Tango::UserDefaultAttrProp	interlockattnnotified_prop;
	interlockattnnotified_prop.set_description("Sets to 1 if the attenuator's value is higher than gain \ndependence threshold");
	//	label	not set for InterlockAttnNotified
	//	unit	not set for InterlockAttnNotified
	//	standard_unit	not set for InterlockAttnNotified
	//	display_unit	not set for InterlockAttnNotified
	//	format	not set for InterlockAttnNotified
	//	max_value	not set for InterlockAttnNotified
	//	min_value	not set for InterlockAttnNotified
	//	max_alarm	not set for InterlockAttnNotified
	//	min_alarm	not set for InterlockAttnNotified
	//	max_warning	not set for InterlockAttnNotified
	//	min_warning	not set for InterlockAttnNotified
	//	delta_t	not set for InterlockAttnNotified
	//	delta_val	not set for InterlockAttnNotified
	
	interlockattnnotified->set_default_properties(interlockattnnotified_prop);
	//	Not Polled
	interlockattnnotified->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(interlockattnnotified);

	//	Attribute : InterlockADCPreFilterNotified
	InterlockADCPreFilterNotifiedAttrib	*interlockadcprefilternotified = new InterlockADCPreFilterNotifiedAttrib();
	Tango::UserDefaultAttrProp	interlockadcprefilternotified_prop;
	interlockadcprefilternotified_prop.set_description("ADC overflow without filtering.");
	//	label	not set for InterlockADCPreFilterNotified
	//	unit	not set for InterlockADCPreFilterNotified
	//	standard_unit	not set for InterlockADCPreFilterNotified
	//	display_unit	not set for InterlockADCPreFilterNotified
	//	format	not set for InterlockADCPreFilterNotified
	//	max_value	not set for InterlockADCPreFilterNotified
	//	min_value	not set for InterlockADCPreFilterNotified
	//	max_alarm	not set for InterlockADCPreFilterNotified
	//	min_alarm	not set for InterlockADCPreFilterNotified
	//	max_warning	not set for InterlockADCPreFilterNotified
	//	min_warning	not set for InterlockADCPreFilterNotified
	//	delta_t	not set for InterlockADCPreFilterNotified
	//	delta_val	not set for InterlockADCPreFilterNotified
	
	interlockadcprefilternotified->set_default_properties(interlockadcprefilternotified_prop);
	//	Not Polled
	interlockadcprefilternotified->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(interlockadcprefilternotified);

	//	Attribute : InterlockADCPostFilterNotified
	InterlockADCPostFilterNotifiedAttrib	*interlockadcpostfilternotified = new InterlockADCPostFilterNotifiedAttrib();
	Tango::UserDefaultAttrProp	interlockadcpostfilternotified_prop;
	interlockadcpostfilternotified_prop.set_description("ADC overflow with filtering.");
	//	label	not set for InterlockADCPostFilterNotified
	//	unit	not set for InterlockADCPostFilterNotified
	//	standard_unit	not set for InterlockADCPostFilterNotified
	//	display_unit	not set for InterlockADCPostFilterNotified
	//	format	not set for InterlockADCPostFilterNotified
	//	max_value	not set for InterlockADCPostFilterNotified
	//	min_value	not set for InterlockADCPostFilterNotified
	//	max_alarm	not set for InterlockADCPostFilterNotified
	//	min_alarm	not set for InterlockADCPostFilterNotified
	//	max_warning	not set for InterlockADCPostFilterNotified
	//	min_warning	not set for InterlockADCPostFilterNotified
	//	delta_t	not set for InterlockADCPostFilterNotified
	//	delta_val	not set for InterlockADCPostFilterNotified
	
	interlockadcpostfilternotified->set_default_properties(interlockadcpostfilternotified_prop);
	//	Not Polled
	interlockadcpostfilternotified->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(interlockadcpostfilternotified);

	//	Attribute : XLow
	XLowAttrib	*xlow = new XLowAttrib();
	Tango::UserDefaultAttrProp	xlow_prop;
	xlow_prop.set_description("Lower limit of the X position interlock threshold in mm");
	xlow_prop.set_label("X Low Int. Thres.");
	xlow_prop.set_unit("mm");
	//	standard_unit	not set for XLow
	//	display_unit	not set for XLow
	xlow_prop.set_format("%8.4f");
	//	max_value	not set for XLow
	//	min_value	not set for XLow
	//	max_alarm	not set for XLow
	//	min_alarm	not set for XLow
	//	max_warning	not set for XLow
	//	min_warning	not set for XLow
	//	delta_t	not set for XLow
	//	delta_val	not set for XLow
	
	xlow->set_default_properties(xlow_prop);
	//	Not Polled
	xlow->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(xlow);

	//	Attribute : XHigh
	XHighAttrib	*xhigh = new XHighAttrib();
	Tango::UserDefaultAttrProp	xhigh_prop;
	xhigh_prop.set_description("Upper limit of the X position interlock threshold in mm");
	xhigh_prop.set_label("X High Int. Thres.");
	xhigh_prop.set_unit("mm");
	//	standard_unit	not set for XHigh
	//	display_unit	not set for XHigh
	xhigh_prop.set_format("%8.4f");
	//	max_value	not set for XHigh
	//	min_value	not set for XHigh
	//	max_alarm	not set for XHigh
	//	min_alarm	not set for XHigh
	//	max_warning	not set for XHigh
	//	min_warning	not set for XHigh
	//	delta_t	not set for XHigh
	//	delta_val	not set for XHigh
	
	xhigh->set_default_properties(xhigh_prop);
	//	Not Polled
	xhigh->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(xhigh);

	//	Attribute : YLow
	YLowAttrib	*ylow = new YLowAttrib();
	Tango::UserDefaultAttrProp	ylow_prop;
	ylow_prop.set_description("Lower limit of the Y position interlock threshold in mm");
	ylow_prop.set_label("Y Low Int. Thres.");
	ylow_prop.set_unit("mm");
	//	standard_unit	not set for YLow
	//	display_unit	not set for YLow
	ylow_prop.set_format("%8.4f");
	//	max_value	not set for YLow
	//	min_value	not set for YLow
	//	max_alarm	not set for YLow
	//	min_alarm	not set for YLow
	//	max_warning	not set for YLow
	//	min_warning	not set for YLow
	//	delta_t	not set for YLow
	//	delta_val	not set for YLow
	
	ylow->set_default_properties(ylow_prop);
	//	Not Polled
	ylow->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(ylow);

	//	Attribute : YHigh
	YHighAttrib	*yhigh = new YHighAttrib();
	Tango::UserDefaultAttrProp	yhigh_prop;
	yhigh_prop.set_description("Upper limit of the Y position interlock threshold in mm");
	yhigh_prop.set_label("Y High Int. Thres.");
	yhigh_prop.set_unit("mm");
	//	standard_unit	not set for YHigh
	//	display_unit	not set for YHigh
	yhigh_prop.set_format("%8.4f");
	//	max_value	not set for YHigh
	//	min_value	not set for YHigh
	//	max_alarm	not set for YHigh
	//	min_alarm	not set for YHigh
	//	max_warning	not set for YHigh
	//	min_warning	not set for YHigh
	//	delta_t	not set for YHigh
	//	delta_val	not set for YHigh
	
	yhigh->set_default_properties(yhigh_prop);
	//	Not Polled
	yhigh->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(yhigh);

	//	Attribute : AutoSwitchingEnabled
	AutoSwitchingEnabledAttrib	*autoswitchingenabled = new AutoSwitchingEnabledAttrib();
	Tango::UserDefaultAttrProp	autoswitchingenabled_prop;
	autoswitchingenabled_prop.set_description("Enables / disables the switching mechanism.");
	autoswitchingenabled_prop.set_label("Auto switching enabled");
	autoswitchingenabled_prop.set_unit("n/a");
	autoswitchingenabled_prop.set_standard_unit("n/a");
	autoswitchingenabled_prop.set_display_unit("n/a");
	//	format	not set for AutoSwitchingEnabled
	//	max_value	not set for AutoSwitchingEnabled
	//	min_value	not set for AutoSwitchingEnabled
	//	max_alarm	not set for AutoSwitchingEnabled
	//	min_alarm	not set for AutoSwitchingEnabled
	//	max_warning	not set for AutoSwitchingEnabled
	//	min_warning	not set for AutoSwitchingEnabled
	//	delta_t	not set for AutoSwitchingEnabled
	//	delta_val	not set for AutoSwitchingEnabled
	
	autoswitchingenabled->set_default_properties(autoswitchingenabled_prop);
	//	Not Polled
	autoswitchingenabled->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(autoswitchingenabled);

	//	Attribute : Switches
	SwitchesAttrib	*switches = new SwitchesAttrib();
	Tango::UserDefaultAttrProp	switches_prop;
	switches_prop.set_description("Switches selection. Must be in [0, 15] or 255 for auto-switching.");
	switches_prop.set_label("Switches");
	switches_prop.set_unit("a.u.");
	//	standard_unit	not set for Switches
	//	display_unit	not set for Switches
	switches_prop.set_format("%3d");
	switches_prop.set_max_value("255");
	switches_prop.set_min_value("0");
	//	max_alarm	not set for Switches
	//	min_alarm	not set for Switches
	//	max_warning	not set for Switches
	//	min_warning	not set for Switches
	//	delta_t	not set for Switches
	//	delta_val	not set for Switches
	
	switches->set_default_properties(switches_prop);
	//	Not Polled
	switches->set_disp_level(Tango::OPERATOR);
	switches->set_memorized();
	switches->set_memorized_init(true);
	att_list.push_back(switches);

	//	Attribute : ExternalSwitching
	ExternalSwitchingAttrib	*externalswitching = new ExternalSwitchingAttrib();
	Tango::UserDefaultAttrProp	externalswitching_prop;
	externalswitching_prop.set_description("Sets the source of switching clock  MC (external) or from the \noscillator (internal). Default value is internal. ");
	externalswitching_prop.set_label("External Switching");
	//	unit	not set for ExternalSwitching
	//	standard_unit	not set for ExternalSwitching
	//	display_unit	not set for ExternalSwitching
	//	format	not set for ExternalSwitching
	//	max_value	not set for ExternalSwitching
	//	min_value	not set for ExternalSwitching
	//	max_alarm	not set for ExternalSwitching
	//	min_alarm	not set for ExternalSwitching
	//	max_warning	not set for ExternalSwitching
	//	min_warning	not set for ExternalSwitching
	//	delta_t	not set for ExternalSwitching
	//	delta_val	not set for ExternalSwitching
	
	externalswitching->set_default_properties(externalswitching_prop);
	//	Not Polled
	externalswitching->set_disp_level(Tango::OPERATOR);
	externalswitching->set_memorized();
	externalswitching->set_memorized_init(true);
	att_list.push_back(externalswitching);

	//	Attribute : SwitchingDelay
	SwitchingDelayAttrib	*switchingdelay = new SwitchingDelayAttrib();
	Tango::UserDefaultAttrProp	switchingdelay_prop;
	switchingdelay_prop.set_description("Sets the delay of the switch position change relative to the \nswitching source clock.");
	switchingdelay_prop.set_label("Switching Delay");
	switchingdelay_prop.set_unit("a.u.");
	//	standard_unit	not set for SwitchingDelay
	switchingdelay_prop.set_display_unit("%6d");
	//	format	not set for SwitchingDelay
	//	max_value	not set for SwitchingDelay
	switchingdelay_prop.set_min_value("0");
	//	max_alarm	not set for SwitchingDelay
	//	min_alarm	not set for SwitchingDelay
	//	max_warning	not set for SwitchingDelay
	//	min_warning	not set for SwitchingDelay
	//	delta_t	not set for SwitchingDelay
	//	delta_val	not set for SwitchingDelay
	
	switchingdelay->set_default_properties(switchingdelay_prop);
	//	Not Polled
	switchingdelay->set_disp_level(Tango::OPERATOR);
	switchingdelay->set_memorized();
	switchingdelay->set_memorized_init(true);
	att_list.push_back(switchingdelay);

	//	Attribute : OffsetTune
	OffsetTuneAttrib	*offsettune = new OffsetTuneAttrib();
	Tango::UserDefaultAttrProp	offsettune_prop;
	offsettune_prop.set_description("Sets the offset tune value, 1 unit is approximately 40 Hz. \nDefault value is 0 (precisely tuned).");
	offsettune_prop.set_label("OffsetTune");
	offsettune_prop.set_unit("x 40Hz");
	//	standard_unit	not set for OffsetTune
	//	display_unit	not set for OffsetTune
	offsettune_prop.set_format("%3d");
	offsettune_prop.set_max_value("500");
	offsettune_prop.set_min_value("-500");
	//	max_alarm	not set for OffsetTune
	//	min_alarm	not set for OffsetTune
	//	max_warning	not set for OffsetTune
	//	min_warning	not set for OffsetTune
	//	delta_t	not set for OffsetTune
	//	delta_val	not set for OffsetTune
	
	offsettune->set_default_properties(offsettune_prop);
	//	Not Polled
	offsettune->set_disp_level(Tango::OPERATOR);
	offsettune->set_memorized();
	offsettune->set_memorized_init(true);
	att_list.push_back(offsettune);

	//	Attribute : CompensateTune
	CompensateTuneAttrib	*compensatetune = new CompensateTuneAttrib();
	Tango::UserDefaultAttrProp	compensatetune_prop;
	compensatetune_prop.set_description("To enable double offset-tune, issue the following command \n(to disable it, just use false instead of true).");
	compensatetune_prop.set_label("Compensate Tune");
	//	unit	not set for CompensateTune
	//	standard_unit	not set for CompensateTune
	//	display_unit	not set for CompensateTune
	//	format	not set for CompensateTune
	//	max_value	not set for CompensateTune
	//	min_value	not set for CompensateTune
	//	max_alarm	not set for CompensateTune
	//	min_alarm	not set for CompensateTune
	//	max_warning	not set for CompensateTune
	//	min_warning	not set for CompensateTune
	//	delta_t	not set for CompensateTune
	//	delta_val	not set for CompensateTune
	
	compensatetune->set_default_properties(compensatetune_prop);
	//	Not Polled
	compensatetune->set_disp_level(Tango::OPERATOR);
	compensatetune->set_memorized();
	compensatetune->set_memorized_init(true);
	att_list.push_back(compensatetune);

	//	Attribute : DSCMode
	DSCModeAttrib	*dscmode = new DSCModeAttrib();
	Tango::UserDefaultAttrProp	dscmode_prop;
	dscmode_prop.set_description("Sets the adjustment (learning) of the amplitude and \nphase coefficients true or false. Set the \ncoefficients' type  adjusted or unity. Combination of \nthese two nodes is necessary to achieve backward \ncompatiblity.");
	dscmode_prop.set_label("DSC Mode");
	dscmode_prop.set_unit("[0:OFF, 1:UNITY, 2:AUTO]");
	//	standard_unit	not set for DSCMode
	//	display_unit	not set for DSCMode
	dscmode_prop.set_format("%1d");
	dscmode_prop.set_max_value("2");
	dscmode_prop.set_min_value("0");
	//	max_alarm	not set for DSCMode
	//	min_alarm	not set for DSCMode
	//	max_warning	not set for DSCMode
	//	min_warning	not set for DSCMode
	//	delta_t	not set for DSCMode
	//	delta_val	not set for DSCMode
	
	dscmode->set_default_properties(dscmode_prop);
	//	Not Polled
	dscmode->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(dscmode);

	//	Attribute : AGCEnabled
	AGCEnabledAttrib	*agcenabled = new AGCEnabledAttrib();
	Tango::UserDefaultAttrProp	agcenabled_prop;
	agcenabled_prop.set_description("Enables/disables the Automatic Gain Control");
	agcenabled_prop.set_label("AGC");
	//	unit	not set for AGCEnabled
	//	standard_unit	not set for AGCEnabled
	//	display_unit	not set for AGCEnabled
	//	format	not set for AGCEnabled
	//	max_value	not set for AGCEnabled
	//	min_value	not set for AGCEnabled
	//	max_alarm	not set for AGCEnabled
	//	min_alarm	not set for AGCEnabled
	//	max_warning	not set for AGCEnabled
	//	min_warning	not set for AGCEnabled
	//	delta_t	not set for AGCEnabled
	//	delta_val	not set for AGCEnabled
	
	agcenabled->set_default_properties(agcenabled_prop);
	//	Not Polled
	agcenabled->set_disp_level(Tango::OPERATOR);
	agcenabled->set_memorized();
	agcenabled->set_memorized_init(true);
	att_list.push_back(agcenabled);

	//	Attribute : Gain
	GainAttrib	*gain = new GainAttrib();
	Tango::UserDefaultAttrProp	gain_prop;
	gain_prop.set_description("Sets the power_level. Attenuation at chosen level \ndepends on the gain scheme configuration. AGC \nmust be disabled to use manual Gain setting.");
	gain_prop.set_label("Gain");
	gain_prop.set_unit("dBm");
	gain_prop.set_standard_unit("dBm");
	gain_prop.set_display_unit("dBm");
	gain_prop.set_format("%2.0f");
	gain_prop.set_max_value("0");
	gain_prop.set_min_value("-60");
	//	max_alarm	not set for Gain
	//	min_alarm	not set for Gain
	//	max_warning	not set for Gain
	//	min_warning	not set for Gain
	//	delta_t	not set for Gain
	//	delta_val	not set for Gain
	
	gain->set_default_properties(gain_prop);
	//	Not Polled
	gain->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(gain);

	//	Attribute : HasMAFSupport
	HasMAFSupportAttrib	*hasmafsupport = new HasMAFSupportAttrib();
	Tango::UserDefaultAttrProp	hasmafsupport_prop;
	hasmafsupport_prop.set_description("<true> if FGPA design with MAF support installed on Libera, <false> otherwise");
	hasmafsupport_prop.set_label("Moving Average Filter Support");
	//	unit	not set for HasMAFSupport
	//	standard_unit	not set for HasMAFSupport
	//	display_unit	not set for HasMAFSupport
	//	format	not set for HasMAFSupport
	//	max_value	not set for HasMAFSupport
	//	min_value	not set for HasMAFSupport
	//	max_alarm	not set for HasMAFSupport
	//	min_alarm	not set for HasMAFSupport
	//	max_warning	not set for HasMAFSupport
	//	min_warning	not set for HasMAFSupport
	//	delta_t	not set for HasMAFSupport
	//	delta_val	not set for HasMAFSupport
	
	hasmafsupport->set_default_properties(hasmafsupport_prop);
	//	Not Polled
	hasmafsupport->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(hasmafsupport);

	//	Attribute : MAFLength
	MAFLengthAttrib	*maflength = new MAFLengthAttrib();
	Tango::UserDefaultAttrProp	maflength_prop;
	maflength_prop.set_description("MAF Delay and MAF Length are two\nparameters, added to adjustable\nDDC design. They are used to\ndetermine the position and the length\nof the acquisition window according\nto the partial fill of the accelerator.");
	maflength_prop.set_label("Moving Average Filter Length");
	maflength_prop.set_unit("ADC samples");
	//	standard_unit	not set for MAFLength
	//	display_unit	not set for MAFLength
	maflength_prop.set_format("%6d");
	//	max_value	not set for MAFLength
	maflength_prop.set_min_value("1");
	//	max_alarm	not set for MAFLength
	//	min_alarm	not set for MAFLength
	//	max_warning	not set for MAFLength
	//	min_warning	not set for MAFLength
	//	delta_t	not set for MAFLength
	//	delta_val	not set for MAFLength
	
	maflength->set_default_properties(maflength_prop);
	//	Not Polled
	maflength->set_disp_level(Tango::OPERATOR);
	maflength->set_memorized();
	maflength->set_memorized_init(true);
	att_list.push_back(maflength);

	//	Attribute : MAFDelay
	MAFDelayAttrib	*mafdelay = new MAFDelayAttrib();
	Tango::UserDefaultAttrProp	mafdelay_prop;
	mafdelay_prop.set_description("MAF Delay and MAF Length are two\nparameters, added to adjustable\nDDC design. They are used to\ndetermine the position and the length\nof the acquisition window according\nto the partial fill of the accelerator.\n");
	mafdelay_prop.set_label("Moving Average Filter Delay");
	mafdelay_prop.set_unit("ADC samples");
	//	standard_unit	not set for MAFDelay
	//	display_unit	not set for MAFDelay
	mafdelay_prop.set_format("%6d");
	//	max_value	not set for MAFDelay
	mafdelay_prop.set_min_value("0");
	//	max_alarm	not set for MAFDelay
	//	min_alarm	not set for MAFDelay
	//	max_warning	not set for MAFDelay
	//	min_warning	not set for MAFDelay
	//	delta_t	not set for MAFDelay
	//	delta_val	not set for MAFDelay
	
	mafdelay->set_default_properties(mafdelay_prop);
	//	Not Polled
	mafdelay->set_disp_level(Tango::OPERATOR);
	mafdelay->set_memorized();
	mafdelay->set_memorized_init(true);
	att_list.push_back(mafdelay);

	//	Attribute : MachineTime
	MachineTimeAttrib	*machinetime = new MachineTimeAttrib();
	Tango::UserDefaultAttrProp	machinetime_prop;
	machinetime_prop.set_description("Machine Time value to be applied on the Libera when the SetTimeOnNextTrigger command is executed");
	machinetime_prop.set_label("Machine Time");
	machinetime_prop.set_unit("a.u.");
	//	standard_unit	not set for MachineTime
	//	display_unit	not set for MachineTime
	machinetime_prop.set_format("%9d");
	//	max_value	not set for MachineTime
	machinetime_prop.set_min_value("0");
	//	max_alarm	not set for MachineTime
	//	min_alarm	not set for MachineTime
	//	max_warning	not set for MachineTime
	//	min_warning	not set for MachineTime
	//	delta_t	not set for MachineTime
	//	delta_val	not set for MachineTime
	
	machinetime->set_default_properties(machinetime_prop);
	//	Not Polled
	machinetime->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(machinetime);

	//	Attribute : TimePhase
	TimePhaseAttrib	*timephase = new TimePhaseAttrib();
	Tango::UserDefaultAttrProp	timephase_prop;
	timephase_prop.set_description("The Machine Time Phase");
	timephase_prop.set_label("Machine Time Phase");
	timephase_prop.set_unit("a.u.");
	//	standard_unit	not set for TimePhase
	//	display_unit	not set for TimePhase
	timephase_prop.set_format("%6d");
	//	max_value	not set for TimePhase
	//	min_value	not set for TimePhase
	//	max_alarm	not set for TimePhase
	//	min_alarm	not set for TimePhase
	//	max_warning	not set for TimePhase
	//	min_warning	not set for TimePhase
	//	delta_t	not set for TimePhase
	//	delta_val	not set for TimePhase
	
	timephase->set_default_properties(timephase_prop);
	//	Not Polled
	timephase->set_disp_level(Tango::OPERATOR);
	timephase->set_memorized();
	timephase->set_memorized_init(true);
	att_list.push_back(timephase);

	//	Attribute : SystemTime
	SystemTimeAttrib	*systemtime = new SystemTimeAttrib();
	Tango::UserDefaultAttrProp	systemtime_prop;
	systemtime_prop.set_description("System Time value to be applied on the Libera when the SetTimeOnNextTrigger command is executed\nUnit is num of secs since 1/1/1970 (Unix system time reference)");
	systemtime_prop.set_label("System Time");
	systemtime_prop.set_unit("secs since 1/1/1970");
	//	standard_unit	not set for SystemTime
	//	display_unit	not set for SystemTime
	systemtime_prop.set_format("%10d");
	//	max_value	not set for SystemTime
	systemtime_prop.set_min_value("2000000000");
	//	max_alarm	not set for SystemTime
	//	min_alarm	not set for SystemTime
	//	max_warning	not set for SystemTime
	//	min_warning	not set for SystemTime
	//	delta_t	not set for SystemTime
	//	delta_val	not set for SystemTime
	
	systemtime->set_default_properties(systemtime_prop);
	//	Not Polled
	systemtime->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(systemtime);

	//	Attribute : SCPLLStatus
	SCPLLStatusAttrib	*scpllstatus = new SCPLLStatusAttrib();
	Tango::UserDefaultAttrProp	scpllstatus_prop;
	scpllstatus_prop.set_description("The SC PLL lock status");
	scpllstatus_prop.set_label("SC PLL Locked");
	//	unit	not set for SCPLLStatus
	//	standard_unit	not set for SCPLLStatus
	//	display_unit	not set for SCPLLStatus
	scpllstatus_prop.set_format("%8d");
	//	max_value	not set for SCPLLStatus
	//	min_value	not set for SCPLLStatus
	//	max_alarm	not set for SCPLLStatus
	//	min_alarm	not set for SCPLLStatus
	//	max_warning	not set for SCPLLStatus
	//	min_warning	not set for SCPLLStatus
	//	delta_t	not set for SCPLLStatus
	//	delta_val	not set for SCPLLStatus
	
	scpllstatus->set_default_properties(scpllstatus_prop);
	//	Not Polled
	scpllstatus->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(scpllstatus);

	//	Attribute : MCPLLStatus
	MCPLLStatusAttrib	*mcpllstatus = new MCPLLStatusAttrib();
	Tango::UserDefaultAttrProp	mcpllstatus_prop;
	mcpllstatus_prop.set_description("Indicates the MC PLL status (1=locked, 0=unlocked)");
	mcpllstatus_prop.set_label("MC PLL Locked");
	//	unit	not set for MCPLLStatus
	//	standard_unit	not set for MCPLLStatus
	//	display_unit	not set for MCPLLStatus
	mcpllstatus_prop.set_format("%8d");
	//	max_value	not set for MCPLLStatus
	//	min_value	not set for MCPLLStatus
	//	max_alarm	not set for MCPLLStatus
	//	min_alarm	not set for MCPLLStatus
	//	max_warning	not set for MCPLLStatus
	//	min_warning	not set for MCPLLStatus
	//	delta_t	not set for MCPLLStatus
	//	delta_val	not set for MCPLLStatus
	
	mcpllstatus->set_default_properties(mcpllstatus_prop);
	//	Not Polled
	mcpllstatus->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(mcpllstatus);

	//	Attribute : Temp1
	Temp1Attrib	*temp1 = new Temp1Attrib();
	Tango::UserDefaultAttrProp	temp1_prop;
	temp1_prop.set_description("Temperature of the hottest component on the BPM \nmodule is returned.");
	temp1_prop.set_label("Temperature 1");
	temp1_prop.set_unit("deg.C");
	//	standard_unit	not set for Temp1
	//	display_unit	not set for Temp1
	temp1_prop.set_format("%8d");
	//	max_value	not set for Temp1
	//	min_value	not set for Temp1
	temp1_prop.set_max_alarm("65");
	//	min_alarm	not set for Temp1
	//	max_warning	not set for Temp1
	//	min_warning	not set for Temp1
	//	delta_t	not set for Temp1
	//	delta_val	not set for Temp1
	
	temp1->set_default_properties(temp1_prop);
	//	Not Polled
	temp1->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(temp1);

	//	Attribute : Temp2
	Temp2Attrib	*temp2 = new Temp2Attrib();
	Tango::UserDefaultAttrProp	temp2_prop;
	temp2_prop.set_description("Temperature of the hottest component on the chassis \ninterconnection board is returned.");
	temp2_prop.set_label("Temperature 2");
	temp2_prop.set_unit("deg.C");
	//	standard_unit	not set for Temp2
	//	display_unit	not set for Temp2
	temp2_prop.set_format("%8d");
	//	max_value	not set for Temp2
	//	min_value	not set for Temp2
	temp2_prop.set_max_alarm("65");
	//	min_alarm	not set for Temp2
	//	max_warning	not set for Temp2
	//	min_warning	not set for Temp2
	//	delta_t	not set for Temp2
	//	delta_val	not set for Temp2
	
	temp2->set_default_properties(temp2_prop);
	//	Not Polled
	temp2->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(temp2);

	//	Attribute : Temp3
	Temp3Attrib	*temp3 = new Temp3Attrib();
	Tango::UserDefaultAttrProp	temp3_prop;
	temp3_prop.set_description("Temperature of the hottest component on the timing \nmodule is returned.");
	temp3_prop.set_label("Temperature 3");
	temp3_prop.set_unit("deg.C");
	//	standard_unit	not set for Temp3
	//	display_unit	not set for Temp3
	temp3_prop.set_format("%8d");
	//	max_value	not set for Temp3
	//	min_value	not set for Temp3
	temp3_prop.set_max_alarm("65");
	//	min_alarm	not set for Temp3
	//	max_warning	not set for Temp3
	//	min_warning	not set for Temp3
	//	delta_t	not set for Temp3
	//	delta_val	not set for Temp3
	
	temp3->set_default_properties(temp3_prop);
	//	Not Polled
	temp3->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(temp3);

	//	Attribute : Fan1Speed
	Fan1SpeedAttrib	*fan1speed = new Fan1SpeedAttrib();
	Tango::UserDefaultAttrProp	fan1speed_prop;
	fan1speed_prop.set_description("Provides minimal fan speed reading of all three fans on \nthe left side of the chassis in order to identify if the fan \nmodule (consisting of 3 fans) is broken  returned value \n0 means that at least one fan has stopped.");
	fan1speed_prop.set_label("Fan.1");
	fan1speed_prop.set_unit("rpm");
	//	standard_unit	not set for Fan1Speed
	//	display_unit	not set for Fan1Speed
	fan1speed_prop.set_format("%8d");
	//	max_value	not set for Fan1Speed
	//	min_value	not set for Fan1Speed
	//	max_alarm	not set for Fan1Speed
	fan1speed_prop.set_min_alarm("1000");
	//	max_warning	not set for Fan1Speed
	//	min_warning	not set for Fan1Speed
	//	delta_t	not set for Fan1Speed
	//	delta_val	not set for Fan1Speed
	
	fan1speed->set_default_properties(fan1speed_prop);
	//	Not Polled
	fan1speed->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(fan1speed);

	//	Attribute : Fan2Speed
	Fan2SpeedAttrib	*fan2speed = new Fan2SpeedAttrib();
	Tango::UserDefaultAttrProp	fan2speed_prop;
	fan2speed_prop.set_description("Provides minimal fan speed reading of all three fans on \nthe right side of the chassis in order to identify if the fan \nmodule (consisting of 3 fans) is broken  returned value \n0 means that at least one fan has stopped.");
	fan2speed_prop.set_label("Fan.2");
	fan2speed_prop.set_unit("rpm");
	//	standard_unit	not set for Fan2Speed
	//	display_unit	not set for Fan2Speed
	fan2speed_prop.set_format("%8d");
	//	max_value	not set for Fan2Speed
	//	min_value	not set for Fan2Speed
	//	max_alarm	not set for Fan2Speed
	fan2speed_prop.set_min_alarm("1000");
	//	max_warning	not set for Fan2Speed
	//	min_warning	not set for Fan2Speed
	//	delta_t	not set for Fan2Speed
	//	delta_val	not set for Fan2Speed
	
	fan2speed->set_default_properties(fan2speed_prop);
	//	Not Polled
	fan2speed->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(fan2speed);

	//	Attribute : Incoherence
	IncoherenceAttrib	*incoherence = new IncoherenceAttrib();
	Tango::UserDefaultAttrProp	incoherence_prop;
	incoherence_prop.set_description("Result of the incoherence calculation. Am alarm will be set \non the attribute when an incoherence was detected.");
	incoherence_prop.set_label("Incoherence");
	incoherence_prop.set_unit("a.u.");
	//	standard_unit	not set for Incoherence
	//	display_unit	not set for Incoherence
	incoherence_prop.set_format("%6.4f");
	//	max_value	not set for Incoherence
	//	min_value	not set for Incoherence
	//	max_alarm	not set for Incoherence
	//	min_alarm	not set for Incoherence
	//	max_warning	not set for Incoherence
	//	min_warning	not set for Incoherence
	//	delta_t	not set for Incoherence
	//	delta_val	not set for Incoherence
	
	incoherence->set_default_properties(incoherence_prop);
	//	Not Polled
	incoherence->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(incoherence);

	//	Attribute : RefIncoherence
	RefIncoherenceAttrib	*refincoherence = new RefIncoherenceAttrib();
	Tango::UserDefaultAttrProp	refincoherence_prop;
	refincoherence_prop.set_description("The reference incoherence value registered with the command \nSetReferenceIncoherence. The reference is used to calculate the\nalarm with the MaxIncoherenceDrift.");
	refincoherence_prop.set_label("Ref. Incoherence");
	refincoherence_prop.set_unit("a.u.");
	//	standard_unit	not set for RefIncoherence
	//	display_unit	not set for RefIncoherence
	refincoherence_prop.set_format("%6.4f");
	//	max_value	not set for RefIncoherence
	//	min_value	not set for RefIncoherence
	//	max_alarm	not set for RefIncoherence
	//	min_alarm	not set for RefIncoherence
	//	max_warning	not set for RefIncoherence
	//	min_warning	not set for RefIncoherence
	//	delta_t	not set for RefIncoherence
	//	delta_val	not set for RefIncoherence
	
	refincoherence->set_default_properties(refincoherence_prop);
	//	Not Polled
	refincoherence->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(refincoherence);

	//	Attribute : MaxIncoherence
	MaxIncoherenceAttrib	*maxincoherence = new MaxIncoherenceAttrib();
	Tango::UserDefaultAttrProp	maxincoherence_prop;
	maxincoherence_prop.set_description("Maximum incoherence value. Used to create an alarm on\nthe Incoherence attribute.");
	maxincoherence_prop.set_label("Max. incoherence");
	maxincoherence_prop.set_unit("a.u.");
	//	standard_unit	not set for MaxIncoherence
	//	display_unit	not set for MaxIncoherence
	maxincoherence_prop.set_format("%6.4f");
	//	max_value	not set for MaxIncoherence
	//	min_value	not set for MaxIncoherence
	//	max_alarm	not set for MaxIncoherence
	//	min_alarm	not set for MaxIncoherence
	//	max_warning	not set for MaxIncoherence
	//	min_warning	not set for MaxIncoherence
	//	delta_t	not set for MaxIncoherence
	//	delta_val	not set for MaxIncoherence
	
	maxincoherence->set_default_properties(maxincoherence_prop);
	//	Not Polled
	maxincoherence->set_disp_level(Tango::OPERATOR);
	maxincoherence->set_memorized();
	maxincoherence->set_memorized_init(true);
	att_list.push_back(maxincoherence);

	//	Attribute : MaxIncoherenceDrift
	MaxIncoherenceDriftAttrib	*maxincoherencedrift = new MaxIncoherenceDriftAttrib();
	Tango::UserDefaultAttrProp	maxincoherencedrift_prop;
	maxincoherencedrift_prop.set_description("Maximum incoherence drift value. Used to create an alarm on\nthe Incoherence attribute.");
	maxincoherencedrift_prop.set_label("Max. Incoherence Drift ");
	maxincoherencedrift_prop.set_unit("a.u.");
	//	standard_unit	not set for MaxIncoherenceDrift
	//	display_unit	not set for MaxIncoherenceDrift
	maxincoherencedrift_prop.set_format("%6.4f");
	//	max_value	not set for MaxIncoherenceDrift
	//	min_value	not set for MaxIncoherenceDrift
	//	max_alarm	not set for MaxIncoherenceDrift
	//	min_alarm	not set for MaxIncoherenceDrift
	//	max_warning	not set for MaxIncoherenceDrift
	//	min_warning	not set for MaxIncoherenceDrift
	//	delta_t	not set for MaxIncoherenceDrift
	//	delta_val	not set for MaxIncoherenceDrift
	
	maxincoherencedrift->set_default_properties(maxincoherencedrift_prop);
	//	Not Polled
	maxincoherencedrift->set_disp_level(Tango::OPERATOR);
	maxincoherencedrift->set_memorized();
	maxincoherencedrift->set_memorized_init(true);
	att_list.push_back(maxincoherencedrift);

	//	Attribute : UpTime
	UpTimeAttrib	*uptime = new UpTimeAttrib();
	Tango::UserDefaultAttrProp	uptime_prop;
	uptime_prop.set_description("Number of seconds since system boot on the host running this TANGO device");
	uptime_prop.set_label("Uptime");
	uptime_prop.set_unit("secs");
	//	standard_unit	not set for UpTime
	//	display_unit	not set for UpTime
	uptime_prop.set_format("%8d");
	//	max_value	not set for UpTime
	//	min_value	not set for UpTime
	//	max_alarm	not set for UpTime
	//	min_alarm	not set for UpTime
	//	max_warning	not set for UpTime
	//	min_warning	not set for UpTime
	//	delta_t	not set for UpTime
	//	delta_val	not set for UpTime
	
	uptime->set_default_properties(uptime_prop);
	//	Not Polled
	uptime->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(uptime);

	//	Attribute : CpuUsage
	CpuUsageAttrib	*cpuusage = new CpuUsageAttrib();
	Tango::UserDefaultAttrProp	cpuusage_prop;
	cpuusage_prop.set_description("CPU usage on the host running this TANGO device");
	cpuusage_prop.set_label("CPU Usage");
	cpuusage_prop.set_unit("%");
	//	standard_unit	not set for CpuUsage
	//	display_unit	not set for CpuUsage
	cpuusage_prop.set_format("%8d");
	//	max_value	not set for CpuUsage
	//	min_value	not set for CpuUsage
	//	max_alarm	not set for CpuUsage
	//	min_alarm	not set for CpuUsage
	//	max_warning	not set for CpuUsage
	//	min_warning	not set for CpuUsage
	//	delta_t	not set for CpuUsage
	//	delta_val	not set for CpuUsage
	
	cpuusage->set_default_properties(cpuusage_prop);
	//	Not Polled
	cpuusage->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(cpuusage);

	//	Attribute : FreeMemory
	FreeMemoryAttrib	*freememory = new FreeMemoryAttrib();
	Tango::UserDefaultAttrProp	freememory_prop;
	freememory_prop.set_description("Amount of free memory on the host running this TANGO device");
	freememory_prop.set_label("Free Mem.");
	freememory_prop.set_unit("bytes");
	//	standard_unit	not set for FreeMemory
	//	display_unit	not set for FreeMemory
	freememory_prop.set_format("%8d");
	//	max_value	not set for FreeMemory
	//	min_value	not set for FreeMemory
	//	max_alarm	not set for FreeMemory
	//	min_alarm	not set for FreeMemory
	//	max_warning	not set for FreeMemory
	//	min_warning	not set for FreeMemory
	//	delta_t	not set for FreeMemory
	//	delta_val	not set for FreeMemory
	
	freememory->set_default_properties(freememory_prop);
	//	Not Polled
	freememory->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(freememory);

	//	Attribute : RamFsUsage
	RamFsUsageAttrib	*ramfsusage = new RamFsUsageAttrib();
	Tango::UserDefaultAttrProp	ramfsusage_prop;
	ramfsusage_prop.set_description("Amount of ram-fs allocated bytes on the host running this TANGO device ");
	ramfsusage_prop.set_label("Ram-fs Usage");
	ramfsusage_prop.set_unit("bytes");
	//	standard_unit	not set for RamFsUsage
	//	display_unit	not set for RamFsUsage
	ramfsusage_prop.set_format("%8d");
	//	max_value	not set for RamFsUsage
	//	min_value	not set for RamFsUsage
	//	max_alarm	not set for RamFsUsage
	//	min_alarm	not set for RamFsUsage
	//	max_warning	not set for RamFsUsage
	//	min_warning	not set for RamFsUsage
	//	delta_t	not set for RamFsUsage
	//	delta_val	not set for RamFsUsage
	
	ramfsusage->set_default_properties(ramfsusage_prop);
	//	Not Polled
	ramfsusage->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ramfsusage);

	//	Attribute : UseLiberaSAData
	UseLiberaSADataAttrib	*useliberasadata = new UseLiberaSADataAttrib();
	Tango::UserDefaultAttrProp	useliberasadata_prop;
	useliberasadata_prop.set_description("If set to true, the X & Z SA postions are retreived from the Libera FPGA.\nOtherwise, they are computed by the Tango device using the button values.\n ");
	useliberasadata_prop.set_label("Use Libera SA Data");
	//	unit	not set for UseLiberaSAData
	//	standard_unit	not set for UseLiberaSAData
	//	display_unit	not set for UseLiberaSAData
	//	format	not set for UseLiberaSAData
	//	max_value	not set for UseLiberaSAData
	//	min_value	not set for UseLiberaSAData
	//	max_alarm	not set for UseLiberaSAData
	//	min_alarm	not set for UseLiberaSAData
	//	max_warning	not set for UseLiberaSAData
	//	min_warning	not set for UseLiberaSAData
	//	delta_t	not set for UseLiberaSAData
	//	delta_val	not set for UseLiberaSAData
	
	useliberasadata->set_default_properties(useliberasadata_prop);
	//	Not Polled
	useliberasadata->set_disp_level(Tango::EXPERT);
	useliberasadata->set_memorized();
	useliberasadata->set_memorized_init(true);
	att_list.push_back(useliberasadata);

	//	Attribute : InterlockEnabled
	InterlockEnabledAttrib	*interlockenabled = new InterlockEnabledAttrib();
	Tango::UserDefaultAttrProp	interlockenabled_prop;
	interlockenabled_prop.set_description("Enables / disables the Interlock detection.");
	interlockenabled_prop.set_label("Interlock Enabled");
	interlockenabled_prop.set_unit("n/a");
	interlockenabled_prop.set_standard_unit("n/a");
	interlockenabled_prop.set_display_unit("n/a");
	//	format	not set for InterlockEnabled
	//	max_value	not set for InterlockEnabled
	//	min_value	not set for InterlockEnabled
	//	max_alarm	not set for InterlockEnabled
	//	min_alarm	not set for InterlockEnabled
	//	max_warning	not set for InterlockEnabled
	//	min_warning	not set for InterlockEnabled
	//	delta_t	not set for InterlockEnabled
	//	delta_val	not set for InterlockEnabled
	
	interlockenabled->set_default_properties(interlockenabled_prop);
	//	Not Polled
	interlockenabled->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(interlockenabled);

	//	Attribute : InterlockGainDependentEnabled
	InterlockGainDependentEnabledAttrib	*interlockgaindependentenabled = new InterlockGainDependentEnabledAttrib();
	Tango::UserDefaultAttrProp	interlockgaindependentenabled_prop;
	interlockgaindependentenabled_prop.set_description("Enables / disables gain dependent mode of Interlock operation.");
	interlockgaindependentenabled_prop.set_label("Interlock Gain Dependence Enabled");
	interlockgaindependentenabled_prop.set_unit("n/a");
	interlockgaindependentenabled_prop.set_standard_unit("n/a");
	interlockgaindependentenabled_prop.set_display_unit("n/a");
	//	format	not set for InterlockGainDependentEnabled
	//	max_value	not set for InterlockGainDependentEnabled
	//	min_value	not set for InterlockGainDependentEnabled
	//	max_alarm	not set for InterlockGainDependentEnabled
	//	min_alarm	not set for InterlockGainDependentEnabled
	//	max_warning	not set for InterlockGainDependentEnabled
	//	min_warning	not set for InterlockGainDependentEnabled
	//	delta_t	not set for InterlockGainDependentEnabled
	//	delta_val	not set for InterlockGainDependentEnabled
	
	interlockgaindependentenabled->set_default_properties(interlockgaindependentenabled_prop);
	//	Not Polled
	interlockgaindependentenabled->set_disp_level(Tango::OPERATOR);
	interlockgaindependentenabled->set_memorized();
	interlockgaindependentenabled->set_memorized_init(true);
	att_list.push_back(interlockgaindependentenabled);

	//	Attribute : InterlockOverflowThreshold
	InterlockOverflowThresholdAttrib	*interlockoverflowthreshold = new InterlockOverflowThresholdAttrib();
	Tango::UserDefaultAttrProp	interlockoverflowthreshold_prop;
	interlockoverflowthreshold_prop.set_description("ADC saturation threshold.");
	interlockoverflowthreshold_prop.set_label("interlock overflow");
	interlockoverflowthreshold_prop.set_unit("a.u.");
	//	standard_unit	not set for InterlockOverflowThreshold
	//	display_unit	not set for InterlockOverflowThreshold
	interlockoverflowthreshold_prop.set_format("%5d");
	interlockoverflowthreshold_prop.set_max_value("32766");
	interlockoverflowthreshold_prop.set_min_value("0");
	//	max_alarm	not set for InterlockOverflowThreshold
	//	min_alarm	not set for InterlockOverflowThreshold
	//	max_warning	not set for InterlockOverflowThreshold
	//	min_warning	not set for InterlockOverflowThreshold
	//	delta_t	not set for InterlockOverflowThreshold
	//	delta_val	not set for InterlockOverflowThreshold
	
	interlockoverflowthreshold->set_default_properties(interlockoverflowthreshold_prop);
	//	Not Polled
	interlockoverflowthreshold->set_disp_level(Tango::OPERATOR);
	interlockoverflowthreshold->set_memorized();
	interlockoverflowthreshold->set_memorized_init(true);
	att_list.push_back(interlockoverflowthreshold);

	//	Attribute : InterlockOverflowDuration
	InterlockOverflowDurationAttrib	*interlockoverflowduration = new InterlockOverflowDurationAttrib();
	Tango::UserDefaultAttrProp	interlockoverflowduration_prop;
	interlockoverflowduration_prop.set_description("Duration of allowed ADC saturation (in ADC samples).");
	interlockoverflowduration_prop.set_label("interlock overflow duration");
	interlockoverflowduration_prop.set_unit("a.u.");
	//	standard_unit	not set for InterlockOverflowDuration
	//	display_unit	not set for InterlockOverflowDuration
	interlockoverflowduration_prop.set_format("%5d");
	interlockoverflowduration_prop.set_max_value("1023");
	interlockoverflowduration_prop.set_min_value("0");
	//	max_alarm	not set for InterlockOverflowDuration
	//	min_alarm	not set for InterlockOverflowDuration
	//	max_warning	not set for InterlockOverflowDuration
	//	min_warning	not set for InterlockOverflowDuration
	//	delta_t	not set for InterlockOverflowDuration
	//	delta_val	not set for InterlockOverflowDuration
	
	interlockoverflowduration->set_default_properties(interlockoverflowduration_prop);
	//	Not Polled
	interlockoverflowduration->set_disp_level(Tango::OPERATOR);
	interlockoverflowduration->set_memorized();
	interlockoverflowduration->set_memorized_init(true);
	att_list.push_back(interlockoverflowduration);

	//	Attribute : InterlockGainDependentThreshold
	InterlockGainDependentThresholdAttrib	*interlockgaindependentthreshold = new InterlockGainDependentThresholdAttrib();
	Tango::UserDefaultAttrProp	interlockgaindependentthreshold_prop;
	interlockgaindependentthreshold_prop.set_description("Sets the threshold for gain dependent mode of Interlock \noperation.");
	interlockgaindependentthreshold_prop.set_label("interlock gain limit");
	interlockgaindependentthreshold_prop.set_unit("a.u.");
	//	standard_unit	not set for InterlockGainDependentThreshold
	interlockgaindependentthreshold_prop.set_display_unit("%5d");
	//	format	not set for InterlockGainDependentThreshold
	interlockgaindependentthreshold_prop.set_max_value("0");
	interlockgaindependentthreshold_prop.set_min_value("-80");
	//	max_alarm	not set for InterlockGainDependentThreshold
	//	min_alarm	not set for InterlockGainDependentThreshold
	//	max_warning	not set for InterlockGainDependentThreshold
	//	min_warning	not set for InterlockGainDependentThreshold
	//	delta_t	not set for InterlockGainDependentThreshold
	//	delta_val	not set for InterlockGainDependentThreshold
	
	interlockgaindependentthreshold->set_default_properties(interlockgaindependentthreshold_prop);
	//	Not Polled
	interlockgaindependentthreshold->set_disp_level(Tango::OPERATOR);
	interlockgaindependentthreshold->set_memorized();
	interlockgaindependentthreshold->set_memorized_init(true);
	att_list.push_back(interlockgaindependentthreshold);

	//	Attribute : Kx
	KxAttrib	*kx = new KxAttrib();
	Tango::UserDefaultAttrProp	kx_prop;
	kx_prop.set_description("Sets the Kx for X position calculation. Default setting is 10 mm \n(=10000000 nm).");
	kx_prop.set_label("X position coefficient");
	kx_prop.set_unit("a.u.");
	//	standard_unit	not set for Kx
	//	display_unit	not set for Kx
	kx_prop.set_format("%8.2f");
	kx_prop.set_max_value("50");
	kx_prop.set_min_value("0.0000001");
	//	max_alarm	not set for Kx
	//	min_alarm	not set for Kx
	//	max_warning	not set for Kx
	//	min_warning	not set for Kx
	//	delta_t	not set for Kx
	//	delta_val	not set for Kx
	
	kx->set_default_properties(kx_prop);
	//	Not Polled
	kx->set_disp_level(Tango::OPERATOR);
	kx->set_memorized();
	kx->set_memorized_init(true);
	att_list.push_back(kx);

	//	Attribute : Ky
	KyAttrib	*ky = new KyAttrib();
	Tango::UserDefaultAttrProp	ky_prop;
	ky_prop.set_description("Sets the Ky for Y position calculation. Default setting is 10 mm \n(=10000000 nm).");
	ky_prop.set_label("Y position coefficient");
	ky_prop.set_unit("a.u.");
	//	standard_unit	not set for Ky
	//	display_unit	not set for Ky
	ky_prop.set_format("%8.2f");
	ky_prop.set_max_value("50");
	ky_prop.set_min_value("0.0000001");
	//	max_alarm	not set for Ky
	//	min_alarm	not set for Ky
	//	max_warning	not set for Ky
	//	min_warning	not set for Ky
	//	delta_t	not set for Ky
	//	delta_val	not set for Ky
	
	ky->set_default_properties(ky_prop);
	//	Not Polled
	ky->set_disp_level(Tango::OPERATOR);
	ky->set_memorized();
	ky->set_memorized_init(true);
	att_list.push_back(ky);

	//	Attribute : XOffset
	XOffsetAttrib	*xoffset = new XOffsetAttrib();
	Tango::UserDefaultAttrProp	xoffset_prop;
	xoffset_prop.set_description("Sets the offset for X position in nm. Default value is 0 nm.");
	xoffset_prop.set_label("X position offset");
	xoffset_prop.set_unit("mm");
	//	standard_unit	not set for XOffset
	//	display_unit	not set for XOffset
	xoffset_prop.set_format("%8.4f");
	//	max_value	not set for XOffset
	//	min_value	not set for XOffset
	//	max_alarm	not set for XOffset
	//	min_alarm	not set for XOffset
	//	max_warning	not set for XOffset
	//	min_warning	not set for XOffset
	//	delta_t	not set for XOffset
	//	delta_val	not set for XOffset
	
	xoffset->set_default_properties(xoffset_prop);
	//	Not Polled
	xoffset->set_disp_level(Tango::OPERATOR);
	xoffset->set_memorized();
	xoffset->set_memorized_init(true);
	att_list.push_back(xoffset);

	//	Attribute : YOffset
	YOffsetAttrib	*yoffset = new YOffsetAttrib();
	Tango::UserDefaultAttrProp	yoffset_prop;
	yoffset_prop.set_description("Sets the offset for Y position in nm. Default value is 0 nm.");
	yoffset_prop.set_label("Y position offset");
	yoffset_prop.set_unit("mm");
	//	standard_unit	not set for YOffset
	//	display_unit	not set for YOffset
	yoffset_prop.set_format("%8.4f");
	//	max_value	not set for YOffset
	//	min_value	not set for YOffset
	//	max_alarm	not set for YOffset
	//	min_alarm	not set for YOffset
	//	max_warning	not set for YOffset
	//	min_warning	not set for YOffset
	//	delta_t	not set for YOffset
	//	delta_val	not set for YOffset
	
	yoffset->set_default_properties(yoffset_prop);
	//	Not Polled
	yoffset->set_disp_level(Tango::OPERATOR);
	yoffset->set_memorized();
	yoffset->set_memorized_init(true);
	att_list.push_back(yoffset);

	//	Attribute : TDEnabled
	TDEnabledAttrib	*tdenabled = new TDEnabledAttrib();
	Tango::UserDefaultAttrProp	tdenabled_prop;
	tdenabled_prop.set_description("TD data source activation flag");
	tdenabled_prop.set_label("TD Enabled");
	tdenabled_prop.set_unit("n/a");
	tdenabled_prop.set_standard_unit("n/a");
	tdenabled_prop.set_display_unit("n/a");
	//	format	not set for TDEnabled
	//	max_value	not set for TDEnabled
	//	min_value	not set for TDEnabled
	//	max_alarm	not set for TDEnabled
	//	min_alarm	not set for TDEnabled
	//	max_warning	not set for TDEnabled
	//	min_warning	not set for TDEnabled
	//	delta_t	not set for TDEnabled
	//	delta_val	not set for TDEnabled
	
	tdenabled->set_default_properties(tdenabled_prop);
	//	Not Polled
	tdenabled->set_disp_level(Tango::OPERATOR);
	tdenabled->set_memorized();
	tdenabled->set_memorized_init(true);
	att_list.push_back(tdenabled);

	//	Attribute : TDBufferSize
	TDBufferSizeAttrib	*tdbuffersize = new TDBufferSizeAttrib();
	Tango::UserDefaultAttrProp	tdbuffersize_prop;
	tdbuffersize_prop.set_description("The number of samples to be read on TD data source.\nInfluences the size of the associated attributes [such as XPosTD for instance].");
	tdbuffersize_prop.set_label("TD Buffer Size");
	tdbuffersize_prop.set_unit("turns");
	//	standard_unit	not set for TDBufferSize
	//	display_unit	not set for TDBufferSize
	tdbuffersize_prop.set_format("%5d");
	tdbuffersize_prop.set_max_value("65535");
	tdbuffersize_prop.set_min_value("2");
	//	max_alarm	not set for TDBufferSize
	//	min_alarm	not set for TDBufferSize
	//	max_warning	not set for TDBufferSize
	//	min_warning	not set for TDBufferSize
	//	delta_t	not set for TDBufferSize
	//	delta_val	not set for TDBufferSize
	
	tdbuffersize->set_default_properties(tdbuffersize_prop);
	//	Not Polled
	tdbuffersize->set_disp_level(Tango::OPERATOR);
	tdbuffersize->set_memorized();
	tdbuffersize->set_memorized_init(true);
	att_list.push_back(tdbuffersize);

	//	Attribute : TDDecimationFactor
	TDDecimationFactorAttrib	*tddecimationfactor = new TDDecimationFactorAttrib();
	Tango::UserDefaultAttrProp	tddecimationfactor_prop;
	tddecimationfactor_prop.set_description("The TD decimation factor");
	tddecimationfactor_prop.set_label("TD Decim. Factor");
	tddecimationfactor_prop.set_unit("samples");
	//	standard_unit	not set for TDDecimationFactor
	//	display_unit	not set for TDDecimationFactor
	tddecimationfactor_prop.set_format("%3d");
	tddecimationfactor_prop.set_max_value("256");
	tddecimationfactor_prop.set_min_value("1");
	//	max_alarm	not set for TDDecimationFactor
	//	min_alarm	not set for TDDecimationFactor
	//	max_warning	not set for TDDecimationFactor
	//	min_warning	not set for TDDecimationFactor
	//	delta_t	not set for TDDecimationFactor
	//	delta_val	not set for TDDecimationFactor
	
	tddecimationfactor->set_default_properties(tddecimationfactor_prop);
	//	Not Polled
	tddecimationfactor->set_disp_level(Tango::OPERATOR);
	tddecimationfactor->set_memorized();
	tddecimationfactor->set_memorized_init(true);
	att_list.push_back(tddecimationfactor);

	//	Attribute : TDTriggerOffset
	TDTriggerOffsetAttrib	*tdtriggeroffset = new TDTriggerOffsetAttrib();
	Tango::UserDefaultAttrProp	tdtriggeroffset_prop;
	tdtriggeroffset_prop.set_description("TD data offset in num. of turns");
	tdtriggeroffset_prop.set_label("TD Trigger Offset");
	tdtriggeroffset_prop.set_unit("turns");
	//	standard_unit	not set for TDTriggerOffset
	//	display_unit	not set for TDTriggerOffset
	tdtriggeroffset_prop.set_format("%6d");
	//	max_value	not set for TDTriggerOffset
	//	min_value	not set for TDTriggerOffset
	//	max_alarm	not set for TDTriggerOffset
	//	min_alarm	not set for TDTriggerOffset
	//	max_warning	not set for TDTriggerOffset
	//	min_warning	not set for TDTriggerOffset
	//	delta_t	not set for TDTriggerOffset
	//	delta_val	not set for TDTriggerOffset
	
	tdtriggeroffset->set_default_properties(tdtriggeroffset_prop);
	//	Not Polled
	tdtriggeroffset->set_disp_level(Tango::OPERATOR);
	tdtriggeroffset->set_memorized();
	tdtriggeroffset->set_memorized_init(true);
	att_list.push_back(tdtriggeroffset);

	//	Attribute : TDBufferFreezingEnabled
	TDBufferFreezingEnabledAttrib	*tdbufferfreezingenabled = new TDBufferFreezingEnabledAttrib();
	Tango::UserDefaultAttrProp	tdbufferfreezingenabled_prop;
	tdbufferfreezingenabled_prop.set_description("TD buffer freezing activation flag");
	tdbufferfreezingenabled_prop.set_label("TD Buffer Freezing Enabled");
	tdbufferfreezingenabled_prop.set_unit("n/a");
	tdbufferfreezingenabled_prop.set_standard_unit("n/a");
	tdbufferfreezingenabled_prop.set_display_unit("n/a");
	//	format	not set for TDBufferFreezingEnabled
	//	max_value	not set for TDBufferFreezingEnabled
	//	min_value	not set for TDBufferFreezingEnabled
	//	max_alarm	not set for TDBufferFreezingEnabled
	//	min_alarm	not set for TDBufferFreezingEnabled
	//	max_warning	not set for TDBufferFreezingEnabled
	//	min_warning	not set for TDBufferFreezingEnabled
	//	delta_t	not set for TDBufferFreezingEnabled
	//	delta_val	not set for TDBufferFreezingEnabled
	
	tdbufferfreezingenabled->set_default_properties(tdbufferfreezingenabled_prop);
	//	Not Polled
	tdbufferfreezingenabled->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(tdbufferfreezingenabled);

	//	Attribute : TDBufferFrozen
	TDBufferFrozenAttrib	*tdbufferfrozen = new TDBufferFrozenAttrib();
	Tango::UserDefaultAttrProp	tdbufferfrozen_prop;
	tdbufferfrozen_prop.set_description("TD buffer status");
	tdbufferfrozen_prop.set_label("TD Buffer Frozen");
	tdbufferfrozen_prop.set_unit("n/a");
	tdbufferfrozen_prop.set_standard_unit("n/a");
	tdbufferfrozen_prop.set_display_unit("n/a");
	//	format	not set for TDBufferFrozen
	//	max_value	not set for TDBufferFrozen
	//	min_value	not set for TDBufferFrozen
	//	max_alarm	not set for TDBufferFrozen
	//	min_alarm	not set for TDBufferFrozen
	//	max_warning	not set for TDBufferFrozen
	//	min_warning	not set for TDBufferFrozen
	//	delta_t	not set for TDBufferFrozen
	//	delta_val	not set for TDBufferFrozen
	
	tdbufferfrozen->set_default_properties(tdbufferfrozen_prop);
	//	Not Polled
	tdbufferfrozen->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(tdbufferfrozen);

	//	Attribute : TDTriggerCounter
	TDTriggerCounterAttrib	*tdtriggercounter = new TDTriggerCounterAttrib();
	Tango::UserDefaultAttrProp	tdtriggercounter_prop;
	tdtriggercounter_prop.set_description("Number of trigger notifications received since last device <init>");
	tdtriggercounter_prop.set_label("Trig.Counter");
	tdtriggercounter_prop.set_unit("a.u.");
	tdtriggercounter_prop.set_standard_unit("a.u.");
	tdtriggercounter_prop.set_display_unit("a.u.");
	tdtriggercounter_prop.set_format("%8d");
	//	max_value	not set for TDTriggerCounter
	//	min_value	not set for TDTriggerCounter
	//	max_alarm	not set for TDTriggerCounter
	//	min_alarm	not set for TDTriggerCounter
	//	max_warning	not set for TDTriggerCounter
	//	min_warning	not set for TDTriggerCounter
	//	delta_t	not set for TDTriggerCounter
	//	delta_val	not set for TDTriggerCounter
	
	tdtriggercounter->set_default_properties(tdtriggercounter_prop);
	//	Not Polled
	tdtriggercounter->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(tdtriggercounter);

	//	Attribute : Ks
	KsAttrib	*ks = new KsAttrib();
	Tango::UserDefaultAttrProp	ks_prop;
	ks_prop.set_description("Coefficient for SUM value. Default setting is 67108864. (226)");
	ks_prop.set_label("SUM value coefficient");
	//	unit	not set for Ks
	//	standard_unit	not set for Ks
	//	display_unit	not set for Ks
	ks_prop.set_format("%8.2f");
	//	max_value	not set for Ks
	//	min_value	not set for Ks
	//	max_alarm	not set for Ks
	//	min_alarm	not set for Ks
	//	max_warning	not set for Ks
	//	min_warning	not set for Ks
	//	delta_t	not set for Ks
	//	delta_val	not set for Ks
	
	ks->set_default_properties(ks_prop);
	//	Not Polled
	ks->set_disp_level(Tango::OPERATOR);
	ks->set_memorized();
	ks->set_memorized_init(true);
	att_list.push_back(ks);

	//	Attribute : QOffset
	QOffsetAttrib	*qoffset = new QOffsetAttrib();
	Tango::UserDefaultAttrProp	qoffset_prop;
	qoffset_prop.set_description("Sets the offset for Q position in nm. Default value is 0 nm.");
	qoffset_prop.set_label("Q position offset");
	qoffset_prop.set_unit("mm");
	//	standard_unit	not set for QOffset
	//	display_unit	not set for QOffset
	qoffset_prop.set_format("%8.4f");
	//	max_value	not set for QOffset
	//	min_value	not set for QOffset
	//	max_alarm	not set for QOffset
	//	min_alarm	not set for QOffset
	//	max_warning	not set for QOffset
	//	min_warning	not set for QOffset
	//	delta_t	not set for QOffset
	//	delta_val	not set for QOffset
	
	qoffset->set_default_properties(qoffset_prop);
	//	Not Polled
	qoffset->set_disp_level(Tango::OPERATOR);
	qoffset->set_memorized();
	qoffset->set_memorized_init(true);
	att_list.push_back(qoffset);

	//	Attribute : SOffset
	SOffsetAttrib	*soffset = new SOffsetAttrib();
	Tango::UserDefaultAttrProp	soffset_prop;
	soffset_prop.set_description("Coefficient for SUM value. Default setting is 67108864. (226)");
	soffset_prop.set_label("Coefficient for SUM value.");
	//	unit	not set for SOffset
	//	standard_unit	not set for SOffset
	//	display_unit	not set for SOffset
	soffset_prop.set_format("%8.4f");
	//	max_value	not set for SOffset
	//	min_value	not set for SOffset
	//	max_alarm	not set for SOffset
	//	min_alarm	not set for SOffset
	//	max_warning	not set for SOffset
	//	min_warning	not set for SOffset
	//	delta_t	not set for SOffset
	//	delta_val	not set for SOffset
	
	soffset->set_default_properties(soffset_prop);
	//	Not Polled
	soffset->set_disp_level(Tango::OPERATOR);
	soffset->set_memorized();
	soffset->set_memorized_init(true);
	att_list.push_back(soffset);

	//	Attribute : SynchronizationStatus
	SynchronizationStatusAttrib	*synchronizationstatus = new SynchronizationStatusAttrib();
	Tango::UserDefaultAttrProp	synchronizationstatus_prop;
	synchronizationstatus_prop.set_description("The synchronization state machine enables the control application to easily monitor the synchronization state of all connected Libera Brilliance+.");
	synchronizationstatus_prop.set_label("Synchronization state machine status");
	//	unit	not set for SynchronizationStatus
	//	standard_unit	not set for SynchronizationStatus
	//	display_unit	not set for SynchronizationStatus
	//	format	not set for SynchronizationStatus
	//	max_value	not set for SynchronizationStatus
	//	min_value	not set for SynchronizationStatus
	//	max_alarm	not set for SynchronizationStatus
	//	min_alarm	not set for SynchronizationStatus
	//	max_warning	not set for SynchronizationStatus
	//	min_warning	not set for SynchronizationStatus
	//	delta_t	not set for SynchronizationStatus
	//	delta_val	not set for SynchronizationStatus
	
	synchronizationstatus->set_default_properties(synchronizationstatus_prop);
	//	Not Polled
	synchronizationstatus->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(synchronizationstatus);

	//	Attribute : T0Delay
	T0DelayAttrib	*t0delay = new T0DelayAttrib();
	Tango::UserDefaultAttrProp	t0delay_prop;
	t0delay_prop.set_description("Delay before transmission starts, set in cycles at fSFP");
	t0delay_prop.set_label("Delay before transmission");
	t0delay_prop.set_unit("Cycles fSFP");
	//	standard_unit	not set for T0Delay
	//	display_unit	not set for T0Delay
	//	format	not set for T0Delay
	//	max_value	not set for T0Delay
	//	min_value	not set for T0Delay
	//	max_alarm	not set for T0Delay
	//	min_alarm	not set for T0Delay
	//	max_warning	not set for T0Delay
	//	min_warning	not set for T0Delay
	//	delta_t	not set for T0Delay
	//	delta_val	not set for T0Delay
	
	t0delay->set_default_properties(t0delay_prop);
	//	Not Polled
	t0delay->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t0delay);

	//	Attribute : MaxADC
	MaxADCAttrib	*maxadc = new MaxADCAttrib();
	Tango::UserDefaultAttrProp	maxadc_prop;
	maxadc_prop.set_description("The MAX ADC is monitored to assess the level of the input signal (ADC saturation). It can be reset on read or on trigger. [OnTrigger, OnRead]");
	maxadc_prop.set_label("Max ADC Saturation");
	//	unit	not set for MaxADC
	//	standard_unit	not set for MaxADC
	//	display_unit	not set for MaxADC
	//	format	not set for MaxADC
	//	max_value	not set for MaxADC
	//	min_value	not set for MaxADC
	//	max_alarm	not set for MaxADC
	//	min_alarm	not set for MaxADC
	//	max_warning	not set for MaxADC
	//	min_warning	not set for MaxADC
	//	delta_t	not set for MaxADC
	//	delta_val	not set for MaxADC
	
	maxadc->set_default_properties(maxadc_prop);
	//	Not Polled
	maxadc->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(maxadc);

	//	Attribute : RtcDecoderSwitch
	RtcDecoderSwitchAttrib	*rtcdecoderswitch = new RtcDecoderSwitchAttrib();
	Tango::UserDefaultAttrProp	rtcdecoderswitch_prop;
	rtcdecoderswitch_prop.set_description("RTC decoding switch of optical stream");
	rtcdecoderswitch_prop.set_label("RTC decoding switch");
	//	unit	not set for RtcDecoderSwitch
	//	standard_unit	not set for RtcDecoderSwitch
	//	display_unit	not set for RtcDecoderSwitch
	//	format	not set for RtcDecoderSwitch
	//	max_value	not set for RtcDecoderSwitch
	//	min_value	not set for RtcDecoderSwitch
	//	max_alarm	not set for RtcDecoderSwitch
	//	min_alarm	not set for RtcDecoderSwitch
	//	max_warning	not set for RtcDecoderSwitch
	//	min_warning	not set for RtcDecoderSwitch
	//	delta_t	not set for RtcDecoderSwitch
	//	delta_val	not set for RtcDecoderSwitch
	
	rtcdecoderswitch->set_default_properties(rtcdecoderswitch_prop);
	//	Not Polled
	rtcdecoderswitch->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(rtcdecoderswitch);

	//	Attribute : McSource
	McSourceAttrib	*mcsource = new McSourceAttrib();
	Tango::UserDefaultAttrProp	mcsource_prop;
	mcsource_prop.set_description("Trigger line source selection");
	mcsource_prop.set_label("MC Source");
	//	unit	not set for McSource
	//	standard_unit	not set for McSource
	//	display_unit	not set for McSource
	//	format	not set for McSource
	//	max_value	not set for McSource
	//	min_value	not set for McSource
	//	max_alarm	not set for McSource
	//	min_alarm	not set for McSource
	//	max_warning	not set for McSource
	//	min_warning	not set for McSource
	//	delta_t	not set for McSource
	//	delta_val	not set for McSource
	
	mcsource->set_default_properties(mcsource_prop);
	//	Not Polled
	mcsource->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(mcsource);

	//	Attribute : T0Direction
	T0DirectionAttrib	*t0direction = new T0DirectionAttrib();
	Tango::UserDefaultAttrProp	t0direction_prop;
	t0direction_prop.set_description("t0 port direction");
	t0direction_prop.set_label("t0 Direction");
	//	unit	not set for T0Direction
	//	standard_unit	not set for T0Direction
	//	display_unit	not set for T0Direction
	//	format	not set for T0Direction
	//	max_value	not set for T0Direction
	//	min_value	not set for T0Direction
	//	max_alarm	not set for T0Direction
	//	min_alarm	not set for T0Direction
	//	max_warning	not set for T0Direction
	//	min_warning	not set for T0Direction
	//	delta_t	not set for T0Direction
	//	delta_val	not set for T0Direction
	
	t0direction->set_default_properties(t0direction_prop);
	//	Not Polled
	t0direction->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t0direction);

	//	Attribute : T0OutputType
	T0OutputTypeAttrib	*t0outputtype = new T0OutputTypeAttrib();
	Tango::UserDefaultAttrProp	t0outputtype_prop;
	t0outputtype_prop.set_description("t0 output type");
	t0outputtype_prop.set_label("t0 output");
	//	unit	not set for T0OutputType
	//	standard_unit	not set for T0OutputType
	//	display_unit	not set for T0OutputType
	//	format	not set for T0OutputType
	//	max_value	not set for T0OutputType
	//	min_value	not set for T0OutputType
	//	max_alarm	not set for T0OutputType
	//	min_alarm	not set for T0OutputType
	//	max_warning	not set for T0OutputType
	//	min_warning	not set for T0OutputType
	//	delta_t	not set for T0OutputType
	//	delta_val	not set for T0OutputType
	
	t0outputtype->set_default_properties(t0outputtype_prop);
	//	Not Polled
	t0outputtype->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t0outputtype);

	//	Attribute : T0State
	T0StateAttrib	*t0state = new T0StateAttrib();
	Tango::UserDefaultAttrProp	t0state_prop;
	t0state_prop.set_description("state of active signal: high (logical 1) or low (logical 0)");
	t0state_prop.set_label("t0 signal state");
	//	unit	not set for T0State
	//	standard_unit	not set for T0State
	//	display_unit	not set for T0State
	//	format	not set for T0State
	//	max_value	not set for T0State
	//	min_value	not set for T0State
	//	max_alarm	not set for T0State
	//	min_alarm	not set for T0State
	//	max_warning	not set for T0State
	//	min_warning	not set for T0State
	//	delta_t	not set for T0State
	//	delta_val	not set for T0State
	
	t0state->set_default_properties(t0state_prop);
	//	Not Polled
	t0state->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t0state);

	//	Attribute : T1Source
	T1SourceAttrib	*t1source = new T1SourceAttrib();
	Tango::UserDefaultAttrProp	t1source_prop;
	t1source_prop.set_description("Trigger line source selection");
	t1source_prop.set_label("t1 Source");
	//	unit	not set for T1Source
	//	standard_unit	not set for T1Source
	//	display_unit	not set for T1Source
	//	format	not set for T1Source
	//	max_value	not set for T1Source
	//	min_value	not set for T1Source
	//	max_alarm	not set for T1Source
	//	min_alarm	not set for T1Source
	//	max_warning	not set for T1Source
	//	min_warning	not set for T1Source
	//	delta_t	not set for T1Source
	//	delta_val	not set for T1Source
	
	t1source->set_default_properties(t1source_prop);
	//	Not Polled
	t1source->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(t1source);

	//	Attribute : T2Source
	T2SourceAttrib	*t2source = new T2SourceAttrib();
	Tango::UserDefaultAttrProp	t2source_prop;
	t2source_prop.set_description("Trigger line source selection");
	t2source_prop.set_label("t2 Source");
	//	unit	not set for T2Source
	//	standard_unit	not set for T2Source
	//	display_unit	not set for T2Source
	//	format	not set for T2Source
	//	max_value	not set for T2Source
	//	min_value	not set for T2Source
	//	max_alarm	not set for T2Source
	//	min_alarm	not set for T2Source
	//	max_warning	not set for T2Source
	//	min_warning	not set for T2Source
	//	delta_t	not set for T2Source
	//	delta_val	not set for T2Source
	
	t2source->set_default_properties(t2source_prop);
	//	Not Polled
	t2source->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(t2source);

	//	Attribute : MgtOut
	MgtOutAttrib	*mgtout = new MgtOutAttrib();
	Tango::UserDefaultAttrProp	mgtout_prop;
	mgtout_prop.set_description("MGT OUT selection off,sfp_in,debug,connectors");
	mgtout_prop.set_label("MGT OUT");
	//	unit	not set for MgtOut
	//	standard_unit	not set for MgtOut
	//	display_unit	not set for MgtOut
	//	format	not set for MgtOut
	//	max_value	not set for MgtOut
	//	min_value	not set for MgtOut
	//	max_alarm	not set for MgtOut
	//	min_alarm	not set for MgtOut
	//	max_warning	not set for MgtOut
	//	min_warning	not set for MgtOut
	//	delta_t	not set for MgtOut
	//	delta_val	not set for MgtOut
	
	mgtout->set_default_properties(mgtout_prop);
	//	Not Polled
	mgtout->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(mgtout);

	//	Attribute : SPThreshold
	SPThresholdAttrib	*spthreshold = new SPThresholdAttrib();
	Tango::UserDefaultAttrProp	spthreshold_prop;
	spthreshold_prop.set_description("Specifies the threshold for start of calculation (in ADC counts) for the Single Pass functionality");
	spthreshold_prop.set_label("SinglePass Mode Threshold");
	//	unit	not set for SPThreshold
	//	standard_unit	not set for SPThreshold
	//	display_unit	not set for SPThreshold
	//	format	not set for SPThreshold
	//	max_value	not set for SPThreshold
	//	min_value	not set for SPThreshold
	//	max_alarm	not set for SPThreshold
	//	min_alarm	not set for SPThreshold
	//	max_warning	not set for SPThreshold
	//	min_warning	not set for SPThreshold
	//	delta_t	not set for SPThreshold
	//	delta_val	not set for SPThreshold
	
	spthreshold->set_default_properties(spthreshold_prop);
	//	Not Polled
	spthreshold->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(spthreshold);

	//	Attribute : SPnBefore
	SPnBeforeAttrib	*spnbefore = new SPnBeforeAttrib();
	Tango::UserDefaultAttrProp	spnbefore_prop;
	spnbefore_prop.set_description("specifies the number of samples to take before the threshold (in ADC samples) for the Single Pass functionality");
	spnbefore_prop.set_label("SinglePass Mode pre-Trigger");
	//	unit	not set for SPnBefore
	//	standard_unit	not set for SPnBefore
	//	display_unit	not set for SPnBefore
	//	format	not set for SPnBefore
	//	max_value	not set for SPnBefore
	//	min_value	not set for SPnBefore
	//	max_alarm	not set for SPnBefore
	//	min_alarm	not set for SPnBefore
	//	max_warning	not set for SPnBefore
	//	min_warning	not set for SPnBefore
	//	delta_t	not set for SPnBefore
	//	delta_val	not set for SPnBefore
	
	spnbefore->set_default_properties(spnbefore_prop);
	//	Not Polled
	spnbefore->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(spnbefore);

	//	Attribute : SPnAfter
	SPnAfterAttrib	*spnafter = new SPnAfterAttrib();
	Tango::UserDefaultAttrProp	spnafter_prop;
	spnafter_prop.set_description("specifies the number of samples to take after the threshold (in ADC samples) for the Single Pass functionality");
	spnafter_prop.set_label("SinglePass Mode post-Trigger");
	//	unit	not set for SPnAfter
	//	standard_unit	not set for SPnAfter
	//	display_unit	not set for SPnAfter
	//	format	not set for SPnAfter
	//	max_value	not set for SPnAfter
	//	min_value	not set for SPnAfter
	//	max_alarm	not set for SPnAfter
	//	min_alarm	not set for SPnAfter
	//	max_warning	not set for SPnAfter
	//	min_warning	not set for SPnAfter
	//	delta_t	not set for SPnAfter
	//	delta_val	not set for SPnAfter
	
	spnafter->set_default_properties(spnafter_prop);
	//	Not Polled
	spnafter->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(spnafter);

	//	Attribute : T0inMask
	T0inMaskAttrib	*t0inmask = new T0inMaskAttrib();
	Tango::UserDefaultAttrProp	t0inmask_prop;
	t0inmask_prop.set_description("T0 Masking array (in_mask) contains 16-bit entries that select the relevant bits from the 16-bit accelerators timing system.");
	t0inmask_prop.set_label("T0 Masking Array");
	//	unit	not set for T0inMask
	//	standard_unit	not set for T0inMask
	//	display_unit	not set for T0inMask
	//	format	not set for T0inMask
	//	max_value	not set for T0inMask
	//	min_value	not set for T0inMask
	//	max_alarm	not set for T0inMask
	//	min_alarm	not set for T0inMask
	//	max_warning	not set for T0inMask
	//	min_warning	not set for T0inMask
	//	delta_t	not set for T0inMask
	//	delta_val	not set for T0inMask
	
	t0inmask->set_default_properties(t0inmask_prop);
	//	Not Polled
	t0inmask->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t0inmask);

	//	Attribute : T1inMask
	T1inMaskAttrib	*t1inmask = new T1inMaskAttrib();
	Tango::UserDefaultAttrProp	t1inmask_prop;
	t1inmask_prop.set_description("T1 Masking array (in_mask) contains 16-bit entries that select the relevant bits from the 16-bit accelerators timing system.");
	t1inmask_prop.set_label("T1 Masking Array");
	//	unit	not set for T1inMask
	//	standard_unit	not set for T1inMask
	//	display_unit	not set for T1inMask
	//	format	not set for T1inMask
	//	max_value	not set for T1inMask
	//	min_value	not set for T1inMask
	//	max_alarm	not set for T1inMask
	//	min_alarm	not set for T1inMask
	//	max_warning	not set for T1inMask
	//	min_warning	not set for T1inMask
	//	delta_t	not set for T1inMask
	//	delta_val	not set for T1inMask
	
	t1inmask->set_default_properties(t1inmask_prop);
	//	Not Polled
	t1inmask->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t1inmask);

	//	Attribute : T2inMask
	T2inMaskAttrib	*t2inmask = new T2inMaskAttrib();
	Tango::UserDefaultAttrProp	t2inmask_prop;
	t2inmask_prop.set_description("T2 Masking array (in_mask) contains 16-bit entries that select the relevant bits from the 16-bit accelerators timing system.");
	t2inmask_prop.set_label("T2 Masking Array");
	//	unit	not set for T2inMask
	//	standard_unit	not set for T2inMask
	//	display_unit	not set for T2inMask
	//	format	not set for T2inMask
	//	max_value	not set for T2inMask
	//	min_value	not set for T2inMask
	//	max_alarm	not set for T2inMask
	//	min_alarm	not set for T2inMask
	//	max_warning	not set for T2inMask
	//	min_warning	not set for T2inMask
	//	delta_t	not set for T2inMask
	//	delta_val	not set for T2inMask
	
	t2inmask->set_default_properties(t2inmask_prop);
	//	Not Polled
	t2inmask->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t2inmask);

	//	Attribute : T0inFunction
	T0inFunctionAttrib	*t0infunction = new T0inFunctionAttrib();
	Tango::UserDefaultAttrProp	t0infunction_prop;
	t0infunction_prop.set_description("T0 Function array (in_function) contains 16-bit entries that define the value of masked bits.");
	t0infunction_prop.set_label("T0 Function array");
	//	unit	not set for T0inFunction
	//	standard_unit	not set for T0inFunction
	//	display_unit	not set for T0inFunction
	//	format	not set for T0inFunction
	//	max_value	not set for T0inFunction
	//	min_value	not set for T0inFunction
	//	max_alarm	not set for T0inFunction
	//	min_alarm	not set for T0inFunction
	//	max_warning	not set for T0inFunction
	//	min_warning	not set for T0inFunction
	//	delta_t	not set for T0inFunction
	//	delta_val	not set for T0inFunction
	
	t0infunction->set_default_properties(t0infunction_prop);
	//	Not Polled
	t0infunction->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t0infunction);

	//	Attribute : T1inFunction
	T1inFunctionAttrib	*t1infunction = new T1inFunctionAttrib();
	Tango::UserDefaultAttrProp	t1infunction_prop;
	t1infunction_prop.set_description("T1 Function array (in_function) contains 16-bit entries that define the value of masked bits.");
	t1infunction_prop.set_label("T1 Function array");
	//	unit	not set for T1inFunction
	//	standard_unit	not set for T1inFunction
	//	display_unit	not set for T1inFunction
	//	format	not set for T1inFunction
	//	max_value	not set for T1inFunction
	//	min_value	not set for T1inFunction
	//	max_alarm	not set for T1inFunction
	//	min_alarm	not set for T1inFunction
	//	max_warning	not set for T1inFunction
	//	min_warning	not set for T1inFunction
	//	delta_t	not set for T1inFunction
	//	delta_val	not set for T1inFunction
	
	t1infunction->set_default_properties(t1infunction_prop);
	//	Not Polled
	t1infunction->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t1infunction);

	//	Attribute : T2inFunction
	T2inFunctionAttrib	*t2infunction = new T2inFunctionAttrib();
	Tango::UserDefaultAttrProp	t2infunction_prop;
	t2infunction_prop.set_description("T2 Function array (in_function) contains 16-bit entries that define the value of masked bits.");
	t2infunction_prop.set_label("T2 Function array");
	//	unit	not set for T2inFunction
	//	standard_unit	not set for T2inFunction
	//	display_unit	not set for T2inFunction
	//	format	not set for T2inFunction
	//	max_value	not set for T2inFunction
	//	min_value	not set for T2inFunction
	//	max_alarm	not set for T2inFunction
	//	min_alarm	not set for T2inFunction
	//	max_warning	not set for T2inFunction
	//	min_warning	not set for T2inFunction
	//	delta_t	not set for T2inFunction
	//	delta_val	not set for T2inFunction
	
	t2infunction->set_default_properties(t2infunction_prop);
	//	Not Polled
	t2infunction->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t2infunction);

	//	Attribute : MCinMask
	MCinMaskAttrib	*mcinmask = new MCinMaskAttrib();
	Tango::UserDefaultAttrProp	mcinmask_prop;
	mcinmask_prop.set_description("MC Masking array (in_mask) contains 16-bit entries that select the relevant bits from the 16-bit accelerators timing system.");
	mcinmask_prop.set_label("MC Masking Array");
	//	unit	not set for MCinMask
	//	standard_unit	not set for MCinMask
	//	display_unit	not set for MCinMask
	//	format	not set for MCinMask
	//	max_value	not set for MCinMask
	//	min_value	not set for MCinMask
	//	max_alarm	not set for MCinMask
	//	min_alarm	not set for MCinMask
	//	max_warning	not set for MCinMask
	//	min_warning	not set for MCinMask
	//	delta_t	not set for MCinMask
	//	delta_val	not set for MCinMask
	
	mcinmask->set_default_properties(mcinmask_prop);
	//	Not Polled
	mcinmask->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(mcinmask);

	//	Attribute : MCinFunction
	MCinFunctionAttrib	*mcinfunction = new MCinFunctionAttrib();
	Tango::UserDefaultAttrProp	mcinfunction_prop;
	mcinfunction_prop.set_description("MC Function array (in_function) contains 16-bit entries that define the value of masked bits.");
	mcinfunction_prop.set_label("MC Function array");
	//	unit	not set for MCinFunction
	//	standard_unit	not set for MCinFunction
	//	display_unit	not set for MCinFunction
	//	format	not set for MCinFunction
	//	max_value	not set for MCinFunction
	//	min_value	not set for MCinFunction
	//	max_alarm	not set for MCinFunction
	//	min_alarm	not set for MCinFunction
	//	max_warning	not set for MCinFunction
	//	min_warning	not set for MCinFunction
	//	delta_t	not set for MCinFunction
	//	delta_val	not set for MCinFunction
	
	mcinfunction->set_default_properties(mcinfunction_prop);
	//	Not Polled
	mcinfunction->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(mcinfunction);

	//	Attribute : T0Duration
	T0DurationAttrib	*t0duration = new T0DurationAttrib();
	Tango::UserDefaultAttrProp	t0duration_prop;
	t0duration_prop.set_description("Duration of signal active pulse");
	t0duration_prop.set_label("T0 Duration");
	//	unit	not set for T0Duration
	//	standard_unit	not set for T0Duration
	//	display_unit	not set for T0Duration
	//	format	not set for T0Duration
	//	max_value	not set for T0Duration
	//	min_value	not set for T0Duration
	//	max_alarm	not set for T0Duration
	//	min_alarm	not set for T0Duration
	//	max_warning	not set for T0Duration
	//	min_warning	not set for T0Duration
	//	delta_t	not set for T0Duration
	//	delta_val	not set for T0Duration
	
	t0duration->set_default_properties(t0duration_prop);
	//	Not Polled
	t0duration->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t0duration);

	//	Attribute : InterlockID
	InterlockIDAttrib	*interlockid = new InterlockIDAttrib();
	Tango::UserDefaultAttrProp	interlockid_prop;
	interlockid_prop.set_description("Oversaturation or X-Y orbit threshold");
	interlockid_prop.set_label("Interlock ID");
	//	unit	not set for InterlockID
	//	standard_unit	not set for InterlockID
	//	display_unit	not set for InterlockID
	//	format	not set for InterlockID
	//	max_value	not set for InterlockID
	//	min_value	not set for InterlockID
	//	max_alarm	not set for InterlockID
	//	min_alarm	not set for InterlockID
	//	max_warning	not set for InterlockID
	//	min_warning	not set for InterlockID
	//	delta_t	not set for InterlockID
	//	delta_val	not set for InterlockID
	
	interlockid->set_default_properties(interlockid_prop);
	//	Not Polled
	interlockid->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(interlockid);

	//	Attribute : SPEnabled
	SPEnabledAttrib	*spenabled = new SPEnabledAttrib();
	Tango::UserDefaultAttrProp	spenabled_prop;
	spenabled_prop.set_description("Single Pass data source activation flag");
	spenabled_prop.set_label("SP Enabled");
	spenabled_prop.set_unit("n/a");
	spenabled_prop.set_standard_unit("n/a");
	spenabled_prop.set_display_unit("n/a");
	//	format	not set for SPEnabled
	//	max_value	not set for SPEnabled
	//	min_value	not set for SPEnabled
	//	max_alarm	not set for SPEnabled
	//	min_alarm	not set for SPEnabled
	//	max_warning	not set for SPEnabled
	//	min_warning	not set for SPEnabled
	//	delta_t	not set for SPEnabled
	//	delta_val	not set for SPEnabled
	
	spenabled->set_default_properties(spenabled_prop);
	//	Not Polled
	spenabled->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(spenabled);

	//	Attribute : SPBufferSize
	SPBufferSizeAttrib	*spbuffersize = new SPBufferSizeAttrib();
	Tango::UserDefaultAttrProp	spbuffersize_prop;
	spbuffersize_prop.set_description("The number of samples to be read on Single Pass data source.");
	spbuffersize_prop.set_label("SP Buffer Size");
	spbuffersize_prop.set_unit("turns");
	//	standard_unit	not set for SPBufferSize
	//	display_unit	not set for SPBufferSize
	spbuffersize_prop.set_format("%5d");
	spbuffersize_prop.set_max_value("65535");
	spbuffersize_prop.set_min_value("2");
	//	max_alarm	not set for SPBufferSize
	//	min_alarm	not set for SPBufferSize
	//	max_warning	not set for SPBufferSize
	//	min_warning	not set for SPBufferSize
	//	delta_t	not set for SPBufferSize
	//	delta_val	not set for SPBufferSize
	
	spbuffersize->set_default_properties(spbuffersize_prop);
	//	Not Polled
	spbuffersize->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(spbuffersize);

	//	Attribute : T2EdgeFalling
	T2EdgeFallingAttrib	*t2edgefalling = new T2EdgeFallingAttrib();
	Tango::UserDefaultAttrProp	t2edgefalling_prop;
	//	description	not set for T2EdgeFalling
	t2edgefalling_prop.set_label("T2 Edge Falling");
	t2edgefalling_prop.set_unit("n/a");
	t2edgefalling_prop.set_standard_unit("n/a");
	t2edgefalling_prop.set_display_unit("n/a");
	//	format	not set for T2EdgeFalling
	//	max_value	not set for T2EdgeFalling
	//	min_value	not set for T2EdgeFalling
	//	max_alarm	not set for T2EdgeFalling
	//	min_alarm	not set for T2EdgeFalling
	//	max_warning	not set for T2EdgeFalling
	//	min_warning	not set for T2EdgeFalling
	//	delta_t	not set for T2EdgeFalling
	//	delta_val	not set for T2EdgeFalling
	
	t2edgefalling->set_default_properties(t2edgefalling_prop);
	//	Not Polled
	t2edgefalling->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t2edgefalling);

	//	Attribute : T2EdgeRising
	T2EdgeRisingAttrib	*t2edgerising = new T2EdgeRisingAttrib();
	Tango::UserDefaultAttrProp	t2edgerising_prop;
	//	description	not set for T2EdgeRising
	t2edgerising_prop.set_label("T2 Edge Rising");
	t2edgerising_prop.set_unit("n/a");
	t2edgerising_prop.set_standard_unit("n/a");
	t2edgerising_prop.set_display_unit("n/a");
	//	format	not set for T2EdgeRising
	//	max_value	not set for T2EdgeRising
	//	min_value	not set for T2EdgeRising
	//	max_alarm	not set for T2EdgeRising
	//	min_alarm	not set for T2EdgeRising
	//	max_warning	not set for T2EdgeRising
	//	min_warning	not set for T2EdgeRising
	//	delta_t	not set for T2EdgeRising
	//	delta_val	not set for T2EdgeRising
	
	t2edgerising->set_default_properties(t2edgerising_prop);
	//	Not Polled
	t2edgerising->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t2edgerising);

	//	Attribute : T1EdgeFalling
	T1EdgeFallingAttrib	*t1edgefalling = new T1EdgeFallingAttrib();
	Tango::UserDefaultAttrProp	t1edgefalling_prop;
	//	description	not set for T1EdgeFalling
	t1edgefalling_prop.set_label("T2 Edge Falling");
	t1edgefalling_prop.set_unit("n/a");
	t1edgefalling_prop.set_standard_unit("n/a");
	t1edgefalling_prop.set_display_unit("n/a");
	//	format	not set for T1EdgeFalling
	//	max_value	not set for T1EdgeFalling
	//	min_value	not set for T1EdgeFalling
	//	max_alarm	not set for T1EdgeFalling
	//	min_alarm	not set for T1EdgeFalling
	//	max_warning	not set for T1EdgeFalling
	//	min_warning	not set for T1EdgeFalling
	//	delta_t	not set for T1EdgeFalling
	//	delta_val	not set for T1EdgeFalling
	
	t1edgefalling->set_default_properties(t1edgefalling_prop);
	//	Not Polled
	t1edgefalling->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t1edgefalling);

	//	Attribute : T1EdgeRising
	T1EdgeRisingAttrib	*t1edgerising = new T1EdgeRisingAttrib();
	Tango::UserDefaultAttrProp	t1edgerising_prop;
	//	description	not set for T1EdgeRising
	t1edgerising_prop.set_label("T1 Edge Rising");
	t1edgerising_prop.set_unit("n/a");
	t1edgerising_prop.set_standard_unit("n/a");
	t1edgerising_prop.set_display_unit("n/a");
	//	format	not set for T1EdgeRising
	//	max_value	not set for T1EdgeRising
	//	min_value	not set for T1EdgeRising
	//	max_alarm	not set for T1EdgeRising
	//	min_alarm	not set for T1EdgeRising
	//	max_warning	not set for T1EdgeRising
	//	min_warning	not set for T1EdgeRising
	//	delta_t	not set for T1EdgeRising
	//	delta_val	not set for T1EdgeRising
	
	t1edgerising->set_default_properties(t1edgerising_prop);
	//	Not Polled
	t1edgerising->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t1edgerising);

	//	Attribute : T2ID
	T2IDAttrib	*t2id = new T2IDAttrib();
	Tango::UserDefaultAttrProp	t2id_prop;
	t2id_prop.set_description("T2 Optical event ID");
	t2id_prop.set_label("T2 ID");
	t2id_prop.set_unit("n/a");
	t2id_prop.set_standard_unit("n/a");
	t2id_prop.set_display_unit("n/a");
	//	format	not set for T2ID
	//	max_value	not set for T2ID
	//	min_value	not set for T2ID
	//	max_alarm	not set for T2ID
	//	min_alarm	not set for T2ID
	//	max_warning	not set for T2ID
	//	min_warning	not set for T2ID
	//	delta_t	not set for T2ID
	//	delta_val	not set for T2ID
	
	t2id->set_default_properties(t2id_prop);
	//	Not Polled
	t2id->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t2id);

	//	Attribute : T1ID
	T1IDAttrib	*t1id = new T1IDAttrib();
	Tango::UserDefaultAttrProp	t1id_prop;
	t1id_prop.set_description("T1 Optical event ID");
	t1id_prop.set_label("T1 ID");
	t1id_prop.set_unit("n/a");
	t1id_prop.set_standard_unit("n/a");
	t1id_prop.set_display_unit("n/a");
	//	format	not set for T1ID
	//	max_value	not set for T1ID
	//	min_value	not set for T1ID
	//	max_alarm	not set for T1ID
	//	min_alarm	not set for T1ID
	//	max_warning	not set for T1ID
	//	min_warning	not set for T1ID
	//	delta_t	not set for T1ID
	//	delta_val	not set for T1ID
	
	t1id->set_default_properties(t1id_prop);
	//	Not Polled
	t1id->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t1id);

	//	Attribute : PMBufferSize
	PMBufferSizeAttrib	*pmbuffersize = new PMBufferSizeAttrib();
	Tango::UserDefaultAttrProp	pmbuffersize_prop;
	pmbuffersize_prop.set_description("The number of samples to be read on PM data source.");
	pmbuffersize_prop.set_label("PM Buffer Size");
	//	unit	not set for PMBufferSize
	//	standard_unit	not set for PMBufferSize
	//	display_unit	not set for PMBufferSize
	pmbuffersize_prop.set_format("%5d");
	//	max_value	not set for PMBufferSize
	//	min_value	not set for PMBufferSize
	//	max_alarm	not set for PMBufferSize
	//	min_alarm	not set for PMBufferSize
	//	max_warning	not set for PMBufferSize
	//	min_warning	not set for PMBufferSize
	//	delta_t	not set for PMBufferSize
	//	delta_val	not set for PMBufferSize
	
	pmbuffersize->set_default_properties(pmbuffersize_prop);
	//	Not Polled
	pmbuffersize->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(pmbuffersize);

	//	Attribute : PMSource
	PMSourceAttrib	*pmsource = new PMSourceAttrib();
	Tango::UserDefaultAttrProp	pmsource_prop;
	pmsource_prop.set_description("source of the PM event (external,interlock,limits)\n");
	pmsource_prop.set_label("PM Source");
	//	unit	not set for PMSource
	//	standard_unit	not set for PMSource
	//	display_unit	not set for PMSource
	//	format	not set for PMSource
	//	max_value	not set for PMSource
	//	min_value	not set for PMSource
	//	max_alarm	not set for PMSource
	//	min_alarm	not set for PMSource
	//	max_warning	not set for PMSource
	//	min_warning	not set for PMSource
	//	delta_t	not set for PMSource
	//	delta_val	not set for PMSource
	
	pmsource->set_default_properties(pmsource_prop);
	//	Not Polled
	pmsource->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(pmsource);

	//	Attribute : T1Direction
	T1DirectionAttrib	*t1direction = new T1DirectionAttrib();
	Tango::UserDefaultAttrProp	t1direction_prop;
	t1direction_prop.set_description("t2 port direction");
	t1direction_prop.set_label("t1 Direction");
	//	unit	not set for T1Direction
	//	standard_unit	not set for T1Direction
	//	display_unit	not set for T1Direction
	//	format	not set for T1Direction
	//	max_value	not set for T1Direction
	//	min_value	not set for T1Direction
	//	max_alarm	not set for T1Direction
	//	min_alarm	not set for T1Direction
	//	max_warning	not set for T1Direction
	//	min_warning	not set for T1Direction
	//	delta_t	not set for T1Direction
	//	delta_val	not set for T1Direction
	
	t1direction->set_default_properties(t1direction_prop);
	//	Not Polled
	t1direction->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t1direction);

	//	Attribute : T2Direction
	T2DirectionAttrib	*t2direction = new T2DirectionAttrib();
	Tango::UserDefaultAttrProp	t2direction_prop;
	t2direction_prop.set_description("t2 port direction");
	t2direction_prop.set_label("t2 Direction");
	//	unit	not set for T2Direction
	//	standard_unit	not set for T2Direction
	//	display_unit	not set for T2Direction
	//	format	not set for T2Direction
	//	max_value	not set for T2Direction
	//	min_value	not set for T2Direction
	//	max_alarm	not set for T2Direction
	//	min_alarm	not set for T2Direction
	//	max_warning	not set for T2Direction
	//	min_warning	not set for T2Direction
	//	delta_t	not set for T2Direction
	//	delta_val	not set for T2Direction
	
	t2direction->set_default_properties(t2direction_prop);
	//	Not Polled
	t2direction->set_disp_level(Tango::EXPERT);
	//	Not Memorized
	att_list.push_back(t2direction);

	//	Attribute : SynchronizeLMT
	SynchronizeLMTAttrib	*synchronizelmt = new SynchronizeLMTAttrib();
	Tango::UserDefaultAttrProp	synchronizelmt_prop;
	synchronizelmt_prop.set_description("The absolute time synchronization is done for all processor modules simultaneously.  [0, 18446744073709551614]");
	synchronizelmt_prop.set_label("Sync LMT");
	//	unit	not set for SynchronizeLMT
	//	standard_unit	not set for SynchronizeLMT
	//	display_unit	not set for SynchronizeLMT
	//	format	not set for SynchronizeLMT
	//	max_value	not set for SynchronizeLMT
	//	min_value	not set for SynchronizeLMT
	//	max_alarm	not set for SynchronizeLMT
	//	min_alarm	not set for SynchronizeLMT
	//	max_warning	not set for SynchronizeLMT
	//	min_warning	not set for SynchronizeLMT
	//	delta_t	not set for SynchronizeLMT
	//	delta_val	not set for SynchronizeLMT
	
	synchronizelmt->set_default_properties(synchronizelmt_prop);
	//	Not Polled
	synchronizelmt->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(synchronizelmt);

	//	Attribute : RTCTimestamp
	RTCTimestampAttrib	*rtctimestamp = new RTCTimestampAttrib();
	Tango::UserDefaultAttrProp	rtctimestamp_prop;
	rtctimestamp_prop.set_description("Timestamp which is be taken by receiving optical events over SFP when reception is enabled");
	rtctimestamp_prop.set_label("RTC Timestamp");
	//	unit	not set for RTCTimestamp
	//	standard_unit	not set for RTCTimestamp
	//	display_unit	not set for RTCTimestamp
	//	format	not set for RTCTimestamp
	//	max_value	not set for RTCTimestamp
	//	min_value	not set for RTCTimestamp
	//	max_alarm	not set for RTCTimestamp
	//	min_alarm	not set for RTCTimestamp
	//	max_warning	not set for RTCTimestamp
	//	min_warning	not set for RTCTimestamp
	//	delta_t	not set for RTCTimestamp
	//	delta_val	not set for RTCTimestamp
	
	rtctimestamp->set_default_properties(rtctimestamp_prop);
	//	Not Polled
	rtctimestamp->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(rtctimestamp);

	//	Attribute : XPosDD
	XPosDDAttrib	*xposdd = new XPosDDAttrib();
	Tango::UserDefaultAttrProp	xposdd_prop;
	xposdd_prop.set_description("Turn by turn data: X Pos.");
	xposdd_prop.set_label("DD X Pos.");
	xposdd_prop.set_unit("mm");
	xposdd_prop.set_standard_unit("mm");
	xposdd_prop.set_display_unit("mm");
	xposdd_prop.set_format("%8.4f");
	//	max_value	not set for XPosDD
	//	min_value	not set for XPosDD
	//	max_alarm	not set for XPosDD
	//	min_alarm	not set for XPosDD
	//	max_warning	not set for XPosDD
	//	min_warning	not set for XPosDD
	//	delta_t	not set for XPosDD
	//	delta_val	not set for XPosDD
	
	xposdd->set_default_properties(xposdd_prop);
	//	Not Polled
	xposdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xposdd);

	//	Attribute : YPosDD
	YPosDDAttrib	*yposdd = new YPosDDAttrib();
	Tango::UserDefaultAttrProp	yposdd_prop;
	yposdd_prop.set_description("Turn by turn data: Y Pos.");
	yposdd_prop.set_label("DD Y Pos.");
	yposdd_prop.set_unit("mm");
	yposdd_prop.set_standard_unit("mm");
	yposdd_prop.set_display_unit("mm");
	yposdd_prop.set_format("%8.4f");
	//	max_value	not set for YPosDD
	//	min_value	not set for YPosDD
	//	max_alarm	not set for YPosDD
	//	min_alarm	not set for YPosDD
	//	max_warning	not set for YPosDD
	//	min_warning	not set for YPosDD
	//	delta_t	not set for YPosDD
	//	delta_val	not set for YPosDD
	
	yposdd->set_default_properties(yposdd_prop);
	//	Not Polled
	yposdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(yposdd);

	//	Attribute : QuadDD
	QuadDDAttrib	*quaddd = new QuadDDAttrib();
	Tango::UserDefaultAttrProp	quaddd_prop;
	quaddd_prop.set_description("Turn by turn data: Quad");
	quaddd_prop.set_label("DD Quad");
	quaddd_prop.set_unit("a.u.");
	quaddd_prop.set_standard_unit("a.u.");
	quaddd_prop.set_display_unit("a.u.");
	quaddd_prop.set_format("%8.4f");
	//	max_value	not set for QuadDD
	//	min_value	not set for QuadDD
	//	max_alarm	not set for QuadDD
	//	min_alarm	not set for QuadDD
	//	max_warning	not set for QuadDD
	//	min_warning	not set for QuadDD
	//	delta_t	not set for QuadDD
	//	delta_val	not set for QuadDD
	
	quaddd->set_default_properties(quaddd_prop);
	//	Not Polled
	quaddd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(quaddd);

	//	Attribute : SumDD
	SumDDAttrib	*sumdd = new SumDDAttrib();
	Tango::UserDefaultAttrProp	sumdd_prop;
	sumdd_prop.set_description("Turn by turn data: Sum");
	sumdd_prop.set_label("DD Sum");
	sumdd_prop.set_unit("mm");
	sumdd_prop.set_standard_unit("mm");
	sumdd_prop.set_display_unit("mm");
	sumdd_prop.set_format("%10.0f");
	//	max_value	not set for SumDD
	//	min_value	not set for SumDD
	//	max_alarm	not set for SumDD
	//	min_alarm	not set for SumDD
	//	max_warning	not set for SumDD
	//	min_warning	not set for SumDD
	//	delta_t	not set for SumDD
	//	delta_val	not set for SumDD
	
	sumdd->set_default_properties(sumdd_prop);
	//	Not Polled
	sumdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(sumdd);

	//	Attribute : VaDD
	VaDDAttrib	*vadd = new VaDDAttrib();
	Tango::UserDefaultAttrProp	vadd_prop;
	vadd_prop.set_description("Turn by turn data: Va");
	vadd_prop.set_label("DD Va");
	vadd_prop.set_unit("a.u.");
	vadd_prop.set_standard_unit("a.u.");
	vadd_prop.set_display_unit("a.u.");
	vadd_prop.set_format("%10.0f");
	//	max_value	not set for VaDD
	//	min_value	not set for VaDD
	//	max_alarm	not set for VaDD
	//	min_alarm	not set for VaDD
	//	max_warning	not set for VaDD
	//	min_warning	not set for VaDD
	//	delta_t	not set for VaDD
	//	delta_val	not set for VaDD
	
	vadd->set_default_properties(vadd_prop);
	//	Not Polled
	vadd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vadd);

	//	Attribute : VbDD
	VbDDAttrib	*vbdd = new VbDDAttrib();
	Tango::UserDefaultAttrProp	vbdd_prop;
	vbdd_prop.set_description("Turn by turn data: Vb");
	vbdd_prop.set_label("DD Vb");
	vbdd_prop.set_unit("a.u.");
	vbdd_prop.set_standard_unit("a.u.");
	vbdd_prop.set_display_unit("a.u.");
	vbdd_prop.set_format("%10.0f");
	//	max_value	not set for VbDD
	//	min_value	not set for VbDD
	//	max_alarm	not set for VbDD
	//	min_alarm	not set for VbDD
	//	max_warning	not set for VbDD
	//	min_warning	not set for VbDD
	//	delta_t	not set for VbDD
	//	delta_val	not set for VbDD
	
	vbdd->set_default_properties(vbdd_prop);
	//	Not Polled
	vbdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vbdd);

	//	Attribute : VcDD
	VcDDAttrib	*vcdd = new VcDDAttrib();
	Tango::UserDefaultAttrProp	vcdd_prop;
	vcdd_prop.set_description("Turn by turn data: Vc");
	vcdd_prop.set_label("DD Vc");
	vcdd_prop.set_unit("a.u.");
	vcdd_prop.set_standard_unit("a.u.");
	vcdd_prop.set_display_unit("a.u.");
	vcdd_prop.set_format("%10.0f");
	//	max_value	not set for VcDD
	//	min_value	not set for VcDD
	//	max_alarm	not set for VcDD
	//	min_alarm	not set for VcDD
	//	max_warning	not set for VcDD
	//	min_warning	not set for VcDD
	//	delta_t	not set for VcDD
	//	delta_val	not set for VcDD
	
	vcdd->set_default_properties(vcdd_prop);
	//	Not Polled
	vcdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vcdd);

	//	Attribute : VdDD
	VdDDAttrib	*vddd = new VdDDAttrib();
	Tango::UserDefaultAttrProp	vddd_prop;
	vddd_prop.set_description("Turn by turn data: Vd");
	vddd_prop.set_label("DD Vd");
	vddd_prop.set_unit("a.u.");
	vddd_prop.set_standard_unit("a.u.");
	vddd_prop.set_display_unit("a.u.");
	vddd_prop.set_format("%10.0f");
	//	max_value	not set for VdDD
	//	min_value	not set for VdDD
	//	max_alarm	not set for VdDD
	//	min_alarm	not set for VdDD
	//	max_warning	not set for VdDD
	//	min_warning	not set for VdDD
	//	delta_t	not set for VdDD
	//	delta_val	not set for VdDD
	
	vddd->set_default_properties(vddd_prop);
	//	Not Polled
	vddd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vddd);

	//	Attribute : XPosSAHistory
	XPosSAHistoryAttrib	*xpossahistory = new XPosSAHistoryAttrib();
	Tango::UserDefaultAttrProp	xpossahistory_prop;
	xpossahistory_prop.set_description("Slow Acquisition: X scrolling window of last NumSamples \n(512) sa samples");
	xpossahistory_prop.set_label("SA X Pos. History");
	xpossahistory_prop.set_unit("mm");
	xpossahistory_prop.set_standard_unit("mm");
	xpossahistory_prop.set_display_unit("mm");
	xpossahistory_prop.set_format("%8.4f");
	//	max_value	not set for XPosSAHistory
	//	min_value	not set for XPosSAHistory
	//	max_alarm	not set for XPosSAHistory
	//	min_alarm	not set for XPosSAHistory
	//	max_warning	not set for XPosSAHistory
	//	min_warning	not set for XPosSAHistory
	//	delta_t	not set for XPosSAHistory
	//	delta_val	not set for XPosSAHistory
	
	xpossahistory->set_default_properties(xpossahistory_prop);
	//	Not Polled
	xpossahistory->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xpossahistory);

	//	Attribute : YPosSAHistory
	YPosSAHistoryAttrib	*ypossahistory = new YPosSAHistoryAttrib();
	Tango::UserDefaultAttrProp	ypossahistory_prop;
	ypossahistory_prop.set_description("Slow Acquisition: Y scrolling window of last NumSamples \n(512) sa samples");
	ypossahistory_prop.set_label("SA Y Pos. History");
	ypossahistory_prop.set_unit("mm");
	ypossahistory_prop.set_standard_unit("mm");
	ypossahistory_prop.set_display_unit("mm");
	ypossahistory_prop.set_format("%8.4f");
	//	max_value	not set for YPosSAHistory
	//	min_value	not set for YPosSAHistory
	//	max_alarm	not set for YPosSAHistory
	//	min_alarm	not set for YPosSAHistory
	//	max_warning	not set for YPosSAHistory
	//	min_warning	not set for YPosSAHistory
	//	delta_t	not set for YPosSAHistory
	//	delta_val	not set for YPosSAHistory
	
	ypossahistory->set_default_properties(ypossahistory_prop);
	//	Not Polled
	ypossahistory->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ypossahistory);

	//	Attribute : SumSAHistory
	SumSAHistoryAttrib	*sumsahistory = new SumSAHistoryAttrib();
	Tango::UserDefaultAttrProp	sumsahistory_prop;
	sumsahistory_prop.set_description("Slow Acquisition: Sum scrolling window of last \nNumSamples (512) sa samples");
	sumsahistory_prop.set_label("SA Sum. History");
	sumsahistory_prop.set_unit("a.u.");
	sumsahistory_prop.set_standard_unit("a.u.");
	sumsahistory_prop.set_display_unit("a.u.");
	sumsahistory_prop.set_format("%8.4f");
	//	max_value	not set for SumSAHistory
	//	min_value	not set for SumSAHistory
	//	max_alarm	not set for SumSAHistory
	//	min_alarm	not set for SumSAHistory
	//	max_warning	not set for SumSAHistory
	//	min_warning	not set for SumSAHistory
	//	delta_t	not set for SumSAHistory
	//	delta_val	not set for SumSAHistory
	
	sumsahistory->set_default_properties(sumsahistory_prop);
	//	Not Polled
	sumsahistory->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(sumsahistory);

	//	Attribute : XPosPM
	XPosPMAttrib	*xpospm = new XPosPMAttrib();
	Tango::UserDefaultAttrProp	xpospm_prop;
	xpospm_prop.set_description("Post Mortem : X pos.");
	xpospm_prop.set_label("X Post Mortem Data");
	xpospm_prop.set_unit("mm");
	xpospm_prop.set_standard_unit("mm");
	xpospm_prop.set_display_unit("mm");
	xpospm_prop.set_format("%8.4f");
	//	max_value	not set for XPosPM
	//	min_value	not set for XPosPM
	//	max_alarm	not set for XPosPM
	//	min_alarm	not set for XPosPM
	//	max_warning	not set for XPosPM
	//	min_warning	not set for XPosPM
	//	delta_t	not set for XPosPM
	//	delta_val	not set for XPosPM
	
	xpospm->set_default_properties(xpospm_prop);
	//	Not Polled
	xpospm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xpospm);

	//	Attribute : YPosPM
	YPosPMAttrib	*ypospm = new YPosPMAttrib();
	Tango::UserDefaultAttrProp	ypospm_prop;
	ypospm_prop.set_description("Post Mortem : Y pos.");
	ypospm_prop.set_label("Y Post Mortem Data");
	ypospm_prop.set_unit("mm");
	ypospm_prop.set_standard_unit("mm");
	ypospm_prop.set_display_unit("mm");
	ypospm_prop.set_format("%8.4f");
	//	max_value	not set for YPosPM
	//	min_value	not set for YPosPM
	//	max_alarm	not set for YPosPM
	//	min_alarm	not set for YPosPM
	//	max_warning	not set for YPosPM
	//	min_warning	not set for YPosPM
	//	delta_t	not set for YPosPM
	//	delta_val	not set for YPosPM
	
	ypospm->set_default_properties(ypospm_prop);
	//	Not Polled
	ypospm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ypospm);

	//	Attribute : QuadPM
	QuadPMAttrib	*quadpm = new QuadPMAttrib();
	Tango::UserDefaultAttrProp	quadpm_prop;
	quadpm_prop.set_description("Post Mortem : Quad");
	quadpm_prop.set_label("Quad Post Mortem Data");
	quadpm_prop.set_unit("a.u");
	quadpm_prop.set_standard_unit("a.u");
	quadpm_prop.set_display_unit("a.u");
	quadpm_prop.set_format("%8.4f");
	//	max_value	not set for QuadPM
	//	min_value	not set for QuadPM
	//	max_alarm	not set for QuadPM
	//	min_alarm	not set for QuadPM
	//	max_warning	not set for QuadPM
	//	min_warning	not set for QuadPM
	//	delta_t	not set for QuadPM
	//	delta_val	not set for QuadPM
	
	quadpm->set_default_properties(quadpm_prop);
	//	Not Polled
	quadpm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(quadpm);

	//	Attribute : SumPM
	SumPMAttrib	*sumpm = new SumPMAttrib();
	Tango::UserDefaultAttrProp	sumpm_prop;
	sumpm_prop.set_description("Post Mortem : Sum");
	sumpm_prop.set_label("Sum Post Mortem Data");
	sumpm_prop.set_unit("a.u");
	sumpm_prop.set_standard_unit("a.u");
	sumpm_prop.set_display_unit("a.u");
	sumpm_prop.set_format("%10.0f");
	//	max_value	not set for SumPM
	//	min_value	not set for SumPM
	//	max_alarm	not set for SumPM
	//	min_alarm	not set for SumPM
	//	max_warning	not set for SumPM
	//	min_warning	not set for SumPM
	//	delta_t	not set for SumPM
	//	delta_val	not set for SumPM
	
	sumpm->set_default_properties(sumpm_prop);
	//	Not Polled
	sumpm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(sumpm);

	//	Attribute : VaPM
	VaPMAttrib	*vapm = new VaPMAttrib();
	Tango::UserDefaultAttrProp	vapm_prop;
	vapm_prop.set_description("Post Mortem : Va");
	vapm_prop.set_label("Va Post Mortem Data");
	vapm_prop.set_unit("a.u.");
	vapm_prop.set_standard_unit("a.u.");
	vapm_prop.set_display_unit("a.u.");
	vapm_prop.set_format("%10.0f");
	//	max_value	not set for VaPM
	//	min_value	not set for VaPM
	//	max_alarm	not set for VaPM
	//	min_alarm	not set for VaPM
	//	max_warning	not set for VaPM
	//	min_warning	not set for VaPM
	//	delta_t	not set for VaPM
	//	delta_val	not set for VaPM
	
	vapm->set_default_properties(vapm_prop);
	//	Not Polled
	vapm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vapm);

	//	Attribute : VbPM
	VbPMAttrib	*vbpm = new VbPMAttrib();
	Tango::UserDefaultAttrProp	vbpm_prop;
	vbpm_prop.set_description("Post Mortem : Vb");
	vbpm_prop.set_label("Vb Post Mortem Data");
	vbpm_prop.set_unit("a.u.");
	vbpm_prop.set_standard_unit("a.u.");
	vbpm_prop.set_display_unit("a.u.");
	vbpm_prop.set_format("%10.0f");
	//	max_value	not set for VbPM
	//	min_value	not set for VbPM
	//	max_alarm	not set for VbPM
	//	min_alarm	not set for VbPM
	//	max_warning	not set for VbPM
	//	min_warning	not set for VbPM
	//	delta_t	not set for VbPM
	//	delta_val	not set for VbPM
	
	vbpm->set_default_properties(vbpm_prop);
	//	Not Polled
	vbpm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vbpm);

	//	Attribute : VcPM
	VcPMAttrib	*vcpm = new VcPMAttrib();
	Tango::UserDefaultAttrProp	vcpm_prop;
	vcpm_prop.set_description("Post Mortem : Vc");
	vcpm_prop.set_label("Post Mortem : Vc");
	vcpm_prop.set_unit("a.u.");
	vcpm_prop.set_standard_unit("a.u.");
	vcpm_prop.set_display_unit("a.u.");
	vcpm_prop.set_format("%10.0f");
	//	max_value	not set for VcPM
	//	min_value	not set for VcPM
	//	max_alarm	not set for VcPM
	//	min_alarm	not set for VcPM
	//	max_warning	not set for VcPM
	//	min_warning	not set for VcPM
	//	delta_t	not set for VcPM
	//	delta_val	not set for VcPM
	
	vcpm->set_default_properties(vcpm_prop);
	//	Not Polled
	vcpm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vcpm);

	//	Attribute : VdPM
	VdPMAttrib	*vdpm = new VdPMAttrib();
	Tango::UserDefaultAttrProp	vdpm_prop;
	vdpm_prop.set_description("Post Mortem : Vd");
	vdpm_prop.set_label("Vd Post Mortem Data");
	vdpm_prop.set_unit("a.u.");
	vdpm_prop.set_standard_unit("a.u.");
	vdpm_prop.set_display_unit("a.u.");
	vdpm_prop.set_format("%10.0f");
	//	max_value	not set for VdPM
	//	min_value	not set for VdPM
	//	max_alarm	not set for VdPM
	//	min_alarm	not set for VdPM
	//	max_warning	not set for VdPM
	//	min_warning	not set for VdPM
	//	delta_t	not set for VdPM
	//	delta_val	not set for VdPM
	
	vdpm->set_default_properties(vdpm_prop);
	//	Not Polled
	vdpm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vdpm);

	//	Attribute : ADCChannelA
	ADCChannelAAttrib	*adcchannela = new ADCChannelAAttrib();
	Tango::UserDefaultAttrProp	adcchannela_prop;
	adcchannela_prop.set_description("ADC values for pickup A");
	adcchannela_prop.set_label("ADC Channel A");
	adcchannela_prop.set_unit("a.u");
	adcchannela_prop.set_standard_unit("a.u");
	adcchannela_prop.set_display_unit("a.u");
	adcchannela_prop.set_format("%8d");
	//	max_value	not set for ADCChannelA
	//	min_value	not set for ADCChannelA
	//	max_alarm	not set for ADCChannelA
	//	min_alarm	not set for ADCChannelA
	//	max_warning	not set for ADCChannelA
	//	min_warning	not set for ADCChannelA
	//	delta_t	not set for ADCChannelA
	//	delta_val	not set for ADCChannelA
	
	adcchannela->set_default_properties(adcchannela_prop);
	//	Not Polled
	adcchannela->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(adcchannela);

	//	Attribute : ADCChannelB
	ADCChannelBAttrib	*adcchannelb = new ADCChannelBAttrib();
	Tango::UserDefaultAttrProp	adcchannelb_prop;
	adcchannelb_prop.set_description("ADC values for pickup B");
	adcchannelb_prop.set_label("ADC Channel B");
	adcchannelb_prop.set_unit("a.u");
	adcchannelb_prop.set_standard_unit("a.u");
	adcchannelb_prop.set_display_unit("a.u");
	adcchannelb_prop.set_format("%8d");
	//	max_value	not set for ADCChannelB
	//	min_value	not set for ADCChannelB
	//	max_alarm	not set for ADCChannelB
	//	min_alarm	not set for ADCChannelB
	//	max_warning	not set for ADCChannelB
	//	min_warning	not set for ADCChannelB
	//	delta_t	not set for ADCChannelB
	//	delta_val	not set for ADCChannelB
	
	adcchannelb->set_default_properties(adcchannelb_prop);
	//	Not Polled
	adcchannelb->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(adcchannelb);

	//	Attribute : ADCChannelC
	ADCChannelCAttrib	*adcchannelc = new ADCChannelCAttrib();
	Tango::UserDefaultAttrProp	adcchannelc_prop;
	adcchannelc_prop.set_description("ADC values for pickup C");
	adcchannelc_prop.set_label("ADC Channel C");
	adcchannelc_prop.set_unit("a.u");
	adcchannelc_prop.set_standard_unit("a.u");
	adcchannelc_prop.set_display_unit("a.u");
	adcchannelc_prop.set_format("%8d");
	//	max_value	not set for ADCChannelC
	//	min_value	not set for ADCChannelC
	//	max_alarm	not set for ADCChannelC
	//	min_alarm	not set for ADCChannelC
	//	max_warning	not set for ADCChannelC
	//	min_warning	not set for ADCChannelC
	//	delta_t	not set for ADCChannelC
	//	delta_val	not set for ADCChannelC
	
	adcchannelc->set_default_properties(adcchannelc_prop);
	//	Not Polled
	adcchannelc->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(adcchannelc);

	//	Attribute : ADCChannelD
	ADCChannelDAttrib	*adcchanneld = new ADCChannelDAttrib();
	Tango::UserDefaultAttrProp	adcchanneld_prop;
	adcchanneld_prop.set_description("ADC values for pickup D");
	adcchanneld_prop.set_label("ADC Channel D");
	adcchanneld_prop.set_unit("a.u");
	adcchanneld_prop.set_standard_unit("a.u");
	adcchanneld_prop.set_display_unit("a.u");
	adcchanneld_prop.set_format("%8d");
	//	max_value	not set for ADCChannelD
	//	min_value	not set for ADCChannelD
	//	max_alarm	not set for ADCChannelD
	//	min_alarm	not set for ADCChannelD
	//	max_warning	not set for ADCChannelD
	//	min_warning	not set for ADCChannelD
	//	delta_t	not set for ADCChannelD
	//	delta_val	not set for ADCChannelD
	
	adcchanneld->set_default_properties(adcchanneld_prop);
	//	Not Polled
	adcchanneld->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(adcchanneld);

	//	Attribute : IaDD
	IaDDAttrib	*iadd = new IaDDAttrib();
	Tango::UserDefaultAttrProp	iadd_prop;
	iadd_prop.set_description("Turn by turn data: Ia");
	iadd_prop.set_label("DD Ia");
	iadd_prop.set_unit("a.u.");
	//	standard_unit	not set for IaDD
	//	display_unit	not set for IaDD
	iadd_prop.set_format("%10.0f");
	//	max_value	not set for IaDD
	//	min_value	not set for IaDD
	//	max_alarm	not set for IaDD
	//	min_alarm	not set for IaDD
	//	max_warning	not set for IaDD
	//	min_warning	not set for IaDD
	//	delta_t	not set for IaDD
	//	delta_val	not set for IaDD
	
	iadd->set_default_properties(iadd_prop);
	//	Not Polled
	iadd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(iadd);

	//	Attribute : IbDD
	IbDDAttrib	*ibdd = new IbDDAttrib();
	Tango::UserDefaultAttrProp	ibdd_prop;
	ibdd_prop.set_description("Turn by turn data: Ib");
	ibdd_prop.set_label("DD Ib");
	ibdd_prop.set_unit("a.u.");
	//	standard_unit	not set for IbDD
	//	display_unit	not set for IbDD
	ibdd_prop.set_format("%10.0f");
	//	max_value	not set for IbDD
	//	min_value	not set for IbDD
	//	max_alarm	not set for IbDD
	//	min_alarm	not set for IbDD
	//	max_warning	not set for IbDD
	//	min_warning	not set for IbDD
	//	delta_t	not set for IbDD
	//	delta_val	not set for IbDD
	
	ibdd->set_default_properties(ibdd_prop);
	//	Not Polled
	ibdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ibdd);

	//	Attribute : IcDD
	IcDDAttrib	*icdd = new IcDDAttrib();
	Tango::UserDefaultAttrProp	icdd_prop;
	icdd_prop.set_description("Turn by turn data: Ic");
	icdd_prop.set_label("DD Ic");
	icdd_prop.set_unit("a.u.");
	//	standard_unit	not set for IcDD
	//	display_unit	not set for IcDD
	icdd_prop.set_format("%10.0f");
	//	max_value	not set for IcDD
	//	min_value	not set for IcDD
	//	max_alarm	not set for IcDD
	//	min_alarm	not set for IcDD
	//	max_warning	not set for IcDD
	//	min_warning	not set for IcDD
	//	delta_t	not set for IcDD
	//	delta_val	not set for IcDD
	
	icdd->set_default_properties(icdd_prop);
	//	Not Polled
	icdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(icdd);

	//	Attribute : IdDD
	IdDDAttrib	*iddd = new IdDDAttrib();
	Tango::UserDefaultAttrProp	iddd_prop;
	iddd_prop.set_description("Turn by turn data: Id");
	iddd_prop.set_label("DD Id");
	iddd_prop.set_unit("a.u.");
	//	standard_unit	not set for IdDD
	//	display_unit	not set for IdDD
	iddd_prop.set_format("%10.0f");
	//	max_value	not set for IdDD
	//	min_value	not set for IdDD
	//	max_alarm	not set for IdDD
	//	min_alarm	not set for IdDD
	//	max_warning	not set for IdDD
	//	min_warning	not set for IdDD
	//	delta_t	not set for IdDD
	//	delta_val	not set for IdDD
	
	iddd->set_default_properties(iddd_prop);
	//	Not Polled
	iddd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(iddd);

	//	Attribute : QaDD
	QaDDAttrib	*qadd = new QaDDAttrib();
	Tango::UserDefaultAttrProp	qadd_prop;
	qadd_prop.set_description("Turn by turn data: Qa");
	qadd_prop.set_label("DD Qa");
	qadd_prop.set_unit("a.u.");
	//	standard_unit	not set for QaDD
	//	display_unit	not set for QaDD
	qadd_prop.set_format("%10.0f");
	//	max_value	not set for QaDD
	//	min_value	not set for QaDD
	//	max_alarm	not set for QaDD
	//	min_alarm	not set for QaDD
	//	max_warning	not set for QaDD
	//	min_warning	not set for QaDD
	//	delta_t	not set for QaDD
	//	delta_val	not set for QaDD
	
	qadd->set_default_properties(qadd_prop);
	//	Not Polled
	qadd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(qadd);

	//	Attribute : QbDD
	QbDDAttrib	*qbdd = new QbDDAttrib();
	Tango::UserDefaultAttrProp	qbdd_prop;
	qbdd_prop.set_description("Turn by turn data: Qb");
	qbdd_prop.set_label("DD Qb");
	qbdd_prop.set_unit("a.u.");
	//	standard_unit	not set for QbDD
	//	display_unit	not set for QbDD
	qbdd_prop.set_format("%10.0f");
	//	max_value	not set for QbDD
	//	min_value	not set for QbDD
	//	max_alarm	not set for QbDD
	//	min_alarm	not set for QbDD
	//	max_warning	not set for QbDD
	//	min_warning	not set for QbDD
	//	delta_t	not set for QbDD
	//	delta_val	not set for QbDD
	
	qbdd->set_default_properties(qbdd_prop);
	//	Not Polled
	qbdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(qbdd);

	//	Attribute : QcDD
	QcDDAttrib	*qcdd = new QcDDAttrib();
	Tango::UserDefaultAttrProp	qcdd_prop;
	qcdd_prop.set_description("Turn by turn data: Qc");
	qcdd_prop.set_label("DD Qc");
	qcdd_prop.set_unit("a.u.");
	//	standard_unit	not set for QcDD
	//	display_unit	not set for QcDD
	qcdd_prop.set_format("%10.0f");
	//	max_value	not set for QcDD
	//	min_value	not set for QcDD
	//	max_alarm	not set for QcDD
	//	min_alarm	not set for QcDD
	//	max_warning	not set for QcDD
	//	min_warning	not set for QcDD
	//	delta_t	not set for QcDD
	//	delta_val	not set for QcDD
	
	qcdd->set_default_properties(qcdd_prop);
	//	Not Polled
	qcdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(qcdd);

	//	Attribute : QdDD
	QdDDAttrib	*qddd = new QdDDAttrib();
	Tango::UserDefaultAttrProp	qddd_prop;
	qddd_prop.set_description("Turn by turn data: Qd");
	qddd_prop.set_label("DD Qd");
	qddd_prop.set_unit("a.u.");
	//	standard_unit	not set for QdDD
	//	display_unit	not set for QdDD
	qddd_prop.set_format("%10.0f");
	//	max_value	not set for QdDD
	//	min_value	not set for QdDD
	//	max_alarm	not set for QdDD
	//	min_alarm	not set for QdDD
	//	max_warning	not set for QdDD
	//	min_warning	not set for QdDD
	//	delta_t	not set for QdDD
	//	delta_val	not set for QdDD
	
	qddd->set_default_properties(qddd_prop);
	//	Not Polled
	qddd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(qddd);

	//	Attribute : UserData
	UserDataAttrib	*userdata = new UserDataAttrib();
	Tango::UserDefaultAttrProp	userdata_prop;
	userdata_prop.set_description("User defined data");
	//	label	not set for UserData
	//	unit	not set for UserData
	//	standard_unit	not set for UserData
	//	display_unit	not set for UserData
	//	format	not set for UserData
	//	max_value	not set for UserData
	//	min_value	not set for UserData
	//	max_alarm	not set for UserData
	//	min_alarm	not set for UserData
	//	max_warning	not set for UserData
	//	min_warning	not set for UserData
	//	delta_t	not set for UserData
	//	delta_val	not set for UserData
	
	userdata->set_default_properties(userdata_prop);
	//	Not Polled
	userdata->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(userdata);

	//	Attribute : logs
	logsAttrib	*logs = new logsAttrib();
	Tango::UserDefaultAttrProp	logs_prop;
	//	description	not set for logs
	//	label	not set for logs
	//	unit	not set for logs
	//	standard_unit	not set for logs
	//	display_unit	not set for logs
	//	format	not set for logs
	//	max_value	not set for logs
	//	min_value	not set for logs
	//	max_alarm	not set for logs
	//	min_alarm	not set for logs
	//	max_warning	not set for logs
	//	min_warning	not set for logs
	//	delta_t	not set for logs
	//	delta_val	not set for logs
	
	logs->set_default_properties(logs_prop);
	//	Not Polled
	logs->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(logs);

	//	Attribute : XPosTD
	XPosTDAttrib	*xpostd = new XPosTDAttrib();
	Tango::UserDefaultAttrProp	xpostd_prop;
	xpostd_prop.set_description("Turn by turn data: X Pos.");
	xpostd_prop.set_label("TD X Pos.");
	xpostd_prop.set_unit("mm");
	xpostd_prop.set_standard_unit("mm");
	xpostd_prop.set_display_unit("mm");
	xpostd_prop.set_format("%8.4f");
	//	max_value	not set for XPosTD
	//	min_value	not set for XPosTD
	//	max_alarm	not set for XPosTD
	//	min_alarm	not set for XPosTD
	//	max_warning	not set for XPosTD
	//	min_warning	not set for XPosTD
	//	delta_t	not set for XPosTD
	//	delta_val	not set for XPosTD
	
	xpostd->set_default_properties(xpostd_prop);
	//	Not Polled
	xpostd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xpostd);

	//	Attribute : YPosTD
	YPosTDAttrib	*ypostd = new YPosTDAttrib();
	Tango::UserDefaultAttrProp	ypostd_prop;
	ypostd_prop.set_description("Turn by turn data: Y Pos.");
	ypostd_prop.set_label("TD Y Pos.");
	ypostd_prop.set_unit("mm");
	ypostd_prop.set_standard_unit("mm");
	ypostd_prop.set_display_unit("mm");
	ypostd_prop.set_format("%8.4f");
	//	max_value	not set for YPosTD
	//	min_value	not set for YPosTD
	//	max_alarm	not set for YPosTD
	//	min_alarm	not set for YPosTD
	//	max_warning	not set for YPosTD
	//	min_warning	not set for YPosTD
	//	delta_t	not set for YPosTD
	//	delta_val	not set for YPosTD
	
	ypostd->set_default_properties(ypostd_prop);
	//	Not Polled
	ypostd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ypostd);

	//	Attribute : QuadTD
	QuadTDAttrib	*quadtd = new QuadTDAttrib();
	Tango::UserDefaultAttrProp	quadtd_prop;
	quadtd_prop.set_description("Turn by turn data: Quad");
	quadtd_prop.set_label("TD Quad");
	quadtd_prop.set_unit("a.u.");
	quadtd_prop.set_standard_unit("a.u.");
	quadtd_prop.set_display_unit("a.u.");
	quadtd_prop.set_format("%8.4f");
	//	max_value	not set for QuadTD
	//	min_value	not set for QuadTD
	//	max_alarm	not set for QuadTD
	//	min_alarm	not set for QuadTD
	//	max_warning	not set for QuadTD
	//	min_warning	not set for QuadTD
	//	delta_t	not set for QuadTD
	//	delta_val	not set for QuadTD
	
	quadtd->set_default_properties(quadtd_prop);
	//	Not Polled
	quadtd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(quadtd);

	//	Attribute : SumTD
	SumTDAttrib	*sumtd = new SumTDAttrib();
	Tango::UserDefaultAttrProp	sumtd_prop;
	sumtd_prop.set_description("Turn by turn data: Sum");
	sumtd_prop.set_label("TD Sum");
	sumtd_prop.set_unit("mm");
	sumtd_prop.set_standard_unit("mm");
	sumtd_prop.set_display_unit("mm");
	sumtd_prop.set_format("%10.0f");
	//	max_value	not set for SumTD
	//	min_value	not set for SumTD
	//	max_alarm	not set for SumTD
	//	min_alarm	not set for SumTD
	//	max_warning	not set for SumTD
	//	min_warning	not set for SumTD
	//	delta_t	not set for SumTD
	//	delta_val	not set for SumTD
	
	sumtd->set_default_properties(sumtd_prop);
	//	Not Polled
	sumtd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(sumtd);

	//	Attribute : VaTD
	VaTDAttrib	*vatd = new VaTDAttrib();
	Tango::UserDefaultAttrProp	vatd_prop;
	vatd_prop.set_description("Turn by turn data: Va");
	vatd_prop.set_label("TD Va");
	vatd_prop.set_unit("a.u.");
	vatd_prop.set_standard_unit("a.u.");
	vatd_prop.set_display_unit("a.u.");
	vatd_prop.set_format("%10.0f");
	//	max_value	not set for VaTD
	//	min_value	not set for VaTD
	//	max_alarm	not set for VaTD
	//	min_alarm	not set for VaTD
	//	max_warning	not set for VaTD
	//	min_warning	not set for VaTD
	//	delta_t	not set for VaTD
	//	delta_val	not set for VaTD
	
	vatd->set_default_properties(vatd_prop);
	//	Not Polled
	vatd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vatd);

	//	Attribute : VbTD
	VbTDAttrib	*vbtd = new VbTDAttrib();
	Tango::UserDefaultAttrProp	vbtd_prop;
	vbtd_prop.set_description("Turn by turn data: Vb");
	vbtd_prop.set_label("TD Vb");
	vbtd_prop.set_unit("a.u.");
	vbtd_prop.set_standard_unit("a.u.");
	vbtd_prop.set_display_unit("a.u.");
	vbtd_prop.set_format("%10.0f");
	//	max_value	not set for VbTD
	//	min_value	not set for VbTD
	//	max_alarm	not set for VbTD
	//	min_alarm	not set for VbTD
	//	max_warning	not set for VbTD
	//	min_warning	not set for VbTD
	//	delta_t	not set for VbTD
	//	delta_val	not set for VbTD
	
	vbtd->set_default_properties(vbtd_prop);
	//	Not Polled
	vbtd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vbtd);

	//	Attribute : VcTD
	VcTDAttrib	*vctd = new VcTDAttrib();
	Tango::UserDefaultAttrProp	vctd_prop;
	vctd_prop.set_description("Turn by turn data: Vc");
	vctd_prop.set_label("TD Vc");
	vctd_prop.set_unit("a.u.");
	vctd_prop.set_standard_unit("a.u.");
	vctd_prop.set_display_unit("a.u.");
	vctd_prop.set_format("%10.0f");
	//	max_value	not set for VcTD
	//	min_value	not set for VcTD
	//	max_alarm	not set for VcTD
	//	min_alarm	not set for VcTD
	//	max_warning	not set for VcTD
	//	min_warning	not set for VcTD
	//	delta_t	not set for VcTD
	//	delta_val	not set for VcTD
	
	vctd->set_default_properties(vctd_prop);
	//	Not Polled
	vctd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vctd);

	//	Attribute : VdTD
	VdTDAttrib	*vdtd = new VdTDAttrib();
	Tango::UserDefaultAttrProp	vdtd_prop;
	vdtd_prop.set_description("Turn by turn data: Vd");
	vdtd_prop.set_label("TD Vd");
	vdtd_prop.set_unit("a.u.");
	vdtd_prop.set_standard_unit("a.u.");
	vdtd_prop.set_display_unit("a.u.");
	vdtd_prop.set_format("%10.0f");
	//	max_value	not set for VdTD
	//	min_value	not set for VdTD
	//	max_alarm	not set for VdTD
	//	min_alarm	not set for VdTD
	//	max_warning	not set for VdTD
	//	min_warning	not set for VdTD
	//	delta_t	not set for VdTD
	//	delta_val	not set for VdTD
	
	vdtd->set_default_properties(vdtd_prop);
	//	Not Polled
	vdtd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vdtd);

	//	Attribute : VaSP
	VaSPAttrib	*vasp = new VaSPAttrib();
	Tango::UserDefaultAttrProp	vasp_prop;
	vasp_prop.set_description("Single Pass data: Va");
	vasp_prop.set_label("SP Va");
	vasp_prop.set_unit("a.u.");
	vasp_prop.set_standard_unit("a.u.");
	vasp_prop.set_display_unit("a.u.");
	vasp_prop.set_format("%10.0f");
	//	max_value	not set for VaSP
	//	min_value	not set for VaSP
	//	max_alarm	not set for VaSP
	//	min_alarm	not set for VaSP
	//	max_warning	not set for VaSP
	//	min_warning	not set for VaSP
	//	delta_t	not set for VaSP
	//	delta_val	not set for VaSP
	
	vasp->set_default_properties(vasp_prop);
	//	Not Polled
	vasp->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vasp);

	//	Attribute : VbSP
	VbSPAttrib	*vbsp = new VbSPAttrib();
	Tango::UserDefaultAttrProp	vbsp_prop;
	vbsp_prop.set_description("Single Pass data: Vb");
	vbsp_prop.set_label("SP Vb");
	vbsp_prop.set_unit("a.u.");
	vbsp_prop.set_standard_unit("a.u.");
	vbsp_prop.set_display_unit("a.u.");
	vbsp_prop.set_format("%10.0f");
	//	max_value	not set for VbSP
	//	min_value	not set for VbSP
	//	max_alarm	not set for VbSP
	//	min_alarm	not set for VbSP
	//	max_warning	not set for VbSP
	//	min_warning	not set for VbSP
	//	delta_t	not set for VbSP
	//	delta_val	not set for VbSP
	
	vbsp->set_default_properties(vbsp_prop);
	//	Not Polled
	vbsp->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vbsp);

	//	Attribute : VcSP
	VcSPAttrib	*vcsp = new VcSPAttrib();
	Tango::UserDefaultAttrProp	vcsp_prop;
	vcsp_prop.set_description("Single Pass data: Vc");
	vcsp_prop.set_label("SP Vc");
	vcsp_prop.set_unit("a.u.");
	vcsp_prop.set_standard_unit("a.u.");
	vcsp_prop.set_display_unit("a.u.");
	vcsp_prop.set_format("%10.0f");
	//	max_value	not set for VcSP
	//	min_value	not set for VcSP
	//	max_alarm	not set for VcSP
	//	min_alarm	not set for VcSP
	//	max_warning	not set for VcSP
	//	min_warning	not set for VcSP
	//	delta_t	not set for VcSP
	//	delta_val	not set for VcSP
	
	vcsp->set_default_properties(vcsp_prop);
	//	Not Polled
	vcsp->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vcsp);

	//	Attribute : VdSP
	VdSPAttrib	*vdsp = new VdSPAttrib();
	Tango::UserDefaultAttrProp	vdsp_prop;
	vdsp_prop.set_description("Single Pass data: Vd");
	vdsp_prop.set_label("SP Vd");
	vdsp_prop.set_unit("a.u.");
	vdsp_prop.set_standard_unit("a.u.");
	vdsp_prop.set_display_unit("a.u.");
	vdsp_prop.set_format("%10.0f");
	//	max_value	not set for VdSP
	//	min_value	not set for VdSP
	//	max_alarm	not set for VdSP
	//	min_alarm	not set for VdSP
	//	max_warning	not set for VdSP
	//	min_warning	not set for VdSP
	//	delta_t	not set for VdSP
	//	delta_val	not set for VdSP
	
	vdsp->set_default_properties(vdsp_prop);
	//	Not Polled
	vdsp->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vdsp);

	//	Attribute : SumSP
	SumSPAttrib	*sumsp = new SumSPAttrib();
	Tango::UserDefaultAttrProp	sumsp_prop;
	sumsp_prop.set_description("Single Pass data: Sum");
	sumsp_prop.set_label("SP Sum");
	sumsp_prop.set_unit("mm");
	sumsp_prop.set_standard_unit("mm");
	sumsp_prop.set_display_unit("mm");
	sumsp_prop.set_format("%10.0f");
	//	max_value	not set for SumSP
	//	min_value	not set for SumSP
	//	max_alarm	not set for SumSP
	//	min_alarm	not set for SumSP
	//	max_warning	not set for SumSP
	//	min_warning	not set for SumSP
	//	delta_t	not set for SumSP
	//	delta_val	not set for SumSP
	
	sumsp->set_default_properties(sumsp_prop);
	//	Not Polled
	sumsp->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(sumsp);

	//	Attribute : XPosSP
	XPosSPAttrib	*xpossp = new XPosSPAttrib();
	Tango::UserDefaultAttrProp	xpossp_prop;
	xpossp_prop.set_description("Single Pass data: X Pos.");
	xpossp_prop.set_label("SP X Pos.");
	xpossp_prop.set_unit("mm");
	xpossp_prop.set_standard_unit("mm");
	xpossp_prop.set_display_unit("mm");
	xpossp_prop.set_format("%8.4f");
	//	max_value	not set for XPosSP
	//	min_value	not set for XPosSP
	//	max_alarm	not set for XPosSP
	//	min_alarm	not set for XPosSP
	//	max_warning	not set for XPosSP
	//	min_warning	not set for XPosSP
	//	delta_t	not set for XPosSP
	//	delta_val	not set for XPosSP
	
	xpossp->set_default_properties(xpossp_prop);
	//	Not Polled
	xpossp->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xpossp);

	//	Attribute : YPosSP
	YPosSPAttrib	*ypossp = new YPosSPAttrib();
	Tango::UserDefaultAttrProp	ypossp_prop;
	ypossp_prop.set_description("Single Pass data: Y Pos.");
	ypossp_prop.set_label("SP Y Pos.");
	ypossp_prop.set_unit("mm");
	ypossp_prop.set_standard_unit("mm");
	ypossp_prop.set_display_unit("mm");
	ypossp_prop.set_format("%8.4f");
	//	max_value	not set for YPosSP
	//	min_value	not set for YPosSP
	//	max_alarm	not set for YPosSP
	//	min_alarm	not set for YPosSP
	//	max_warning	not set for YPosSP
	//	min_warning	not set for YPosSP
	//	delta_t	not set for YPosSP
	//	delta_val	not set for YPosSP
	
	ypossp->set_default_properties(ypossp_prop);
	//	Not Polled
	ypossp->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ypossp);

	//	Attribute : ThdrId
	ThdrIdAttrib	*thdrid = new ThdrIdAttrib();
	Tango::UserDefaultAttrProp	thdrid_prop;
	thdrid_prop.set_description("Indicates the ADC sample in the ADC buffer where the threshold was exceeded");
	thdrid_prop.set_label("SP Thr_Idx");
	thdrid_prop.set_unit("a.u.");
	thdrid_prop.set_standard_unit("a.u.");
	thdrid_prop.set_display_unit("a.u.");
	thdrid_prop.set_format("%10.0f");
	//	max_value	not set for ThdrId
	//	min_value	not set for ThdrId
	//	max_alarm	not set for ThdrId
	//	min_alarm	not set for ThdrId
	//	max_warning	not set for ThdrId
	//	min_warning	not set for ThdrId
	//	delta_t	not set for ThdrId
	//	delta_val	not set for ThdrId
	
	thdrid->set_default_properties(thdrid_prop);
	//	Not Polled
	thdrid->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(thdrid);

	//	Create a list of static attributes
	create_static_attribute_list(get_class_attr()->get_attr_list());
	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::attribute_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::attribute_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::command_factory()
 *	Description : Create the command object(s)
 *                and store them in the command list
 */
//--------------------------------------------------------
void LiberaBrilliancePlusClass::command_factory()
{
	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::command_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::command_factory_before


	//	Command GetParameters
	GetParametersClass	*pGetParametersCmd =
		new GetParametersClass("GetParameters",
			Tango::DEV_VOID, Tango::DEVVAR_DOUBLESTRINGARRAY,
			"N/A",
			"The BPM gain and offsets",
			Tango::OPERATOR);
	command_list.push_back(pGetParametersCmd);

	//	Command UnfreezeDDBuffer
	UnfreezeDDBufferClass	*pUnfreezeDDBufferCmd =
		new UnfreezeDDBufferClass("UnfreezeDDBuffer",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pUnfreezeDDBufferCmd);

	//	Command EnableDDBufferFreezing
	EnableDDBufferFreezingClass	*pEnableDDBufferFreezingCmd =
		new EnableDDBufferFreezingClass("EnableDDBufferFreezing",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pEnableDDBufferFreezingCmd);

	//	Command DisableDDBufferFreezing
	DisableDDBufferFreezingClass	*pDisableDDBufferFreezingCmd =
		new DisableDDBufferFreezingClass("DisableDDBufferFreezing",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pDisableDDBufferFreezingCmd);

	//	Command EnableDD
	EnableDDClass	*pEnableDDCmd =
		new EnableDDClass("EnableDD",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pEnableDDCmd);

	//	Command DisableDD
	DisableDDClass	*pDisableDDCmd =
		new DisableDDClass("DisableDD",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pDisableDDCmd);

	//	Command EnableSA
	EnableSAClass	*pEnableSACmd =
		new EnableSAClass("EnableSA",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pEnableSACmd);

	//	Command DisableSA
	DisableSAClass	*pDisableSACmd =
		new DisableSAClass("DisableSA",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pDisableSACmd);

	//	Command ResetPMNotification
	ResetPMNotificationClass	*pResetPMNotificationCmd =
		new ResetPMNotificationClass("ResetPMNotification",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pResetPMNotificationCmd);

	//	Command ResetInterlockNotification
	ResetInterlockNotificationClass	*pResetInterlockNotificationCmd =
		new ResetInterlockNotificationClass("ResetInterlockNotification",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pResetInterlockNotificationCmd);

	//	Command SetInterlockConfiguration
	SetInterlockConfigurationClass	*pSetInterlockConfigurationCmd =
		new SetInterlockConfigurationClass("SetInterlockConfiguration",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pSetInterlockConfigurationCmd);

	//	Command EnableADC
	EnableADCClass	*pEnableADCCmd =
		new EnableADCClass("EnableADC",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pEnableADCCmd);

	//	Command DisableADC
	DisableADCClass	*pDisableADCCmd =
		new DisableADCClass("DisableADC",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pDisableADCCmd);

	//	Command SetTimeOnNextTrigger
	SetTimeOnNextTriggerClass	*pSetTimeOnNextTriggerCmd =
		new SetTimeOnNextTriggerClass("SetTimeOnNextTrigger",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pSetTimeOnNextTriggerCmd);

	//	Command ReadFAData
	ReadFADataClass	*pReadFADataCmd =
		new ReadFADataClass("ReadFAData",
			Tango::DEVVAR_LONGARRAY, Tango::DEVVAR_LONGARRAY,
			"The reading parameters: [0]:offset in FA data block, [1]:size of elems, [2]:num of elems",
			"The data [as an array of bytes]",
			Tango::OPERATOR);
	command_list.push_back(pReadFADataCmd);

	//	Command WriteFAData
	WriteFADataClass	*pWriteFADataCmd =
		new WriteFADataClass("WriteFAData",
			Tango::DEVVAR_LONGARRAY, Tango::DEV_VOID,
			"The writting parameters: [0]:offset in FA data block, bytes[1]:size of elems, [2]:num of elems, [3, ...]: actual to data to be written",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pWriteFADataCmd);

	//	Command SaveDSCParameters
	SaveDSCParametersClass	*pSaveDSCParametersCmd =
		new SaveDSCParametersClass("SaveDSCParameters",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pSaveDSCParametersCmd);

	//	Command ReloadSystemProperties
	ReloadSystemPropertiesClass	*pReloadSystemPropertiesCmd =
		new ReloadSystemPropertiesClass("ReloadSystemProperties",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pReloadSystemPropertiesCmd);

	//	Command SetRefIncoherence
	SetRefIncoherenceClass	*pSetRefIncoherenceCmd =
		new SetRefIncoherenceClass("SetRefIncoherence",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pSetRefIncoherenceCmd);

	//	Command MagicCommand
	MagicCommandClass	*pMagicCommandCmd =
		new MagicCommandClass("MagicCommand",
			Tango::DEV_STRING, Tango::DEVVAR_STRINGARRAY,
			"absolute path of the node name",
			"value of specified node(s)",
			Tango::EXPERT);
	command_list.push_back(pMagicCommandCmd);

	//	Command EnableTDBufferFreezing
	EnableTDBufferFreezingClass	*pEnableTDBufferFreezingCmd =
		new EnableTDBufferFreezingClass("EnableTDBufferFreezing",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pEnableTDBufferFreezingCmd);

	//	Command DisableTDBufferFreezing
	DisableTDBufferFreezingClass	*pDisableTDBufferFreezingCmd =
		new DisableTDBufferFreezingClass("DisableTDBufferFreezing",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pDisableTDBufferFreezingCmd);

	//	Command EnableTD
	EnableTDClass	*pEnableTDCmd =
		new EnableTDClass("EnableTD",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pEnableTDCmd);

	//	Command DisableTD
	DisableTDClass	*pDisableTDCmd =
		new DisableTDClass("DisableTD",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pDisableTDCmd);

	//	Command UnfreezeTDBuffer
	UnfreezeTDBufferClass	*pUnfreezeTDBufferCmd =
		new UnfreezeTDBufferClass("UnfreezeTDBuffer",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pUnfreezeTDBufferCmd);

	//	Command EnableSP
	EnableSPClass	*pEnableSPCmd =
		new EnableSPClass("EnableSP",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pEnableSPCmd);

	//	Command DisableSP
	DisableSPClass	*pDisableSPCmd =
		new DisableSPClass("DisableSP",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pDisableSPCmd);

	//	Command StartSynchronization
	StartSynchronizationClass	*pStartSynchronizationCmd =
		new StartSynchronizationClass("StartSynchronization",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pStartSynchronizationCmd);

	//	Command AnnounceSynchronization
	AnnounceSynchronizationClass	*pAnnounceSynchronizationCmd =
		new AnnounceSynchronizationClass("AnnounceSynchronization",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pAnnounceSynchronizationCmd);

	//	Command ForceInitSettings
	ForceInitSettingsClass	*pForceInitSettingsCmd =
		new ForceInitSettingsClass("ForceInitSettings",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pForceInitSettingsCmd);

	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::command_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::command_factory_after
}

//===================================================================
//	Dynamic attributes related methods
//===================================================================

//--------------------------------------------------------
/**
 * method : 		LiberaBrilliancePlusClass::create_static_attribute_list
 * description : 	Create the a list of static attributes
 *
 * @param	att_list	the ceated attribute list 
 */
//--------------------------------------------------------
void LiberaBrilliancePlusClass::create_static_attribute_list(vector<Tango::Attr *> &att_list)
{
	for (unsigned long i=0 ; i<att_list.size() ; i++)
	{
		string att_name(att_list[i]->get_name());
		transform(att_name.begin(), att_name.end(), att_name.begin(), ::tolower);
		defaultAttList.push_back(att_name);
	}

	cout2 << defaultAttList.size() << " attributes in default list" << endl;

	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::create_static_att_list) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::create_static_att_list
}


//--------------------------------------------------------
/**
 * method : 		LiberaBrilliancePlusClass::erase_dynamic_attributes
 * description : 	delete the dynamic attributes if any.
 *
 * @param	devlist_ptr	the device list pointer
 * @param	list of all attributes
 */
//--------------------------------------------------------
void LiberaBrilliancePlusClass::erase_dynamic_attributes(const Tango::DevVarStringArray *devlist_ptr, vector<Tango::Attr *> &att_list)
{
	Tango::Util *tg = Tango::Util::instance();

	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{	
		Tango::DeviceImpl *dev_impl = tg->get_device_by_name(((string)(*devlist_ptr)[i]).c_str());
		LiberaBrilliancePlus *dev = static_cast<LiberaBrilliancePlus *> (dev_impl);
		
		vector<Tango::Attribute *> &dev_att_list = dev->get_device_attr()->get_attribute_list();
		vector<Tango::Attribute *>::iterator ite_att;
		for (ite_att=dev_att_list.begin() ; ite_att != dev_att_list.end() ; ++ite_att)
		{
			string att_name((*ite_att)->get_name_lower());
			if ((att_name == "state") || (att_name == "status"))
				continue;
			vector<string>::iterator ite_str = find(defaultAttList.begin(), defaultAttList.end(), att_name);
			if (ite_str == defaultAttList.end())
			{
				cout2 << att_name << " is a UNWANTED dynamic attribute for device " << (*devlist_ptr)[i] << endl;
				Tango::Attribute &att = dev->get_device_attr()->get_attr_by_name(att_name.c_str());
				dev->remove_attribute(att_list[att.get_attr_idx()], true, false);
				--ite_att;
			}
		}
	}
	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::erase_dynamic_attributes) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::erase_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::get_attr_by_name()
 *	Description : returns Tango::Attr * object found by name
 */
//--------------------------------------------------------
Tango::Attr *LiberaBrilliancePlusClass::get_attr_object_by_name(vector<Tango::Attr *> &att_list, string attname)
{
	vector<Tango::Attr *>::iterator it;
	for (it=att_list.begin() ; it<att_list.end() ; it++)
		if ((*it)->get_name()==attname)
			return (*it);
	//	Attr does not exist
	return NULL;
}


/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::Additional Methods) ENABLED START -----*/

/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::Additional Methods
} //	namespace
