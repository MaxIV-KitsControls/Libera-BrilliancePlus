/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass.cpp) ENABLED START -----*/
static const char *RcsId      = "$Id:  $";
static const char *TagName    = "$Name:  $";
static const char *CvsPath    = "$Source:  $";
static const char *SvnPath    = "$HeadURL:  $";
static const char *HttpServer = "http://www.esrf.eu/computing/cs/tango/tango_doc/ds_doc/";
//=============================================================================
//
// file :        LiberaBrilliancePlusClass.cpp
//
// description : C++ source for the LiberaBrilliancePlusClass.
//               A singleton class derived from DeviceClass.
//               It implements the command and attribute list
//               and all properties and methods required
//               by the LiberaBrilliancePlus once per process.
//
// project :     Libera BPM Device Server
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <LiberaBrilliancePlusClass.h>

/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass.cpp

//-------------------------------------------------------------------
/**
 *	Create LiberaBrilliancePlusClass singleton and
 *	return it in a C function for Python usage
 */
//-------------------------------------------------------------------
extern "C" {
#ifdef _TG_WINDOWS_

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_LiberaBrilliancePlus_class(const char *name) {
		return LiberaBrilliancePlus_ns::LiberaBrilliancePlusClass::init(name);
	}
}

namespace LiberaBrilliancePlus_ns
{
//===================================================================
//	Initialize pointer for singleton pattern
//===================================================================
LiberaBrilliancePlusClass *LiberaBrilliancePlusClass::_instance = NULL;

//--------------------------------------------------------
/**
 * method : 		LiberaBrilliancePlusClass::LiberaBrilliancePlusClass(string &s)
 * description : 	constructor for the LiberaBrilliancePlusClass
 *
 * @param s	The class name
 */
//--------------------------------------------------------
LiberaBrilliancePlusClass::LiberaBrilliancePlusClass(string &s):Tango::DeviceClass(s)
{
	cout2 << "Entering LiberaBrilliancePlusClass constructor" << endl;
	set_default_property();
	get_class_property();
	write_class_property();

	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::constructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::constructor

	cout2 << "Leaving LiberaBrilliancePlusClass constructor" << endl;
}

//--------------------------------------------------------
/**
 * method : 		LiberaBrilliancePlusClass::~LiberaBrilliancePlusClass()
 * description : 	destructor for the LiberaBrilliancePlusClass
 */
//--------------------------------------------------------
LiberaBrilliancePlusClass::~LiberaBrilliancePlusClass()
{
	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::destructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::destructor

	_instance = NULL;
}


//--------------------------------------------------------
/**
 * method : 		LiberaBrilliancePlusClass::init
 * description : 	Create the object if not already done.
 *                  Otherwise, just return a pointer to the object
 *
 * @param	name	The class name
 */
//--------------------------------------------------------
LiberaBrilliancePlusClass *LiberaBrilliancePlusClass::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new LiberaBrilliancePlusClass(s);
		}
		catch (bad_alloc &)
		{
			throw;
		}		
	}		
	return _instance;
}

//--------------------------------------------------------
/**
 * method : 		LiberaBrilliancePlusClass::instance
 * description : 	Check if object already created,
 *                  and return a pointer to the object
 */
//--------------------------------------------------------
LiberaBrilliancePlusClass *LiberaBrilliancePlusClass::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}



//===================================================================
//	Command execution method calls
//===================================================================
//--------------------------------------------------------
/**
 * method : 		GetParametersClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetParametersClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetParametersClass::execute(): arrived" << endl;
	return insert((static_cast<LiberaBrilliancePlus *>(device))->get_parameters());
}

//--------------------------------------------------------
/**
 * method : 		UnfreezeDDBufferClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *UnfreezeDDBufferClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "UnfreezeDDBufferClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->unfreeze_ddbuffer());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		EnableDDBufferFreezingClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *EnableDDBufferFreezingClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "EnableDDBufferFreezingClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->enable_ddbuffer_freezing());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		DisableDDBufferFreezingClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *DisableDDBufferFreezingClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "DisableDDBufferFreezingClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->disable_ddbuffer_freezing());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		EnableDDClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *EnableDDClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "EnableDDClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->enable_dd());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		DisableDDClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *DisableDDClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "DisableDDClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->disable_dd());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		EnableSAClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *EnableSAClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "EnableSAClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->enable_sa());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		DisableSAClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *DisableSAClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "DisableSAClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->disable_sa());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ResetPMNotificationClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ResetPMNotificationClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ResetPMNotificationClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->reset_pmnotification());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ResetInterlockNotificationClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ResetInterlockNotificationClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ResetInterlockNotificationClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->reset_interlock_notification());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SetInterlockConfigurationClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SetInterlockConfigurationClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "SetInterlockConfigurationClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->set_interlock_configuration());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		EnableADCClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *EnableADCClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "EnableADCClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->enable_adc());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		DisableADCClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *DisableADCClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "DisableADCClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->disable_adc());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SetTimeOnNextTriggerClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SetTimeOnNextTriggerClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "SetTimeOnNextTriggerClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->set_time_on_next_trigger());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ReadFADataClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ReadFADataClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "ReadFADataClass::execute(): arrived" << endl;
	const Tango::DevVarLongArray *argin;
	extract(in_any, argin);
	return insert((static_cast<LiberaBrilliancePlus *>(device))->read_fadata(argin));
}

//--------------------------------------------------------
/**
 * method : 		WriteFADataClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *WriteFADataClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "WriteFADataClass::execute(): arrived" << endl;
	const Tango::DevVarLongArray *argin;
	extract(in_any, argin);
	((static_cast<LiberaBrilliancePlus *>(device))->write_fadata(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SaveDSCParametersClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SaveDSCParametersClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "SaveDSCParametersClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->save_dscparameters());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ReloadSystemPropertiesClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ReloadSystemPropertiesClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ReloadSystemPropertiesClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->reload_system_properties());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SetRefIncoherenceClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SetRefIncoherenceClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "SetRefIncoherenceClass::execute(): arrived" << endl;
	((static_cast<LiberaBrilliancePlus *>(device))->set_ref_incoherence());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		MagicCommandClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *MagicCommandClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "MagicCommandClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	return insert((static_cast<LiberaBrilliancePlus *>(device))->magic_command(argin));
}


//===================================================================
//	Properties management
//===================================================================
//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::get_class_property()
 *	Description : Get the class property for specified name.
 */
//--------------------------------------------------------
Tango::DbDatum LiberaBrilliancePlusClass::get_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, returns  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::get_default_device_property()
 *	Description : Return the default value for device property.
 */
//--------------------------------------------------------
Tango::DbDatum LiberaBrilliancePlusClass::get_default_device_property(string &prop_name)
{
	for (unsigned int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::get_default_class_property()
 *	Description : Return the default value for class property.
 */
//--------------------------------------------------------
Tango::DbDatum LiberaBrilliancePlusClass::get_default_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::get_class_property()
 *	Description : Read database to initialize class property data members.
 */
//--------------------------------------------------------
void LiberaBrilliancePlusClass::get_class_property()
{
	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::get_class_property_before) ENABLED START -----*/
	
	//	Initialize class property data members
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::get_class_property_before
	//	Read class properties from database.
	cl_prop.push_back(Tango::DbDatum("InterlockConfiguration"));
	cl_prop.push_back(Tango::DbDatum("EnableDDOptionalData"));
	cl_prop.push_back(Tango::DbDatum("EnableSAOptionalData"));
	cl_prop.push_back(Tango::DbDatum("EnableSAHistoryOptionalData"));
	cl_prop.push_back(Tango::DbDatum("EnableADCOptionalData"));
	cl_prop.push_back(Tango::DbDatum("Institute"));
	
	//	Call database and extract values
	if (Tango::Util::instance()->_UseDb==true)
		get_db_class()->get_property(cl_prop);
	Tango::DbDatum	def_prop;
	int	i = -1;

	//	Try to extract InterlockConfiguration value
	if (cl_prop[++i].is_empty()==false)	cl_prop[i]  >>  interlockConfiguration;
	else
	{
		//	Check default value for InterlockConfiguration
		def_prop = get_default_class_property(cl_prop[i].name);
		if (def_prop.is_empty()==false)
		{
			def_prop    >>  interlockConfiguration;
			cl_prop[i]  <<  interlockConfiguration;
		}
	}
	//	Try to extract EnableDDOptionalData value
	if (cl_prop[++i].is_empty()==false)	cl_prop[i]  >>  enableDDOptionalData;
	else
	{
		//	Check default value for EnableDDOptionalData
		def_prop = get_default_class_property(cl_prop[i].name);
		if (def_prop.is_empty()==false)
		{
			def_prop    >>  enableDDOptionalData;
			cl_prop[i]  <<  enableDDOptionalData;
		}
	}
	//	Try to extract EnableSAOptionalData value
	if (cl_prop[++i].is_empty()==false)	cl_prop[i]  >>  enableSAOptionalData;
	else
	{
		//	Check default value for EnableSAOptionalData
		def_prop = get_default_class_property(cl_prop[i].name);
		if (def_prop.is_empty()==false)
		{
			def_prop    >>  enableSAOptionalData;
			cl_prop[i]  <<  enableSAOptionalData;
		}
	}
	//	Try to extract EnableSAHistoryOptionalData value
	if (cl_prop[++i].is_empty()==false)	cl_prop[i]  >>  enableSAHistoryOptionalData;
	else
	{
		//	Check default value for EnableSAHistoryOptionalData
		def_prop = get_default_class_property(cl_prop[i].name);
		if (def_prop.is_empty()==false)
		{
			def_prop    >>  enableSAHistoryOptionalData;
			cl_prop[i]  <<  enableSAHistoryOptionalData;
		}
	}
	//	Try to extract EnableADCOptionalData value
	if (cl_prop[++i].is_empty()==false)	cl_prop[i]  >>  enableADCOptionalData;
	else
	{
		//	Check default value for EnableADCOptionalData
		def_prop = get_default_class_property(cl_prop[i].name);
		if (def_prop.is_empty()==false)
		{
			def_prop    >>  enableADCOptionalData;
			cl_prop[i]  <<  enableADCOptionalData;
		}
	}
	//	Try to extract Institute value
	if (cl_prop[++i].is_empty()==false)	cl_prop[i]  >>  institute;
	else
	{
		//	Check default value for Institute
		def_prop = get_default_class_property(cl_prop[i].name);
		if (def_prop.is_empty()==false)
		{
			def_prop    >>  institute;
			cl_prop[i]  <<  institute;
		}
	}
	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::get_class_property_after) ENABLED START -----*/
	
	//	Check class property data members init
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::get_class_property_after

}

//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::set_default_property()
 *	Description : Set default property (class and device) for wizard.
 *                For each property, add to wizard property name and description.
 *                If default value has been set, add it to wizard property and
 *                store it in a DbDatum.
 */
//--------------------------------------------------------
void LiberaBrilliancePlusClass::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;
	vector<string>	vect_data;

	//	Set Default Class Properties
	prop_name = "InterlockConfiguration";
	prop_desc = "The user defined interlock configuration. This is the configuration that should be applied on the Libera in case the device `finds`\nthe Libera in its default startup configuration when it is itself starting up or executing its Init TANGO command. This configuration\ncan also be applied using the dedicated ``SetInterlockConfiguration`` expert command.\nParameters mapping:\n[0] Interlock : mode - [0]: disabled, [1]: enabled, [3]: enabled with gain dependency\n[1] Interlock : threshold : X low in mm\n[2] Interlock : threshold : X high in mm\n[3] Interlock : threshold : Z low in mm (i.e. Y low in the Libera terminology)\n[4] Interlock : threshold : Z high in mm (i.e. Y high in the Libera terminology)\n[5] Interlock : overflow limit (ADC threshold)\n[6] Interlock : overflow duration (num of overloaded ADC samples before raising intlck)\n[7] Interlock : gain limit in dBm  (intlck not active under this limit) - valid range is [-60, 0]";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		cl_def_prop.push_back(data);
		add_wiz_class_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_class_prop(prop_name, prop_desc);
	prop_name = "EnableDDOptionalData";
	prop_desc = "Enables/Disables  DD optional data (IxDD and QxDD)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		cl_def_prop.push_back(data);
		add_wiz_class_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_class_prop(prop_name, prop_desc);
	prop_name = "EnableSAOptionalData";
	prop_desc = "Enables/disables SA optional Data (currently not used)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		cl_def_prop.push_back(data);
		add_wiz_class_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_class_prop(prop_name, prop_desc);
	prop_name = "EnableSAHistoryOptionalData";
	prop_desc = "Enables/disables SA History optional data (sum history)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		cl_def_prop.push_back(data);
		add_wiz_class_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_class_prop(prop_name, prop_desc);
	prop_name = "EnableADCOptionalData";
	prop_desc = "Enables/disables ADC optional data (currently not used)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		cl_def_prop.push_back(data);
		add_wiz_class_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_class_prop(prop_name, prop_desc);
	prop_name = "Institute";
	prop_desc = "0: TANGO_INSTITUTE (GENERIC)\n1: ALBA\n2: ESRF\n3: ELETTRA\n4: SOLEIL";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		cl_def_prop.push_back(data);
		add_wiz_class_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_class_prop(prop_name, prop_desc);

	//	Set Default device Properties
	prop_name = "LiberaIpAddr";
	prop_desc = "The Libera IP address [no default value]";
	prop_def  = "127.0.0.1";
	vect_data.clear();
	vect_data.push_back("127.0.0.1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "LiberaPort";
	prop_desc = "The port on which the generic server handles external requests. Defaults to 23721.";
	prop_def  = "23271";
	vect_data.clear();
	vect_data.push_back("23271");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DefaultDDBufferSize";
	prop_desc = "Default [or initial] value for attribute DDBufferSize [in samples]. Defaults to 1024.";
	prop_def  = "1024";
	vect_data.clear();
	vect_data.push_back("1024");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Switches";
	prop_desc = "Switches configuration. The valid range is [0..15]. Defaults to 3.";
	prop_def  = "3";
	vect_data.clear();
	vect_data.push_back("3");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "LiberaMulticastIpAddr";
	prop_desc = "Asynch. notifications (e.g. trigger events) will be send to this addr [no default value]";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Location";
	prop_desc = "The BPM location [TL1, BOOSTER, TL2 or STORAGE_RING]. No default value.";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableExternalTrigger";
	prop_desc = "Enables (or not) the external trigger source.\nInlfuences the TANGO device behaviour not the Libera itself. Defaults to false.";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DDTaskActivityPeriod";
	prop_desc = "Specify the watch-dog (1) or data reading period (2) in ms.\nMust be in the rangec [500, 25000] ms. Defaults to 1000.\n(1) : external trigger enabled - (2) : external trigger disabled.";
	prop_def  = "1000";
	vect_data.clear();
	vect_data.push_back("1000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "SATaskActivityPeriod";
	prop_desc = "Specify the watch-dog (1) or data reading period (2) in ms.\nMust be in the range [100, 25000] ms. Defaults to 100.";
	prop_def  = "100";
	vect_data.clear();
	vect_data.push_back("100");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableDD";
	prop_desc = "Specifies whether or not the DD data source should be enabled at startup. Defaults to false.";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableSA";
	prop_desc = "Specifies whether or not the SA data source should be enabled at startup. Defaults to false.";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "SAHistoryLength";
	prop_desc = "SA history buffer length [in samples]. Defaults to 8196.";
	prop_def  = "512";
	vect_data.clear();
	vect_data.push_back("512");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DDDecimationFactor";
	prop_desc = "The DD decimation factor.\nAllowed values : 1 (no decimation) or 64 (for the so called booster normal mode)";
	prop_def  = "1";
	vect_data.clear();
	vect_data.push_back("1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableAutoSwitchingIfSAEnabled";
	prop_desc = "When set to TRUE, auto-switching is automattically enabled when the SA data source is itself enabled";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableDSCIfAutoSwitchingEnabled";
	prop_desc = "When set to TRUE, the Digital Signal Conditioning is automattically enabled when the auto-switching is itself enabled";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DefaultSAStatNumSamples";
	prop_desc = "Default number of SA history samples to use form RMS pos. computation.\nDefaults to 10 (last second in the SA history).";
	prop_def  = "256";
	vect_data.clear();
	vect_data.push_back("256");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DefaultADCBufferSize";
	prop_desc = "Default [or initial] value for attribute ADCBufferSize [in samples]. Defaults to 1024.";
	prop_def  = "1024";
	vect_data.clear();
	vect_data.push_back("1024");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ADCTaskActivityPeriod";
	prop_desc = "Specifies the data reading period in ms.\nMust be in the range [500, 25000] ms. Defaults to 1000.";
	prop_def  = "1000";
	vect_data.clear();
	vect_data.push_back("1000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableADC";
	prop_desc = "Specifies whether or not the ADC data source should be enabled at startup. Defaults to false.";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DefaultTimePhaseValue";
	prop_desc = "Default value for the machine time phase. Its valid range is [0, RfSfRatio - 1] where\nRfSfRatio is a machine dependent system property.";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "InterlockConfiguration";
	prop_desc = "The user defined interlock configuration. This is the configuration that should be applied on the Libera in case the device `finds`\nthe Libera in its default startup configuration when it is itself starting up or executing its Init TANGO command. This configuration\ncan also be applied using the dedicated `SetInterlockConfiguration` expert command.\nParameters mapping:\n[0] Interlock : mode - [0]: disabled, [1]: enabled, [3]: enabled with gain dependency\n[1] Interlock : threshold : X low in mm\n[2] Interlock : threshold : X high in mm\n[3] Interlock : threshold : Z low in mm (i.e. Y low in the Libera terminology)\n[4] Interlock : threshold : Z high in mm (i.e. Y high in the Libera terminology)\n[5] Interlock : overflow limit (ADC threshold)\n[6] Interlock : overflow duration (num of overloaded ADC samples before raising intlck)\n[7] Interlock : gain limit in dBm  (intlck not active under this limit) - valid range is [-60, 0]";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableDDOptionalData";
	prop_desc = "Enables/Disables  DD optional data (IxDD and QxDD)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableSAOptionalData";
	prop_desc = "Enables/disables SA optional Data (currently not used)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableSAHistoryOptionalData";
	prop_desc = "Enables/disables SA History optional data (sum history)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableADCOptionalData";
	prop_desc = "Enables/disables ADC optional data (currently not used)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Institute";
	prop_desc = "0: TANGO_INSTITUTE (GENERIC)\n1: ALBA\n2: ESRF\n3: ELETTRA\n4: SOLEIL";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "MaxDDBufferSizeWhenDecimationEnabled";
	prop_desc = "Max. DD buffer size when decimation enabled on DD data source.\nDefaults to 10000";
	prop_def  = "16384";
	vect_data.clear();
	vect_data.push_back("16384");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "PassBBAOffsetsToFPGA";
	prop_desc = "Controls wether or not the BBA offsets are taken into account when computing the offsets passed to the FPGA process";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "FADataCacheRefreshPeriod";
	prop_desc = "The <FA Data> cache refresh period in msecs.\nDefaults to 500 ms (2Hz).";
	prop_def  = "500";
	vect_data.clear();
	vect_data.push_back("500");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "LiberaBoard";
	prop_desc = "BPM board ID within the chassis [raf3,raf4,raf5 or raf6]";
	prop_def  = "raf5";
	vect_data.clear();
	vect_data.push_back("raf5");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
}

//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::write_class_property()
 *	Description : Set class description fields as property in database
 */
//--------------------------------------------------------
void LiberaBrilliancePlusClass::write_class_property()
{
	//	First time, check if database used
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("Libera BPM Device Server");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("IT Libera BPM Device Server.");
	str_desc.push_back("The interface should be the same as for the Brillance model.");
	description << str_desc;
	data.push_back(description);

	//	put cvs or svn location
	string	filename("LiberaBrilliancePlus");
	filename += "Class.cpp";

	// check for cvs information
	string	src_path(CvsPath);
	start = src_path.find("/");
	if (start!=string::npos)
	{
		end   = src_path.find(filename);
		if (end>start)
		{
			string	strloc = src_path.substr(start, end-start);
			//	Check if specific repository
			start = strloc.find("/cvsroot/");
			if (start!=string::npos && start>0)
			{
				string	repository = strloc.substr(0, start);
				if (repository.find("/segfs/")!=string::npos)
					strloc = "ESRF:" + strloc.substr(start, strloc.length()-start);
			}
			Tango::DbDatum	cvs_loc("cvs_location");
			cvs_loc << strloc;
			data.push_back(cvs_loc);
		}
	}

	// check for svn information
	else
	{
		string	src_path(SvnPath);
		start = src_path.find("://");
		if (start!=string::npos)
		{
			end = src_path.find(filename);
			if (end>start)
			{
				header = "$HeadURL: ";
				start = header.length();
				string	strloc = src_path.substr(start, (end-start));
				
				Tango::DbDatum	svn_loc("svn_location");
				svn_loc << strloc;
				data.push_back(svn_loc);
			}
		}
	}

	//	Get CVS or SVN revision tag
	
	// CVS tag
	string	tagname(TagName);
	header = "$Name: ";
	start = header.length();
	string	endstr(" $");
	
	end   = tagname.find(endstr);
	if (end!=string::npos && end>start)
	{
		string	strtag = tagname.substr(start, end-start);
		Tango::DbDatum	cvs_tag("cvs_tag");
		cvs_tag << strtag;
		data.push_back(cvs_tag);
	}
	
	// SVN tag
	string	svnpath(SvnPath);
	header = "$HeadURL: ";
	start = header.length();
	
	end   = svnpath.find(endstr);
	if (end!=string::npos && end>start)
	{
		string	strloc = svnpath.substr(start, end-start);
		
		string tagstr ("/tags/");
		start = strloc.find(tagstr);
		if ( start!=string::npos )
		{
			start = start + tagstr.length();
			end   = strloc.find(filename);
			string	strtag = strloc.substr(start, end-start-1);
			
			Tango::DbDatum	svn_tag("svn_tag");
			svn_tag << strtag;
			data.push_back(svn_tag);
		}
	}

	//	Get URL location
	string	httpServ(HttpServer);
	if (httpServ.length()>0)
	{
		Tango::DbDatum	db_doc_url("doc_url");
		db_doc_url << httpServ;
		data.push_back(db_doc_url);
	}

	//  Put inheritance
	Tango::DbDatum	inher_datum("InheritedFrom");
	vector<string> inheritance;
	inheritance.push_back("TANGO_BASE_CLASS");
	inher_datum << inheritance;
	data.push_back(inher_datum);

	//	Call database and and values
	get_db_class()->put_property(data);
}

//===================================================================
//	Factory methods
//===================================================================

//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::device_factory()
 *	Description : Create the device object(s)
 *                and store them in the device list
 */
//--------------------------------------------------------
void LiberaBrilliancePlusClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{
	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::device_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::device_factory_before

	//	Create devices and add it into the device list
	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
		device_list.push_back(new LiberaBrilliancePlus(this, (*devlist_ptr)[i]));							 
	}

	//	Manage dynamic attributes if any
	erase_dynamic_attributes(devlist_ptr, get_class_attr()->get_attr_list());

	//	Export devices to the outside world
	for (unsigned long i=1 ; i<=devlist_ptr->length() ; i++)
	{
		//	Add dynamic attributes if any
		LiberaBrilliancePlus *dev = static_cast<LiberaBrilliancePlus *>(device_list[device_list.size()-i]);
		dev->add_dynamic_attributes();

		//	Check before if database used.
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(dev);
		else
			export_device(dev, dev->get_name().c_str());
	}

	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::device_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::device_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::attribute_factory()
 *	Description : Create the attribute object(s)
 *                and store them in the attribute list
 */
//--------------------------------------------------------
void LiberaBrilliancePlusClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::attribute_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::attribute_factory_before
	//	Attribute : LiberaModel
	LiberaModelAttrib	*liberamodel = new LiberaModelAttrib();
	Tango::UserDefaultAttrProp	liberamodel_prop;
	liberamodel_prop.set_description("The Libera Model: 0:Electron, 1:Brillance, 2:Photon");
	liberamodel_prop.set_label("Libera Model");
	liberamodel_prop.set_unit("[0:e-, 1:br, 2:ph]");
	//	standard_unit	not set for LiberaModel
	//	display_unit	not set for LiberaModel
	liberamodel_prop.set_format("%d");
	//	max_value	not set for LiberaModel
	//	min_value	not set for LiberaModel
	//	max_alarm	not set for LiberaModel
	//	min_alarm	not set for LiberaModel
	//	max_warning	not set for LiberaModel
	//	min_warning	not set for LiberaModel
	//	delta_t	not set for LiberaModel
	//	delta_val	not set for LiberaModel
	
	liberamodel->set_default_properties(liberamodel_prop);
	//	Not Polled
	liberamodel->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(liberamodel);

	//	Attribute : DDEnabled
	DDEnabledAttrib	*ddenabled = new DDEnabledAttrib();
	Tango::UserDefaultAttrProp	ddenabled_prop;
	ddenabled_prop.set_description("DD data source activation flag");
	ddenabled_prop.set_label("DD Enabled");
	ddenabled_prop.set_unit("n/a");
	ddenabled_prop.set_standard_unit("n/a");
	ddenabled_prop.set_display_unit("n/a");
	//	format	not set for DDEnabled
	//	max_value	not set for DDEnabled
	//	min_value	not set for DDEnabled
	//	max_alarm	not set for DDEnabled
	//	min_alarm	not set for DDEnabled
	//	max_warning	not set for DDEnabled
	//	min_warning	not set for DDEnabled
	//	delta_t	not set for DDEnabled
	//	delta_val	not set for DDEnabled
	
	ddenabled->set_default_properties(ddenabled_prop);
	//	Not Polled
	ddenabled->set_disp_level(Tango::OPERATOR);
	ddenabled->set_memorized();
	ddenabled->set_memorized_init(true);
	att_list.push_back(ddenabled);

	//	Attribute : DDBufferSize
	DDBufferSizeAttrib	*ddbuffersize = new DDBufferSizeAttrib();
	Tango::UserDefaultAttrProp	ddbuffersize_prop;
	ddbuffersize_prop.set_description("The number of samples to be read on DD data source.\nInfluences the size of the associated attributes [such as XPosDD for instance].");
	ddbuffersize_prop.set_label("DD Buffer Size");
	ddbuffersize_prop.set_unit("turns");
	//	standard_unit	not set for DDBufferSize
	//	display_unit	not set for DDBufferSize
	ddbuffersize_prop.set_format("%5d");
	ddbuffersize_prop.set_max_value("65535");
	ddbuffersize_prop.set_min_value("2");
	//	max_alarm	not set for DDBufferSize
	//	min_alarm	not set for DDBufferSize
	//	max_warning	not set for DDBufferSize
	//	min_warning	not set for DDBufferSize
	//	delta_t	not set for DDBufferSize
	//	delta_val	not set for DDBufferSize
	
	ddbuffersize->set_default_properties(ddbuffersize_prop);
	//	Not Polled
	ddbuffersize->set_disp_level(Tango::OPERATOR);
	ddbuffersize->set_memorized();
	ddbuffersize->set_memorized_init(true);
	att_list.push_back(ddbuffersize);

	//	Attribute : DDDecimationFactor
	DDDecimationFactorAttrib	*dddecimationfactor = new DDDecimationFactorAttrib();
	Tango::UserDefaultAttrProp	dddecimationfactor_prop;
	dddecimationfactor_prop.set_description("The DD decimation factor");
	dddecimationfactor_prop.set_label("DD Decim. Factor");
	dddecimationfactor_prop.set_unit("samples");
	//	standard_unit	not set for DDDecimationFactor
	//	display_unit	not set for DDDecimationFactor
	dddecimationfactor_prop.set_format("%3d");
	dddecimationfactor_prop.set_max_value("256");
	dddecimationfactor_prop.set_min_value("1");
	//	max_alarm	not set for DDDecimationFactor
	//	min_alarm	not set for DDDecimationFactor
	//	max_warning	not set for DDDecimationFactor
	//	min_warning	not set for DDDecimationFactor
	//	delta_t	not set for DDDecimationFactor
	//	delta_val	not set for DDDecimationFactor
	
	dddecimationfactor->set_default_properties(dddecimationfactor_prop);
	//	Not Polled
	dddecimationfactor->set_disp_level(Tango::OPERATOR);
	dddecimationfactor->set_memorized();
	dddecimationfactor->set_memorized_init(true);
	att_list.push_back(dddecimationfactor);

	//	Attribute : DDTriggerOffset
	DDTriggerOffsetAttrib	*ddtriggeroffset = new DDTriggerOffsetAttrib();
	Tango::UserDefaultAttrProp	ddtriggeroffset_prop;
	ddtriggeroffset_prop.set_description("DD data offset in num. of turns");
	ddtriggeroffset_prop.set_label("DD Trigger Offset");
	ddtriggeroffset_prop.set_unit("turns");
	//	standard_unit	not set for DDTriggerOffset
	//	display_unit	not set for DDTriggerOffset
	ddtriggeroffset_prop.set_format("%6d");
	//	max_value	not set for DDTriggerOffset
	//	min_value	not set for DDTriggerOffset
	//	max_alarm	not set for DDTriggerOffset
	//	min_alarm	not set for DDTriggerOffset
	//	max_warning	not set for DDTriggerOffset
	//	min_warning	not set for DDTriggerOffset
	//	delta_t	not set for DDTriggerOffset
	//	delta_val	not set for DDTriggerOffset
	
	ddtriggeroffset->set_default_properties(ddtriggeroffset_prop);
	//	Not Polled
	ddtriggeroffset->set_disp_level(Tango::OPERATOR);
	ddtriggeroffset->set_memorized();
	ddtriggeroffset->set_memorized_init(true);
	att_list.push_back(ddtriggeroffset);

	//	Attribute : DDBufferFreezingEnabled
	DDBufferFreezingEnabledAttrib	*ddbufferfreezingenabled = new DDBufferFreezingEnabledAttrib();
	Tango::UserDefaultAttrProp	ddbufferfreezingenabled_prop;
	ddbufferfreezingenabled_prop.set_description("DD buffer freezing activation flag");
	ddbufferfreezingenabled_prop.set_label("DD Buffer Freezing Enabled");
	ddbufferfreezingenabled_prop.set_unit("n/a");
	ddbufferfreezingenabled_prop.set_standard_unit("n/a");
	ddbufferfreezingenabled_prop.set_display_unit("n/a");
	//	format	not set for DDBufferFreezingEnabled
	//	max_value	not set for DDBufferFreezingEnabled
	//	min_value	not set for DDBufferFreezingEnabled
	//	max_alarm	not set for DDBufferFreezingEnabled
	//	min_alarm	not set for DDBufferFreezingEnabled
	//	max_warning	not set for DDBufferFreezingEnabled
	//	min_warning	not set for DDBufferFreezingEnabled
	//	delta_t	not set for DDBufferFreezingEnabled
	//	delta_val	not set for DDBufferFreezingEnabled
	
	ddbufferfreezingenabled->set_default_properties(ddbufferfreezingenabled_prop);
	//	Not Polled
	ddbufferfreezingenabled->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ddbufferfreezingenabled);

	//	Attribute : DDBufferFrozen
	DDBufferFrozenAttrib	*ddbufferfrozen = new DDBufferFrozenAttrib();
	Tango::UserDefaultAttrProp	ddbufferfrozen_prop;
	ddbufferfrozen_prop.set_description("DD buffer status");
	ddbufferfrozen_prop.set_label("DD Buffer Frozen");
	ddbufferfrozen_prop.set_unit("n/a");
	ddbufferfrozen_prop.set_standard_unit("n/a");
	ddbufferfrozen_prop.set_display_unit("n/a");
	//	format	not set for DDBufferFrozen
	//	max_value	not set for DDBufferFrozen
	//	min_value	not set for DDBufferFrozen
	//	max_alarm	not set for DDBufferFrozen
	//	min_alarm	not set for DDBufferFrozen
	//	max_warning	not set for DDBufferFrozen
	//	min_warning	not set for DDBufferFrozen
	//	delta_t	not set for DDBufferFrozen
	//	delta_val	not set for DDBufferFrozen
	
	ddbufferfrozen->set_default_properties(ddbufferfrozen_prop);
	//	Not Polled
	ddbufferfrozen->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ddbufferfrozen);

	//	Attribute : DDTriggerCounter
	DDTriggerCounterAttrib	*ddtriggercounter = new DDTriggerCounterAttrib();
	Tango::UserDefaultAttrProp	ddtriggercounter_prop;
	ddtriggercounter_prop.set_description("Number of trigger notifications received since last device <init> ");
	ddtriggercounter_prop.set_label("Trig.Counter");
	ddtriggercounter_prop.set_unit("a.u.");
	ddtriggercounter_prop.set_standard_unit("a.u.");
	ddtriggercounter_prop.set_display_unit("a.u.");
	ddtriggercounter_prop.set_format("%8d");
	//	max_value	not set for DDTriggerCounter
	//	min_value	not set for DDTriggerCounter
	//	max_alarm	not set for DDTriggerCounter
	//	min_alarm	not set for DDTriggerCounter
	//	max_warning	not set for DDTriggerCounter
	//	min_warning	not set for DDTriggerCounter
	//	delta_t	not set for DDTriggerCounter
	//	delta_val	not set for DDTriggerCounter
	
	ddtriggercounter->set_default_properties(ddtriggercounter_prop);
	//	Not Polled
	ddtriggercounter->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ddtriggercounter);

	//	Attribute : ExternalTriggerEnabled
	ExternalTriggerEnabledAttrib	*externaltriggerenabled = new ExternalTriggerEnabledAttrib();
	Tango::UserDefaultAttrProp	externaltriggerenabled_prop;
	externaltriggerenabled_prop.set_description("External trigger activation flag");
	externaltriggerenabled_prop.set_label("Ext. Trig. Enabled");
	externaltriggerenabled_prop.set_unit("n/a");
	externaltriggerenabled_prop.set_standard_unit("n/a");
	externaltriggerenabled_prop.set_display_unit("n/a");
	//	format	not set for ExternalTriggerEnabled
	//	max_value	not set for ExternalTriggerEnabled
	//	min_value	not set for ExternalTriggerEnabled
	//	max_alarm	not set for ExternalTriggerEnabled
	//	min_alarm	not set for ExternalTriggerEnabled
	//	max_warning	not set for ExternalTriggerEnabled
	//	min_warning	not set for ExternalTriggerEnabled
	//	delta_t	not set for ExternalTriggerEnabled
	//	delta_val	not set for ExternalTriggerEnabled
	
	externaltriggerenabled->set_default_properties(externaltriggerenabled_prop);
	//	Not Polled
	externaltriggerenabled->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(externaltriggerenabled);

	//	Attribute : ExternalTriggerDelay
	ExternalTriggerDelayAttrib	*externaltriggerdelay = new ExternalTriggerDelayAttrib();
	Tango::UserDefaultAttrProp	externaltriggerdelay_prop;
	externaltriggerdelay_prop.set_description("Sets the delay on the external trigger arrival. \nThe delay is set in steps of ADC samples (~ 9 ns).");
	externaltriggerdelay_prop.set_label("External Trigger Delay");
	externaltriggerdelay_prop.set_unit("ADC samples");
	//	standard_unit	not set for ExternalTriggerDelay
	//	display_unit	not set for ExternalTriggerDelay
	externaltriggerdelay_prop.set_format("%6d");
	//	max_value	not set for ExternalTriggerDelay
	externaltriggerdelay_prop.set_min_value("0");
	//	max_alarm	not set for ExternalTriggerDelay
	//	min_alarm	not set for ExternalTriggerDelay
	//	max_warning	not set for ExternalTriggerDelay
	//	min_warning	not set for ExternalTriggerDelay
	//	delta_t	not set for ExternalTriggerDelay
	//	delta_val	not set for ExternalTriggerDelay
	
	externaltriggerdelay->set_default_properties(externaltriggerdelay_prop);
	//	Not Polled
	externaltriggerdelay->set_disp_level(Tango::OPERATOR);
	externaltriggerdelay->set_memorized();
	externaltriggerdelay->set_memorized_init(true);
	att_list.push_back(externaltriggerdelay);

	//	Attribute : SAEnabled
	SAEnabledAttrib	*saenabled = new SAEnabledAttrib();
	Tango::UserDefaultAttrProp	saenabled_prop;
	saenabled_prop.set_description("SA data source activation flag");
	saenabled_prop.set_label("SA Enabled");
	saenabled_prop.set_unit("n/a");
	saenabled_prop.set_standard_unit("n/a");
	saenabled_prop.set_display_unit("n/a");
	//	format	not set for SAEnabled
	//	max_value	not set for SAEnabled
	//	min_value	not set for SAEnabled
	//	max_alarm	not set for SAEnabled
	//	min_alarm	not set for SAEnabled
	//	max_warning	not set for SAEnabled
	//	min_warning	not set for SAEnabled
	//	delta_t	not set for SAEnabled
	//	delta_val	not set for SAEnabled
	
	saenabled->set_default_properties(saenabled_prop);
	//	Not Polled
	saenabled->set_disp_level(Tango::OPERATOR);
	saenabled->set_memorized();
	saenabled->set_memorized_init(true);
	att_list.push_back(saenabled);

	//	Attribute : VaSA
	VaSAAttrib	*vasa = new VaSAAttrib();
	Tango::UserDefaultAttrProp	vasa_prop;
	vasa_prop.set_description("Slow Acquisition: Va");
	vasa_prop.set_label("SA Va");
	vasa_prop.set_unit("a.u.");
	vasa_prop.set_standard_unit("a.u.");
	vasa_prop.set_display_unit("a.u.");
	vasa_prop.set_format("%10.0f");
	//	max_value	not set for VaSA
	//	min_value	not set for VaSA
	//	max_alarm	not set for VaSA
	//	min_alarm	not set for VaSA
	//	max_warning	not set for VaSA
	//	min_warning	not set for VaSA
	//	delta_t	not set for VaSA
	//	delta_val	not set for VaSA
	
	vasa->set_default_properties(vasa_prop);
	//	Not Polled
	vasa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vasa);

	//	Attribute : VbSA
	VbSAAttrib	*vbsa = new VbSAAttrib();
	Tango::UserDefaultAttrProp	vbsa_prop;
	vbsa_prop.set_description("Slow Acquisition: Vb");
	vbsa_prop.set_label("SA Vb");
	vbsa_prop.set_unit("a.u.");
	vbsa_prop.set_standard_unit("a.u.");
	vbsa_prop.set_display_unit("a.u.");
	vbsa_prop.set_format("%10.0f");
	//	max_value	not set for VbSA
	//	min_value	not set for VbSA
	//	max_alarm	not set for VbSA
	//	min_alarm	not set for VbSA
	//	max_warning	not set for VbSA
	//	min_warning	not set for VbSA
	//	delta_t	not set for VbSA
	//	delta_val	not set for VbSA
	
	vbsa->set_default_properties(vbsa_prop);
	//	Not Polled
	vbsa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vbsa);

	//	Attribute : VcSA
	VcSAAttrib	*vcsa = new VcSAAttrib();
	Tango::UserDefaultAttrProp	vcsa_prop;
	vcsa_prop.set_description("Slow Acquisition: Vc");
	vcsa_prop.set_label("SA Vc");
	vcsa_prop.set_unit("a.u.");
	vcsa_prop.set_standard_unit("a.u.");
	vcsa_prop.set_display_unit("a.u.");
	vcsa_prop.set_format("%10.0f");
	//	max_value	not set for VcSA
	//	min_value	not set for VcSA
	//	max_alarm	not set for VcSA
	//	min_alarm	not set for VcSA
	//	max_warning	not set for VcSA
	//	min_warning	not set for VcSA
	//	delta_t	not set for VcSA
	//	delta_val	not set for VcSA
	
	vcsa->set_default_properties(vcsa_prop);
	//	Not Polled
	vcsa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vcsa);

	//	Attribute : VdSA
	VdSAAttrib	*vdsa = new VdSAAttrib();
	Tango::UserDefaultAttrProp	vdsa_prop;
	vdsa_prop.set_description("Slow Acquisition: Vd");
	vdsa_prop.set_label("SA Vd");
	vdsa_prop.set_unit("a.u.");
	vdsa_prop.set_standard_unit("a.u.");
	vdsa_prop.set_display_unit("a.u.");
	vdsa_prop.set_format("%10.0f");
	//	max_value	not set for VdSA
	//	min_value	not set for VdSA
	//	max_alarm	not set for VdSA
	//	min_alarm	not set for VdSA
	//	max_warning	not set for VdSA
	//	min_warning	not set for VdSA
	//	delta_t	not set for VdSA
	//	delta_val	not set for VdSA
	
	vdsa->set_default_properties(vdsa_prop);
	//	Not Polled
	vdsa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vdsa);

	//	Attribute : XPosSA
	XPosSAAttrib	*xpossa = new XPosSAAttrib();
	Tango::UserDefaultAttrProp	xpossa_prop;
	xpossa_prop.set_description("Slow Acquisition: X");
	xpossa_prop.set_label("X.Pos.SA");
	xpossa_prop.set_unit("mm");
	//	standard_unit	not set for XPosSA
	//	display_unit	not set for XPosSA
	xpossa_prop.set_format("%8.2f");
	//	max_value	not set for XPosSA
	//	min_value	not set for XPosSA
	//	max_alarm	not set for XPosSA
	//	min_alarm	not set for XPosSA
	//	max_warning	not set for XPosSA
	//	min_warning	not set for XPosSA
	//	delta_t	not set for XPosSA
	//	delta_val	not set for XPosSA
	
	xpossa->set_default_properties(xpossa_prop);
	//	Not Polled
	xpossa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xpossa);

	//	Attribute : YPosSA
	YPosSAAttrib	*ypossa = new YPosSAAttrib();
	Tango::UserDefaultAttrProp	ypossa_prop;
	ypossa_prop.set_description("Slow Acquisition: Y");
	ypossa_prop.set_label("Y.Pos.SA");
	ypossa_prop.set_unit("mm");
	//	standard_unit	not set for YPosSA
	//	display_unit	not set for YPosSA
	ypossa_prop.set_format("%8.2f");
	//	max_value	not set for YPosSA
	//	min_value	not set for YPosSA
	//	max_alarm	not set for YPosSA
	//	min_alarm	not set for YPosSA
	//	max_warning	not set for YPosSA
	//	min_warning	not set for YPosSA
	//	delta_t	not set for YPosSA
	//	delta_val	not set for YPosSA
	
	ypossa->set_default_properties(ypossa_prop);
	//	Not Polled
	ypossa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ypossa);

	//	Attribute : SumSA
	SumSAAttrib	*sumsa = new SumSAAttrib();
	Tango::UserDefaultAttrProp	sumsa_prop;
	sumsa_prop.set_description("Slow Acquisition: Sum");
	sumsa_prop.set_label("Sum SA");
	sumsa_prop.set_unit("a.u.");
	//	standard_unit	not set for SumSA
	//	display_unit	not set for SumSA
	sumsa_prop.set_format("%10.0f");
	//	max_value	not set for SumSA
	//	min_value	not set for SumSA
	//	max_alarm	not set for SumSA
	//	min_alarm	not set for SumSA
	//	max_warning	not set for SumSA
	//	min_warning	not set for SumSA
	//	delta_t	not set for SumSA
	//	delta_val	not set for SumSA
	
	sumsa->set_default_properties(sumsa_prop);
	//	Not Polled
	sumsa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(sumsa);

	//	Attribute : QuadSA
	QuadSAAttrib	*quadsa = new QuadSAAttrib();
	Tango::UserDefaultAttrProp	quadsa_prop;
	quadsa_prop.set_description("Slow Acquisition: Quad");
	quadsa_prop.set_label("Quad SA");
	quadsa_prop.set_unit("a.u.");
	//	standard_unit	not set for QuadSA
	//	display_unit	not set for QuadSA
	quadsa_prop.set_format("%8.4f");
	//	max_value	not set for QuadSA
	//	min_value	not set for QuadSA
	//	max_alarm	not set for QuadSA
	//	min_alarm	not set for QuadSA
	//	max_warning	not set for QuadSA
	//	min_warning	not set for QuadSA
	//	delta_t	not set for QuadSA
	//	delta_val	not set for QuadSA
	
	quadsa->set_default_properties(quadsa_prop);
	//	Not Polled
	quadsa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(quadsa);

	//	Attribute : CxSA
	CxSAAttrib	*cxsa = new CxSAAttrib();
	Tango::UserDefaultAttrProp	cxsa_prop;
	cxsa_prop.set_description("FOFB X correction sent to the power supply");
	cxsa_prop.set_label("FOFB X Correction");
	cxsa_prop.set_unit("a.u.");
	//	standard_unit	not set for CxSA
	//	display_unit	not set for CxSA
	cxsa_prop.set_format("%8d");
	//	max_value	not set for CxSA
	//	min_value	not set for CxSA
	//	max_alarm	not set for CxSA
	//	min_alarm	not set for CxSA
	//	max_warning	not set for CxSA
	//	min_warning	not set for CxSA
	//	delta_t	not set for CxSA
	//	delta_val	not set for CxSA
	
	cxsa->set_default_properties(cxsa_prop);
	//	Not Polled
	cxsa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(cxsa);

	//	Attribute : CySA
	CySAAttrib	*cysa = new CySAAttrib();
	Tango::UserDefaultAttrProp	cysa_prop;
	cysa_prop.set_description("FOFB Y correction sent to the power supply");
	cysa_prop.set_label("FOFB Y Correction");
	cysa_prop.set_unit("a.u.");
	//	standard_unit	not set for CySA
	//	display_unit	not set for CySA
	cysa_prop.set_format("%8d");
	//	max_value	not set for CySA
	//	min_value	not set for CySA
	//	max_alarm	not set for CySA
	//	min_alarm	not set for CySA
	//	max_warning	not set for CySA
	//	min_warning	not set for CySA
	//	delta_t	not set for CySA
	//	delta_val	not set for CySA
	
	cysa->set_default_properties(cysa_prop);
	//	Not Polled
	cysa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(cysa);

	//	Attribute : SAStatNumSamples
	SAStatNumSamplesAttrib	*sastatnumsamples = new SAStatNumSamplesAttrib();
	Tango::UserDefaultAttrProp	sastatnumsamples_prop;
	sastatnumsamples_prop.set_description("The number of sample in SA history used to compute the SA statistics\n(Mean, RMS, Peak pos). The most recent samples will be used.\nThe valid range is [2, SAHistoryLength property value].\n");
	sastatnumsamples_prop.set_label("SA Stats.Num.Samples.");
	sastatnumsamples_prop.set_unit("samples");
	//	standard_unit	not set for SAStatNumSamples
	//	display_unit	not set for SAStatNumSamples
	sastatnumsamples_prop.set_format("%5d");
	//	max_value	not set for SAStatNumSamples
	//	min_value	not set for SAStatNumSamples
	//	max_alarm	not set for SAStatNumSamples
	//	min_alarm	not set for SAStatNumSamples
	//	max_warning	not set for SAStatNumSamples
	//	min_warning	not set for SAStatNumSamples
	//	delta_t	not set for SAStatNumSamples
	//	delta_val	not set for SAStatNumSamples
	
	sastatnumsamples->set_default_properties(sastatnumsamples_prop);
	//	Not Polled
	sastatnumsamples->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(sastatnumsamples);

	//	Attribute : XMeanPosSA
	XMeanPosSAAttrib	*xmeanpossa = new XMeanPosSAAttrib();
	Tango::UserDefaultAttrProp	xmeanpossa_prop;
	xmeanpossa_prop.set_description("Slow Acquisition:  arithmetic average from history values");
	xmeanpossa_prop.set_label("SA X Mean Pos.");
	xmeanpossa_prop.set_unit("mm");
	//	standard_unit	not set for XMeanPosSA
	//	display_unit	not set for XMeanPosSA
	xmeanpossa_prop.set_format("%8.4f");
	//	max_value	not set for XMeanPosSA
	//	min_value	not set for XMeanPosSA
	//	max_alarm	not set for XMeanPosSA
	//	min_alarm	not set for XMeanPosSA
	//	max_warning	not set for XMeanPosSA
	//	min_warning	not set for XMeanPosSA
	//	delta_t	not set for XMeanPosSA
	//	delta_val	not set for XMeanPosSA
	
	xmeanpossa->set_default_properties(xmeanpossa_prop);
	//	Not Polled
	xmeanpossa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xmeanpossa);

	//	Attribute : YMeanPosSA
	YMeanPosSAAttrib	*ymeanpossa = new YMeanPosSAAttrib();
	Tango::UserDefaultAttrProp	ymeanpossa_prop;
	ymeanpossa_prop.set_description("Slow Acquisition:  arithmetic average from history values");
	ymeanpossa_prop.set_label("SA Y Mean Pos.");
	ymeanpossa_prop.set_unit("mm");
	//	standard_unit	not set for YMeanPosSA
	//	display_unit	not set for YMeanPosSA
	ymeanpossa_prop.set_format("%8.4f");
	//	max_value	not set for YMeanPosSA
	//	min_value	not set for YMeanPosSA
	//	max_alarm	not set for YMeanPosSA
	//	min_alarm	not set for YMeanPosSA
	//	max_warning	not set for YMeanPosSA
	//	min_warning	not set for YMeanPosSA
	//	delta_t	not set for YMeanPosSA
	//	delta_val	not set for YMeanPosSA
	
	ymeanpossa->set_default_properties(ymeanpossa_prop);
	//	Not Polled
	ymeanpossa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ymeanpossa);

	//	Attribute : XRMSPosSA
	XRMSPosSAAttrib	*xrmspossa = new XRMSPosSAAttrib();
	Tango::UserDefaultAttrProp	xrmspossa_prop;
	xrmspossa_prop.set_description("Slow Acquisition:  X root mean square from histry samples sqrt(Xi^2-mean^2)/N^2");
	xrmspossa_prop.set_label("SA X RMS Pos.");
	xrmspossa_prop.set_unit("um");
	//	standard_unit	not set for XRMSPosSA
	//	display_unit	not set for XRMSPosSA
	xrmspossa_prop.set_format("%8.2f");
	//	max_value	not set for XRMSPosSA
	//	min_value	not set for XRMSPosSA
	//	max_alarm	not set for XRMSPosSA
	//	min_alarm	not set for XRMSPosSA
	//	max_warning	not set for XRMSPosSA
	//	min_warning	not set for XRMSPosSA
	//	delta_t	not set for XRMSPosSA
	//	delta_val	not set for XRMSPosSA
	
	xrmspossa->set_default_properties(xrmspossa_prop);
	//	Not Polled
	xrmspossa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xrmspossa);

	//	Attribute : YRMSPosSA
	YRMSPosSAAttrib	*yrmspossa = new YRMSPosSAAttrib();
	Tango::UserDefaultAttrProp	yrmspossa_prop;
	yrmspossa_prop.set_description("Slow Acquisition: Y root mean square from histry samples sqrt(Xi^2-mean^2)/N^2.");
	yrmspossa_prop.set_label("SA Y RMS Pos.");
	yrmspossa_prop.set_unit("um");
	//	standard_unit	not set for YRMSPosSA
	//	display_unit	not set for YRMSPosSA
	yrmspossa_prop.set_format("%8.2f");
	//	max_value	not set for YRMSPosSA
	//	min_value	not set for YRMSPosSA
	//	max_alarm	not set for YRMSPosSA
	//	min_alarm	not set for YRMSPosSA
	//	max_warning	not set for YRMSPosSA
	//	min_warning	not set for YRMSPosSA
	//	delta_t	not set for YRMSPosSA
	//	delta_val	not set for YRMSPosSA
	
	yrmspossa->set_default_properties(yrmspossa_prop);
	//	Not Polled
	yrmspossa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(yrmspossa);

	//	Attribute : XPeakPosSA
	XPeakPosSAAttrib	*xpeakpossa = new XPeakPosSAAttrib();
	Tango::UserDefaultAttrProp	xpeakpossa_prop;
	xpeakpossa_prop.set_description("Slow Acquisition: X difference between max and min value from history");
	xpeakpossa_prop.set_label("X.Peak.Pos.SA");
	xpeakpossa_prop.set_unit("um");
	//	standard_unit	not set for XPeakPosSA
	//	display_unit	not set for XPeakPosSA
	xpeakpossa_prop.set_format("%8.2f");
	//	max_value	not set for XPeakPosSA
	//	min_value	not set for XPeakPosSA
	//	max_alarm	not set for XPeakPosSA
	//	min_alarm	not set for XPeakPosSA
	//	max_warning	not set for XPeakPosSA
	//	min_warning	not set for XPeakPosSA
	//	delta_t	not set for XPeakPosSA
	//	delta_val	not set for XPeakPosSA
	
	xpeakpossa->set_default_properties(xpeakpossa_prop);
	//	Not Polled
	xpeakpossa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xpeakpossa);

	//	Attribute : YPeakPosSA
	YPeakPosSAAttrib	*ypeakpossa = new YPeakPosSAAttrib();
	Tango::UserDefaultAttrProp	ypeakpossa_prop;
	ypeakpossa_prop.set_description("Slow Acquisition: Y difference between max and min value from history");
	ypeakpossa_prop.set_label("Y.Peak.Pos.SA");
	ypeakpossa_prop.set_unit("um");
	//	standard_unit	not set for YPeakPosSA
	//	display_unit	not set for YPeakPosSA
	ypeakpossa_prop.set_format("%8.2f");
	//	max_value	not set for YPeakPosSA
	//	min_value	not set for YPeakPosSA
	//	max_alarm	not set for YPeakPosSA
	//	min_alarm	not set for YPeakPosSA
	//	max_warning	not set for YPeakPosSA
	//	min_warning	not set for YPeakPosSA
	//	delta_t	not set for YPeakPosSA
	//	delta_val	not set for YPeakPosSA
	
	ypeakpossa->set_default_properties(ypeakpossa_prop);
	//	Not Polled
	ypeakpossa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ypeakpossa);

	//	Attribute : SumMeanSA
	SumMeanSAAttrib	*summeansa = new SumMeanSAAttrib();
	Tango::UserDefaultAttrProp	summeansa_prop;
	summeansa_prop.set_description("SA: mean of sum");
	summeansa_prop.set_label("SA Sum Mean");
	summeansa_prop.set_unit("a.u.");
	summeansa_prop.set_standard_unit("a.u.");
	summeansa_prop.set_display_unit("a.u.");
	summeansa_prop.set_format("%8.1f");
	//	max_value	not set for SumMeanSA
	//	min_value	not set for SumMeanSA
	//	max_alarm	not set for SumMeanSA
	//	min_alarm	not set for SumMeanSA
	//	max_warning	not set for SumMeanSA
	//	min_warning	not set for SumMeanSA
	//	delta_t	not set for SumMeanSA
	//	delta_val	not set for SumMeanSA
	
	summeansa->set_default_properties(summeansa_prop);
	//	Not Polled
	summeansa->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(summeansa);

	//	Attribute : ADCEnabled
	ADCEnabledAttrib	*adcenabled = new ADCEnabledAttrib();
	Tango::UserDefaultAttrProp	adcenabled_prop;
	adcenabled_prop.set_description("ADC data source activation flag");
	adcenabled_prop.set_label("ADC Enabled");
	adcenabled_prop.set_unit("n/a");
	adcenabled_prop.set_standard_unit("n/a");
	adcenabled_prop.set_display_unit("n/a");
	//	format	not set for ADCEnabled
	//	max_value	not set for ADCEnabled
	//	min_value	not set for ADCEnabled
	//	max_alarm	not set for ADCEnabled
	//	min_alarm	not set for ADCEnabled
	//	max_warning	not set for ADCEnabled
	//	min_warning	not set for ADCEnabled
	//	delta_t	not set for ADCEnabled
	//	delta_val	not set for ADCEnabled
	
	adcenabled->set_default_properties(adcenabled_prop);
	//	Not Polled
	adcenabled->set_disp_level(Tango::OPERATOR);
	adcenabled->set_memorized();
	adcenabled->set_memorized_init(true);
	att_list.push_back(adcenabled);

	//	Attribute : ADCBufferSize
	ADCBufferSizeAttrib	*adcbuffersize = new ADCBufferSizeAttrib();
	Tango::UserDefaultAttrProp	adcbuffersize_prop;
	adcbuffersize_prop.set_description("The number of samples to be read on ADC data source.\nInfluences the size of the associated attributes [such as ADCChannelA for instance].");
	adcbuffersize_prop.set_label("ADC Buffer Size");
	adcbuffersize_prop.set_unit("samples");
	//	standard_unit	not set for ADCBufferSize
	//	display_unit	not set for ADCBufferSize
	adcbuffersize_prop.set_format("%5d");
	adcbuffersize_prop.set_max_value("65535");
	adcbuffersize_prop.set_min_value("8");
	//	max_alarm	not set for ADCBufferSize
	//	min_alarm	not set for ADCBufferSize
	//	max_warning	not set for ADCBufferSize
	//	min_warning	not set for ADCBufferSize
	//	delta_t	not set for ADCBufferSize
	//	delta_val	not set for ADCBufferSize
	
	adcbuffersize->set_default_properties(adcbuffersize_prop);
	//	Not Polled
	adcbuffersize->set_disp_level(Tango::OPERATOR);
	adcbuffersize->set_memorized();
	adcbuffersize->set_memorized_init(true);
	att_list.push_back(adcbuffersize);

	//	Attribute : PMOffset
	PMOffsetAttrib	*pmoffset = new PMOffsetAttrib();
	Tango::UserDefaultAttrProp	pmoffset_prop;
	pmoffset_prop.set_description("Offset relative to the post mortem event setting. \nSet value is in turns, e.g. 1024 would mean that post mortem \nacquisition is starting 1024 turns after the post mortem trigger \nwas received.");
	pmoffset_prop.set_label("Post Mortem Offset");
	pmoffset_prop.set_unit("samples");
	//	standard_unit	not set for PMOffset
	//	display_unit	not set for PMOffset
	pmoffset_prop.set_format("%3d");
	pmoffset_prop.set_max_value("10000");
	pmoffset_prop.set_min_value("-10000");
	//	max_alarm	not set for PMOffset
	//	min_alarm	not set for PMOffset
	//	max_warning	not set for PMOffset
	//	min_warning	not set for PMOffset
	//	delta_t	not set for PMOffset
	//	delta_val	not set for PMOffset
	
	pmoffset->set_default_properties(pmoffset_prop);
	//	Not Polled
	pmoffset->set_disp_level(Tango::OPERATOR);
	pmoffset->set_memorized();
	pmoffset->set_memorized_init(true);
	att_list.push_back(pmoffset);

	//	Attribute : PMNotified
	PMNotifiedAttrib	*pmnotified = new PMNotifiedAttrib();
	Tango::UserDefaultAttrProp	pmnotified_prop;
	pmnotified_prop.set_description("Post Moterm notification flag");
	pmnotified_prop.set_label("Post Moterm Notified");
	pmnotified_prop.set_unit("n/a");
	//	standard_unit	not set for PMNotified
	//	display_unit	not set for PMNotified
	//	format	not set for PMNotified
	//	max_value	not set for PMNotified
	//	min_value	not set for PMNotified
	//	max_alarm	not set for PMNotified
	//	min_alarm	not set for PMNotified
	//	max_warning	not set for PMNotified
	//	min_warning	not set for PMNotified
	//	delta_t	not set for PMNotified
	//	delta_val	not set for PMNotified
	
	pmnotified->set_default_properties(pmnotified_prop);
	//	Not Polled
	pmnotified->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(pmnotified);

	//	Attribute : PMNotificationCounter
	PMNotificationCounterAttrib	*pmnotificationcounter = new PMNotificationCounterAttrib();
	Tango::UserDefaultAttrProp	pmnotificationcounter_prop;
	pmnotificationcounter_prop.set_description("Number a PM event recieved since last Init");
	pmnotificationcounter_prop.set_label("PM Notif. Counter");
	//	unit	not set for PMNotificationCounter
	//	standard_unit	not set for PMNotificationCounter
	//	display_unit	not set for PMNotificationCounter
	pmnotificationcounter_prop.set_format("%8d");
	//	max_value	not set for PMNotificationCounter
	//	min_value	not set for PMNotificationCounter
	//	max_alarm	not set for PMNotificationCounter
	//	min_alarm	not set for PMNotificationCounter
	//	max_warning	not set for PMNotificationCounter
	//	min_warning	not set for PMNotificationCounter
	//	delta_t	not set for PMNotificationCounter
	//	delta_val	not set for PMNotificationCounter
	
	pmnotificationcounter->set_default_properties(pmnotificationcounter_prop);
	//	Not Polled
	pmnotificationcounter->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(pmnotificationcounter);

	//	Attribute : InterlockXNotified
	InterlockXNotifiedAttrib	*interlockxnotified = new InterlockXNotifiedAttrib();
	Tango::UserDefaultAttrProp	interlockxnotified_prop;
	interlockxnotified_prop.set_description("Sets to 1 if X position trip caused the Interlock event.");
	//	label	not set for InterlockXNotified
	//	unit	not set for InterlockXNotified
	//	standard_unit	not set for InterlockXNotified
	//	display_unit	not set for InterlockXNotified
	//	format	not set for InterlockXNotified
	//	max_value	not set for InterlockXNotified
	//	min_value	not set for InterlockXNotified
	//	max_alarm	not set for InterlockXNotified
	//	min_alarm	not set for InterlockXNotified
	//	max_warning	not set for InterlockXNotified
	//	min_warning	not set for InterlockXNotified
	//	delta_t	not set for InterlockXNotified
	//	delta_val	not set for InterlockXNotified
	
	interlockxnotified->set_default_properties(interlockxnotified_prop);
	//	Not Polled
	interlockxnotified->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(interlockxnotified);

	//	Attribute : InterlockYNotified
	InterlockYNotifiedAttrib	*interlockynotified = new InterlockYNotifiedAttrib();
	Tango::UserDefaultAttrProp	interlockynotified_prop;
	interlockynotified_prop.set_description("Sets to 1 if Yposition trip caused the Interlock event.");
	//	label	not set for InterlockYNotified
	//	unit	not set for InterlockYNotified
	//	standard_unit	not set for InterlockYNotified
	//	display_unit	not set for InterlockYNotified
	//	format	not set for InterlockYNotified
	//	max_value	not set for InterlockYNotified
	//	min_value	not set for InterlockYNotified
	//	max_alarm	not set for InterlockYNotified
	//	min_alarm	not set for InterlockYNotified
	//	max_warning	not set for InterlockYNotified
	//	min_warning	not set for InterlockYNotified
	//	delta_t	not set for InterlockYNotified
	//	delta_val	not set for InterlockYNotified
	
	interlockynotified->set_default_properties(interlockynotified_prop);
	//	Not Polled
	interlockynotified->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(interlockynotified);

	//	Attribute : InterlockAttnNotified
	InterlockAttnNotifiedAttrib	*interlockattnnotified = new InterlockAttnNotifiedAttrib();
	Tango::UserDefaultAttrProp	interlockattnnotified_prop;
	interlockattnnotified_prop.set_description("Sets to 1 if the attenuator's value is higher than gain \ndependence threshold");
	//	label	not set for InterlockAttnNotified
	//	unit	not set for InterlockAttnNotified
	//	standard_unit	not set for InterlockAttnNotified
	//	display_unit	not set for InterlockAttnNotified
	//	format	not set for InterlockAttnNotified
	//	max_value	not set for InterlockAttnNotified
	//	min_value	not set for InterlockAttnNotified
	//	max_alarm	not set for InterlockAttnNotified
	//	min_alarm	not set for InterlockAttnNotified
	//	max_warning	not set for InterlockAttnNotified
	//	min_warning	not set for InterlockAttnNotified
	//	delta_t	not set for InterlockAttnNotified
	//	delta_val	not set for InterlockAttnNotified
	
	interlockattnnotified->set_default_properties(interlockattnnotified_prop);
	//	Not Polled
	interlockattnnotified->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(interlockattnnotified);

	//	Attribute : InterlockADCPreFilterNotified
	InterlockADCPreFilterNotifiedAttrib	*interlockadcprefilternotified = new InterlockADCPreFilterNotifiedAttrib();
	Tango::UserDefaultAttrProp	interlockadcprefilternotified_prop;
	interlockadcprefilternotified_prop.set_description("ADC overflow without filtering.");
	//	label	not set for InterlockADCPreFilterNotified
	//	unit	not set for InterlockADCPreFilterNotified
	//	standard_unit	not set for InterlockADCPreFilterNotified
	//	display_unit	not set for InterlockADCPreFilterNotified
	//	format	not set for InterlockADCPreFilterNotified
	//	max_value	not set for InterlockADCPreFilterNotified
	//	min_value	not set for InterlockADCPreFilterNotified
	//	max_alarm	not set for InterlockADCPreFilterNotified
	//	min_alarm	not set for InterlockADCPreFilterNotified
	//	max_warning	not set for InterlockADCPreFilterNotified
	//	min_warning	not set for InterlockADCPreFilterNotified
	//	delta_t	not set for InterlockADCPreFilterNotified
	//	delta_val	not set for InterlockADCPreFilterNotified
	
	interlockadcprefilternotified->set_default_properties(interlockadcprefilternotified_prop);
	//	Not Polled
	interlockadcprefilternotified->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(interlockadcprefilternotified);

	//	Attribute : InterlockADCPostFilterNotified
	InterlockADCPostFilterNotifiedAttrib	*interlockadcpostfilternotified = new InterlockADCPostFilterNotifiedAttrib();
	Tango::UserDefaultAttrProp	interlockadcpostfilternotified_prop;
	interlockadcpostfilternotified_prop.set_description("ADC overflow with filtering.");
	//	label	not set for InterlockADCPostFilterNotified
	//	unit	not set for InterlockADCPostFilterNotified
	//	standard_unit	not set for InterlockADCPostFilterNotified
	//	display_unit	not set for InterlockADCPostFilterNotified
	//	format	not set for InterlockADCPostFilterNotified
	//	max_value	not set for InterlockADCPostFilterNotified
	//	min_value	not set for InterlockADCPostFilterNotified
	//	max_alarm	not set for InterlockADCPostFilterNotified
	//	min_alarm	not set for InterlockADCPostFilterNotified
	//	max_warning	not set for InterlockADCPostFilterNotified
	//	min_warning	not set for InterlockADCPostFilterNotified
	//	delta_t	not set for InterlockADCPostFilterNotified
	//	delta_val	not set for InterlockADCPostFilterNotified
	
	interlockadcpostfilternotified->set_default_properties(interlockadcpostfilternotified_prop);
	//	Not Polled
	interlockadcpostfilternotified->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(interlockadcpostfilternotified);

	//	Attribute : XLow
	XLowAttrib	*xlow = new XLowAttrib();
	Tango::UserDefaultAttrProp	xlow_prop;
	xlow_prop.set_description("Lower limit of the X position interlock threshold in mm");
	xlow_prop.set_label("X Low Int. Thres.");
	xlow_prop.set_unit("mm");
	//	standard_unit	not set for XLow
	//	display_unit	not set for XLow
	xlow_prop.set_format("%8.4f");
	//	max_value	not set for XLow
	//	min_value	not set for XLow
	//	max_alarm	not set for XLow
	//	min_alarm	not set for XLow
	//	max_warning	not set for XLow
	//	min_warning	not set for XLow
	//	delta_t	not set for XLow
	//	delta_val	not set for XLow
	
	xlow->set_default_properties(xlow_prop);
	//	Not Polled
	xlow->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xlow);

	//	Attribute : XHigh
	XHighAttrib	*xhigh = new XHighAttrib();
	Tango::UserDefaultAttrProp	xhigh_prop;
	xhigh_prop.set_description("Upper limit of the X position interlock threshold in mm");
	xhigh_prop.set_label("X High Int. Thres.");
	xhigh_prop.set_unit("mm");
	//	standard_unit	not set for XHigh
	//	display_unit	not set for XHigh
	xhigh_prop.set_format("%8.4f");
	//	max_value	not set for XHigh
	//	min_value	not set for XHigh
	//	max_alarm	not set for XHigh
	//	min_alarm	not set for XHigh
	//	max_warning	not set for XHigh
	//	min_warning	not set for XHigh
	//	delta_t	not set for XHigh
	//	delta_val	not set for XHigh
	
	xhigh->set_default_properties(xhigh_prop);
	//	Not Polled
	xhigh->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xhigh);

	//	Attribute : YLow
	YLowAttrib	*ylow = new YLowAttrib();
	Tango::UserDefaultAttrProp	ylow_prop;
	ylow_prop.set_description("Lower limit of the Y position interlock threshold in mm");
	ylow_prop.set_label("Y Low Int. Thres.");
	ylow_prop.set_unit("mm");
	//	standard_unit	not set for YLow
	//	display_unit	not set for YLow
	ylow_prop.set_format("%8.4f");
	//	max_value	not set for YLow
	//	min_value	not set for YLow
	//	max_alarm	not set for YLow
	//	min_alarm	not set for YLow
	//	max_warning	not set for YLow
	//	min_warning	not set for YLow
	//	delta_t	not set for YLow
	//	delta_val	not set for YLow
	
	ylow->set_default_properties(ylow_prop);
	//	Not Polled
	ylow->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ylow);

	//	Attribute : YHigh
	YHighAttrib	*yhigh = new YHighAttrib();
	Tango::UserDefaultAttrProp	yhigh_prop;
	yhigh_prop.set_description("Upper limit of the Y position interlock threshold in mm");
	yhigh_prop.set_label("Y High Int. Thres.");
	yhigh_prop.set_unit("mm");
	//	standard_unit	not set for YHigh
	//	display_unit	not set for YHigh
	yhigh_prop.set_format("%8.4f");
	//	max_value	not set for YHigh
	//	min_value	not set for YHigh
	//	max_alarm	not set for YHigh
	//	min_alarm	not set for YHigh
	//	max_warning	not set for YHigh
	//	min_warning	not set for YHigh
	//	delta_t	not set for YHigh
	//	delta_val	not set for YHigh
	
	yhigh->set_default_properties(yhigh_prop);
	//	Not Polled
	yhigh->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(yhigh);

	//	Attribute : AutoSwitchingEnabled
	AutoSwitchingEnabledAttrib	*autoswitchingenabled = new AutoSwitchingEnabledAttrib();
	Tango::UserDefaultAttrProp	autoswitchingenabled_prop;
	autoswitchingenabled_prop.set_description("Enables / disables the switching mechanism.");
	autoswitchingenabled_prop.set_label("Auto switching enabled");
	autoswitchingenabled_prop.set_unit("n/a");
	autoswitchingenabled_prop.set_standard_unit("n/a");
	autoswitchingenabled_prop.set_display_unit("n/a");
	//	format	not set for AutoSwitchingEnabled
	//	max_value	not set for AutoSwitchingEnabled
	//	min_value	not set for AutoSwitchingEnabled
	//	max_alarm	not set for AutoSwitchingEnabled
	//	min_alarm	not set for AutoSwitchingEnabled
	//	max_warning	not set for AutoSwitchingEnabled
	//	min_warning	not set for AutoSwitchingEnabled
	//	delta_t	not set for AutoSwitchingEnabled
	//	delta_val	not set for AutoSwitchingEnabled
	
	autoswitchingenabled->set_default_properties(autoswitchingenabled_prop);
	//	Not Polled
	autoswitchingenabled->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(autoswitchingenabled);

	//	Attribute : Switches
	SwitchesAttrib	*switches = new SwitchesAttrib();
	Tango::UserDefaultAttrProp	switches_prop;
	switches_prop.set_description("Switches selection. Must be in [0, 15] or 255 for auto-switching.");
	switches_prop.set_label("Switches");
	switches_prop.set_unit("a.u.");
	//	standard_unit	not set for Switches
	//	display_unit	not set for Switches
	switches_prop.set_format("%3d");
	switches_prop.set_max_value("255");
	switches_prop.set_min_value("0");
	//	max_alarm	not set for Switches
	//	min_alarm	not set for Switches
	//	max_warning	not set for Switches
	//	min_warning	not set for Switches
	//	delta_t	not set for Switches
	//	delta_val	not set for Switches
	
	switches->set_default_properties(switches_prop);
	//	Not Polled
	switches->set_disp_level(Tango::OPERATOR);
	switches->set_memorized();
	switches->set_memorized_init(true);
	att_list.push_back(switches);

	//	Attribute : ExternalSwitching
	ExternalSwitchingAttrib	*externalswitching = new ExternalSwitchingAttrib();
	Tango::UserDefaultAttrProp	externalswitching_prop;
	externalswitching_prop.set_description("Sets the source of switching clock ? MC (external) or from the \noscillator (internal). Default value is internal. ");
	externalswitching_prop.set_label("External Switching");
	//	unit	not set for ExternalSwitching
	//	standard_unit	not set for ExternalSwitching
	//	display_unit	not set for ExternalSwitching
	//	format	not set for ExternalSwitching
	//	max_value	not set for ExternalSwitching
	//	min_value	not set for ExternalSwitching
	//	max_alarm	not set for ExternalSwitching
	//	min_alarm	not set for ExternalSwitching
	//	max_warning	not set for ExternalSwitching
	//	min_warning	not set for ExternalSwitching
	//	delta_t	not set for ExternalSwitching
	//	delta_val	not set for ExternalSwitching
	
	externalswitching->set_default_properties(externalswitching_prop);
	//	Not Polled
	externalswitching->set_disp_level(Tango::OPERATOR);
	externalswitching->set_memorized();
	externalswitching->set_memorized_init(true);
	att_list.push_back(externalswitching);

	//	Attribute : SwitchingDelay
	SwitchingDelayAttrib	*switchingdelay = new SwitchingDelayAttrib();
	Tango::UserDefaultAttrProp	switchingdelay_prop;
	switchingdelay_prop.set_description("Sets the delay of the switch position change relative to the \nswitching source clock.");
	switchingdelay_prop.set_label("Switching Delay");
	switchingdelay_prop.set_unit("a.u.");
	//	standard_unit	not set for SwitchingDelay
	switchingdelay_prop.set_display_unit("%6d");
	//	format	not set for SwitchingDelay
	//	max_value	not set for SwitchingDelay
	switchingdelay_prop.set_min_value("0");
	//	max_alarm	not set for SwitchingDelay
	//	min_alarm	not set for SwitchingDelay
	//	max_warning	not set for SwitchingDelay
	//	min_warning	not set for SwitchingDelay
	//	delta_t	not set for SwitchingDelay
	//	delta_val	not set for SwitchingDelay
	
	switchingdelay->set_default_properties(switchingdelay_prop);
	//	Not Polled
	switchingdelay->set_disp_level(Tango::OPERATOR);
	switchingdelay->set_memorized();
	switchingdelay->set_memorized_init(true);
	att_list.push_back(switchingdelay);

	//	Attribute : OffsetTune
	OffsetTuneAttrib	*offsettune = new OffsetTuneAttrib();
	Tango::UserDefaultAttrProp	offsettune_prop;
	offsettune_prop.set_description("Sets the offset tune value, 1 unit is approximately 40 Hz. \nDefault value is 0 (precisely tuned).");
	offsettune_prop.set_label("OffsetTune");
	offsettune_prop.set_unit("x 40Hz");
	//	standard_unit	not set for OffsetTune
	//	display_unit	not set for OffsetTune
	offsettune_prop.set_format("%3d");
	offsettune_prop.set_max_value("500");
	offsettune_prop.set_min_value("-500");
	//	max_alarm	not set for OffsetTune
	//	min_alarm	not set for OffsetTune
	//	max_warning	not set for OffsetTune
	//	min_warning	not set for OffsetTune
	//	delta_t	not set for OffsetTune
	//	delta_val	not set for OffsetTune
	
	offsettune->set_default_properties(offsettune_prop);
	//	Not Polled
	offsettune->set_disp_level(Tango::OPERATOR);
	offsettune->set_memorized();
	offsettune->set_memorized_init(true);
	att_list.push_back(offsettune);

	//	Attribute : CompensateTune
	CompensateTuneAttrib	*compensatetune = new CompensateTuneAttrib();
	Tango::UserDefaultAttrProp	compensatetune_prop;
	compensatetune_prop.set_description("To enable double offset-tune, issue the following command \n(to disable it, just use ?false? instead of ?true?).");
	compensatetune_prop.set_label("Compensate Tune");
	//	unit	not set for CompensateTune
	//	standard_unit	not set for CompensateTune
	//	display_unit	not set for CompensateTune
	//	format	not set for CompensateTune
	//	max_value	not set for CompensateTune
	//	min_value	not set for CompensateTune
	//	max_alarm	not set for CompensateTune
	//	min_alarm	not set for CompensateTune
	//	max_warning	not set for CompensateTune
	//	min_warning	not set for CompensateTune
	//	delta_t	not set for CompensateTune
	//	delta_val	not set for CompensateTune
	
	compensatetune->set_default_properties(compensatetune_prop);
	//	Not Polled
	compensatetune->set_disp_level(Tango::OPERATOR);
	compensatetune->set_memorized();
	compensatetune->set_memorized_init(true);
	att_list.push_back(compensatetune);

	//	Attribute : DSCMode
	DSCModeAttrib	*dscmode = new DSCModeAttrib();
	Tango::UserDefaultAttrProp	dscmode_prop;
	dscmode_prop.set_description("Sets the adjustment (learning) of the amplitude and \nphase coefficients true or false. Set the \ncoefficients' type ? adjusted or unity. Combination of \nthese two nodes is necessary to achieve backward \ncompatiblity.");
	dscmode_prop.set_label("DSC Mode");
	dscmode_prop.set_unit("[0:OFF, 1:UNITY, 2:AUTO]");
	//	standard_unit	not set for DSCMode
	//	display_unit	not set for DSCMode
	dscmode_prop.set_format("%1d");
	dscmode_prop.set_max_value("2");
	dscmode_prop.set_min_value("0");
	//	max_alarm	not set for DSCMode
	//	min_alarm	not set for DSCMode
	//	max_warning	not set for DSCMode
	//	min_warning	not set for DSCMode
	//	delta_t	not set for DSCMode
	//	delta_val	not set for DSCMode
	
	dscmode->set_default_properties(dscmode_prop);
	//	Not Polled
	dscmode->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(dscmode);

	//	Attribute : AGCEnabled
	AGCEnabledAttrib	*agcenabled = new AGCEnabledAttrib();
	Tango::UserDefaultAttrProp	agcenabled_prop;
	agcenabled_prop.set_description("Enables/disables the Automatic Gain Control");
	agcenabled_prop.set_label("AGC");
	//	unit	not set for AGCEnabled
	//	standard_unit	not set for AGCEnabled
	//	display_unit	not set for AGCEnabled
	//	format	not set for AGCEnabled
	//	max_value	not set for AGCEnabled
	//	min_value	not set for AGCEnabled
	//	max_alarm	not set for AGCEnabled
	//	min_alarm	not set for AGCEnabled
	//	max_warning	not set for AGCEnabled
	//	min_warning	not set for AGCEnabled
	//	delta_t	not set for AGCEnabled
	//	delta_val	not set for AGCEnabled
	
	agcenabled->set_default_properties(agcenabled_prop);
	//	Not Polled
	agcenabled->set_disp_level(Tango::OPERATOR);
	agcenabled->set_memorized();
	agcenabled->set_memorized_init(true);
	att_list.push_back(agcenabled);

	//	Attribute : Gain
	GainAttrib	*gain = new GainAttrib();
	Tango::UserDefaultAttrProp	gain_prop;
	gain_prop.set_description("Sets the power_level. Attenuation at chosen level \ndepends on the gain scheme configuration. AGC \nmust be disabled to use manual Gain setting.");
	gain_prop.set_label("Gain");
	gain_prop.set_unit("dBm");
	gain_prop.set_standard_unit("dBm");
	gain_prop.set_display_unit("dBm");
	gain_prop.set_format("%2.0f");
	gain_prop.set_max_value("0");
	gain_prop.set_min_value("-60");
	//	max_alarm	not set for Gain
	//	min_alarm	not set for Gain
	//	max_warning	not set for Gain
	//	min_warning	not set for Gain
	//	delta_t	not set for Gain
	//	delta_val	not set for Gain
	
	gain->set_default_properties(gain_prop);
	//	Not Polled
	gain->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(gain);

	//	Attribute : HasMAFSupport
	HasMAFSupportAttrib	*hasmafsupport = new HasMAFSupportAttrib();
	Tango::UserDefaultAttrProp	hasmafsupport_prop;
	hasmafsupport_prop.set_description("<true> if FGPA design with MAF support installed on Libera, <false> otherwise");
	hasmafsupport_prop.set_label("Moving Average Filter Support");
	//	unit	not set for HasMAFSupport
	//	standard_unit	not set for HasMAFSupport
	//	display_unit	not set for HasMAFSupport
	//	format	not set for HasMAFSupport
	//	max_value	not set for HasMAFSupport
	//	min_value	not set for HasMAFSupport
	//	max_alarm	not set for HasMAFSupport
	//	min_alarm	not set for HasMAFSupport
	//	max_warning	not set for HasMAFSupport
	//	min_warning	not set for HasMAFSupport
	//	delta_t	not set for HasMAFSupport
	//	delta_val	not set for HasMAFSupport
	
	hasmafsupport->set_default_properties(hasmafsupport_prop);
	//	Not Polled
	hasmafsupport->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(hasmafsupport);

	//	Attribute : MAFLength
	MAFLengthAttrib	*maflength = new MAFLengthAttrib();
	Tango::UserDefaultAttrProp	maflength_prop;
	maflength_prop.set_description("MAF Delay and MAF Length are two\nparameters, added to adjustable\nDDC design. They are used to\ndetermine the position and the length\nof the acquisition window according\nto the partial fill of the accelerator.");
	maflength_prop.set_label("Moving Average Filter Length");
	maflength_prop.set_unit("ADC samples");
	//	standard_unit	not set for MAFLength
	//	display_unit	not set for MAFLength
	maflength_prop.set_format("%6d");
	//	max_value	not set for MAFLength
	maflength_prop.set_min_value("1");
	//	max_alarm	not set for MAFLength
	//	min_alarm	not set for MAFLength
	//	max_warning	not set for MAFLength
	//	min_warning	not set for MAFLength
	//	delta_t	not set for MAFLength
	//	delta_val	not set for MAFLength
	
	maflength->set_default_properties(maflength_prop);
	//	Not Polled
	maflength->set_disp_level(Tango::OPERATOR);
	maflength->set_memorized();
	maflength->set_memorized_init(true);
	att_list.push_back(maflength);

	//	Attribute : MAFDelay
	MAFDelayAttrib	*mafdelay = new MAFDelayAttrib();
	Tango::UserDefaultAttrProp	mafdelay_prop;
	mafdelay_prop.set_description("MAF Delay and MAF Length are two\nparameters, added to adjustable\nDDC design. They are used to\ndetermine the position and the length\nof the acquisition window according\nto the partial fill of the accelerator.\n");
	mafdelay_prop.set_label("Moving Average Filter Delay");
	mafdelay_prop.set_unit("ADC samples");
	//	standard_unit	not set for MAFDelay
	//	display_unit	not set for MAFDelay
	mafdelay_prop.set_format("%6d");
	//	max_value	not set for MAFDelay
	mafdelay_prop.set_min_value("0");
	//	max_alarm	not set for MAFDelay
	//	min_alarm	not set for MAFDelay
	//	max_warning	not set for MAFDelay
	//	min_warning	not set for MAFDelay
	//	delta_t	not set for MAFDelay
	//	delta_val	not set for MAFDelay
	
	mafdelay->set_default_properties(mafdelay_prop);
	//	Not Polled
	mafdelay->set_disp_level(Tango::OPERATOR);
	mafdelay->set_memorized();
	mafdelay->set_memorized_init(true);
	att_list.push_back(mafdelay);

	//	Attribute : MachineTime
	MachineTimeAttrib	*machinetime = new MachineTimeAttrib();
	Tango::UserDefaultAttrProp	machinetime_prop;
	machinetime_prop.set_description("Machine Time value to be applied on the Libera when the SetTimeOnNextTrigger command is executed");
	machinetime_prop.set_label("Machine Time");
	machinetime_prop.set_unit("a.u.");
	//	standard_unit	not set for MachineTime
	//	display_unit	not set for MachineTime
	machinetime_prop.set_format("%9d");
	//	max_value	not set for MachineTime
	machinetime_prop.set_min_value("0");
	//	max_alarm	not set for MachineTime
	//	min_alarm	not set for MachineTime
	//	max_warning	not set for MachineTime
	//	min_warning	not set for MachineTime
	//	delta_t	not set for MachineTime
	//	delta_val	not set for MachineTime
	
	machinetime->set_default_properties(machinetime_prop);
	//	Not Polled
	machinetime->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(machinetime);

	//	Attribute : TimePhase
	TimePhaseAttrib	*timephase = new TimePhaseAttrib();
	Tango::UserDefaultAttrProp	timephase_prop;
	timephase_prop.set_description("The Machine Time Phase");
	timephase_prop.set_label("Machine Time Phase");
	timephase_prop.set_unit("a.u.");
	//	standard_unit	not set for TimePhase
	//	display_unit	not set for TimePhase
	timephase_prop.set_format("%6d");
	//	max_value	not set for TimePhase
	//	min_value	not set for TimePhase
	//	max_alarm	not set for TimePhase
	//	min_alarm	not set for TimePhase
	//	max_warning	not set for TimePhase
	//	min_warning	not set for TimePhase
	//	delta_t	not set for TimePhase
	//	delta_val	not set for TimePhase
	
	timephase->set_default_properties(timephase_prop);
	//	Not Polled
	timephase->set_disp_level(Tango::OPERATOR);
	timephase->set_memorized();
	timephase->set_memorized_init(true);
	att_list.push_back(timephase);

	//	Attribute : SystemTime
	SystemTimeAttrib	*systemtime = new SystemTimeAttrib();
	Tango::UserDefaultAttrProp	systemtime_prop;
	systemtime_prop.set_description("System Time value to be applied on the Libera when the SetTimeOnNextTrigger command is executed\nUnit is num of secs since 1/1/1970 (Unix system time reference)");
	systemtime_prop.set_label("System Time");
	systemtime_prop.set_unit("secs since 1/1/1970");
	//	standard_unit	not set for SystemTime
	//	display_unit	not set for SystemTime
	systemtime_prop.set_format("%10d");
	//	max_value	not set for SystemTime
	systemtime_prop.set_min_value("2000000000");
	//	max_alarm	not set for SystemTime
	//	min_alarm	not set for SystemTime
	//	max_warning	not set for SystemTime
	//	min_warning	not set for SystemTime
	//	delta_t	not set for SystemTime
	//	delta_val	not set for SystemTime
	
	systemtime->set_default_properties(systemtime_prop);
	//	Not Polled
	systemtime->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(systemtime);

	//	Attribute : SCPLLStatus
	SCPLLStatusAttrib	*scpllstatus = new SCPLLStatusAttrib();
	Tango::UserDefaultAttrProp	scpllstatus_prop;
	scpllstatus_prop.set_description("The SC PLL lock status");
	scpllstatus_prop.set_label("SC PLL Locked");
	//	unit	not set for SCPLLStatus
	//	standard_unit	not set for SCPLLStatus
	//	display_unit	not set for SCPLLStatus
	scpllstatus_prop.set_format("%8d");
	//	max_value	not set for SCPLLStatus
	//	min_value	not set for SCPLLStatus
	//	max_alarm	not set for SCPLLStatus
	//	min_alarm	not set for SCPLLStatus
	//	max_warning	not set for SCPLLStatus
	//	min_warning	not set for SCPLLStatus
	//	delta_t	not set for SCPLLStatus
	//	delta_val	not set for SCPLLStatus
	
	scpllstatus->set_default_properties(scpllstatus_prop);
	//	Not Polled
	scpllstatus->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(scpllstatus);

	//	Attribute : MCPLLStatus
	MCPLLStatusAttrib	*mcpllstatus = new MCPLLStatusAttrib();
	Tango::UserDefaultAttrProp	mcpllstatus_prop;
	mcpllstatus_prop.set_description("Indicates the MC PLL status (1=locked, 0=unlocked)");
	mcpllstatus_prop.set_label("MC PLL Locked");
	//	unit	not set for MCPLLStatus
	//	standard_unit	not set for MCPLLStatus
	//	display_unit	not set for MCPLLStatus
	mcpllstatus_prop.set_format("%8d");
	//	max_value	not set for MCPLLStatus
	//	min_value	not set for MCPLLStatus
	//	max_alarm	not set for MCPLLStatus
	//	min_alarm	not set for MCPLLStatus
	//	max_warning	not set for MCPLLStatus
	//	min_warning	not set for MCPLLStatus
	//	delta_t	not set for MCPLLStatus
	//	delta_val	not set for MCPLLStatus
	
	mcpllstatus->set_default_properties(mcpllstatus_prop);
	//	Not Polled
	mcpllstatus->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(mcpllstatus);

	//	Attribute : Temp1
	Temp1Attrib	*temp1 = new Temp1Attrib();
	Tango::UserDefaultAttrProp	temp1_prop;
	temp1_prop.set_description("Temperature of the hottest component on the BPM \nmodule is returned.");
	temp1_prop.set_label("Temperature 1");
	temp1_prop.set_unit("deg.C");
	//	standard_unit	not set for Temp1
	//	display_unit	not set for Temp1
	temp1_prop.set_format("%8d");
	//	max_value	not set for Temp1
	//	min_value	not set for Temp1
	temp1_prop.set_max_alarm("65");
	//	min_alarm	not set for Temp1
	//	max_warning	not set for Temp1
	//	min_warning	not set for Temp1
	//	delta_t	not set for Temp1
	//	delta_val	not set for Temp1
	
	temp1->set_default_properties(temp1_prop);
	//	Not Polled
	temp1->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(temp1);

	//	Attribute : Temp2
	Temp2Attrib	*temp2 = new Temp2Attrib();
	Tango::UserDefaultAttrProp	temp2_prop;
	temp2_prop.set_description("Temperature of the hottest component on the chassis \ninterconnection board is returned.");
	temp2_prop.set_label("Temperature 2");
	temp2_prop.set_unit("deg.C");
	//	standard_unit	not set for Temp2
	//	display_unit	not set for Temp2
	temp2_prop.set_format("%8d");
	//	max_value	not set for Temp2
	//	min_value	not set for Temp2
	temp2_prop.set_max_alarm("65");
	//	min_alarm	not set for Temp2
	//	max_warning	not set for Temp2
	//	min_warning	not set for Temp2
	//	delta_t	not set for Temp2
	//	delta_val	not set for Temp2
	
	temp2->set_default_properties(temp2_prop);
	//	Not Polled
	temp2->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(temp2);

	//	Attribute : Temp3
	Temp3Attrib	*temp3 = new Temp3Attrib();
	Tango::UserDefaultAttrProp	temp3_prop;
	temp3_prop.set_description("Temperature of the hottest component on the timing \nmodule is returned.");
	temp3_prop.set_label("Temperature 3");
	temp3_prop.set_unit("deg.C");
	//	standard_unit	not set for Temp3
	//	display_unit	not set for Temp3
	temp3_prop.set_format("%8d");
	//	max_value	not set for Temp3
	//	min_value	not set for Temp3
	temp3_prop.set_max_alarm("65");
	//	min_alarm	not set for Temp3
	//	max_warning	not set for Temp3
	//	min_warning	not set for Temp3
	//	delta_t	not set for Temp3
	//	delta_val	not set for Temp3
	
	temp3->set_default_properties(temp3_prop);
	//	Not Polled
	temp3->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(temp3);

	//	Attribute : Fan1Speed
	Fan1SpeedAttrib	*fan1speed = new Fan1SpeedAttrib();
	Tango::UserDefaultAttrProp	fan1speed_prop;
	fan1speed_prop.set_description("Provides minimal fan speed reading of all three fans on \nthe left side of the chassis in order to identify if the fan \nmodule (consisting of 3 fans) is broken ? returned value \n0 means that at least one fan has stopped.");
	fan1speed_prop.set_label("Fan.1");
	fan1speed_prop.set_unit("rpm");
	//	standard_unit	not set for Fan1Speed
	//	display_unit	not set for Fan1Speed
	fan1speed_prop.set_format("%8d");
	//	max_value	not set for Fan1Speed
	//	min_value	not set for Fan1Speed
	//	max_alarm	not set for Fan1Speed
	fan1speed_prop.set_min_alarm("1000");
	//	max_warning	not set for Fan1Speed
	//	min_warning	not set for Fan1Speed
	//	delta_t	not set for Fan1Speed
	//	delta_val	not set for Fan1Speed
	
	fan1speed->set_default_properties(fan1speed_prop);
	//	Not Polled
	fan1speed->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(fan1speed);

	//	Attribute : Fan2Speed
	Fan2SpeedAttrib	*fan2speed = new Fan2SpeedAttrib();
	Tango::UserDefaultAttrProp	fan2speed_prop;
	fan2speed_prop.set_description("Provides minimal fan speed reading of all three fans on \nthe right side of the chassis in order to identify if the fan \nmodule (consisting of 3 fans) is broken ? returned value \n0 means that at least one fan has stopped.");
	fan2speed_prop.set_label("Fan.2");
	fan2speed_prop.set_unit("rpm");
	//	standard_unit	not set for Fan2Speed
	//	display_unit	not set for Fan2Speed
	fan2speed_prop.set_format("%8d");
	//	max_value	not set for Fan2Speed
	//	min_value	not set for Fan2Speed
	//	max_alarm	not set for Fan2Speed
	fan2speed_prop.set_min_alarm("1000");
	//	max_warning	not set for Fan2Speed
	//	min_warning	not set for Fan2Speed
	//	delta_t	not set for Fan2Speed
	//	delta_val	not set for Fan2Speed
	
	fan2speed->set_default_properties(fan2speed_prop);
	//	Not Polled
	fan2speed->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(fan2speed);

	//	Attribute : Incoherence
	IncoherenceAttrib	*incoherence = new IncoherenceAttrib();
	Tango::UserDefaultAttrProp	incoherence_prop;
	incoherence_prop.set_description("Result of the incoherence calculation. Am alarm will be set \non the attribute when an incoherence was detected.");
	incoherence_prop.set_label("Incoherence");
	incoherence_prop.set_unit("a.u.");
	//	standard_unit	not set for Incoherence
	//	display_unit	not set for Incoherence
	incoherence_prop.set_format("%6.4f");
	//	max_value	not set for Incoherence
	//	min_value	not set for Incoherence
	//	max_alarm	not set for Incoherence
	//	min_alarm	not set for Incoherence
	//	max_warning	not set for Incoherence
	//	min_warning	not set for Incoherence
	//	delta_t	not set for Incoherence
	//	delta_val	not set for Incoherence
	
	incoherence->set_default_properties(incoherence_prop);
	//	Not Polled
	incoherence->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(incoherence);

	//	Attribute : RefIncoherence
	RefIncoherenceAttrib	*refincoherence = new RefIncoherenceAttrib();
	Tango::UserDefaultAttrProp	refincoherence_prop;
	refincoherence_prop.set_description("The reference incoherence value registered with the command \nSetReferenceIncoherence. The reference is used to calculate the\nalarm with the MaxIncoherenceDrift.");
	refincoherence_prop.set_label("Ref. Incoherence");
	refincoherence_prop.set_unit("a.u.");
	//	standard_unit	not set for RefIncoherence
	//	display_unit	not set for RefIncoherence
	refincoherence_prop.set_format("%6.4f");
	//	max_value	not set for RefIncoherence
	//	min_value	not set for RefIncoherence
	//	max_alarm	not set for RefIncoherence
	//	min_alarm	not set for RefIncoherence
	//	max_warning	not set for RefIncoherence
	//	min_warning	not set for RefIncoherence
	//	delta_t	not set for RefIncoherence
	//	delta_val	not set for RefIncoherence
	
	refincoherence->set_default_properties(refincoherence_prop);
	//	Not Polled
	refincoherence->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(refincoherence);

	//	Attribute : MaxIncoherence
	MaxIncoherenceAttrib	*maxincoherence = new MaxIncoherenceAttrib();
	Tango::UserDefaultAttrProp	maxincoherence_prop;
	maxincoherence_prop.set_description("Maximum incoherence value. Used to create an alarm on\nthe Incoherence attribute.");
	maxincoherence_prop.set_label("Max. incoherence");
	maxincoherence_prop.set_unit("a.u.");
	//	standard_unit	not set for MaxIncoherence
	//	display_unit	not set for MaxIncoherence
	maxincoherence_prop.set_format("%6.4f");
	//	max_value	not set for MaxIncoherence
	//	min_value	not set for MaxIncoherence
	//	max_alarm	not set for MaxIncoherence
	//	min_alarm	not set for MaxIncoherence
	//	max_warning	not set for MaxIncoherence
	//	min_warning	not set for MaxIncoherence
	//	delta_t	not set for MaxIncoherence
	//	delta_val	not set for MaxIncoherence
	
	maxincoherence->set_default_properties(maxincoherence_prop);
	//	Not Polled
	maxincoherence->set_disp_level(Tango::OPERATOR);
	maxincoherence->set_memorized();
	maxincoherence->set_memorized_init(true);
	att_list.push_back(maxincoherence);

	//	Attribute : MaxIncoherenceDrift
	MaxIncoherenceDriftAttrib	*maxincoherencedrift = new MaxIncoherenceDriftAttrib();
	Tango::UserDefaultAttrProp	maxincoherencedrift_prop;
	maxincoherencedrift_prop.set_description("Maximum incoherence drift value. Used to create an alarm on\nthe Incoherence attribute.");
	maxincoherencedrift_prop.set_label("Max. Incoherence Drift ");
	maxincoherencedrift_prop.set_unit("a.u.");
	//	standard_unit	not set for MaxIncoherenceDrift
	//	display_unit	not set for MaxIncoherenceDrift
	maxincoherencedrift_prop.set_format("%6.4f");
	//	max_value	not set for MaxIncoherenceDrift
	//	min_value	not set for MaxIncoherenceDrift
	//	max_alarm	not set for MaxIncoherenceDrift
	//	min_alarm	not set for MaxIncoherenceDrift
	//	max_warning	not set for MaxIncoherenceDrift
	//	min_warning	not set for MaxIncoherenceDrift
	//	delta_t	not set for MaxIncoherenceDrift
	//	delta_val	not set for MaxIncoherenceDrift
	
	maxincoherencedrift->set_default_properties(maxincoherencedrift_prop);
	//	Not Polled
	maxincoherencedrift->set_disp_level(Tango::OPERATOR);
	maxincoherencedrift->set_memorized();
	maxincoherencedrift->set_memorized_init(true);
	att_list.push_back(maxincoherencedrift);

	//	Attribute : UpTime
	UpTimeAttrib	*uptime = new UpTimeAttrib();
	Tango::UserDefaultAttrProp	uptime_prop;
	uptime_prop.set_description("Number of seconds since system boot on the host running this TANGO device");
	uptime_prop.set_label("Uptime");
	uptime_prop.set_unit("secs");
	//	standard_unit	not set for UpTime
	//	display_unit	not set for UpTime
	uptime_prop.set_format("%8d");
	//	max_value	not set for UpTime
	//	min_value	not set for UpTime
	//	max_alarm	not set for UpTime
	//	min_alarm	not set for UpTime
	//	max_warning	not set for UpTime
	//	min_warning	not set for UpTime
	//	delta_t	not set for UpTime
	//	delta_val	not set for UpTime
	
	uptime->set_default_properties(uptime_prop);
	//	Not Polled
	uptime->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(uptime);

	//	Attribute : CpuUsage
	CpuUsageAttrib	*cpuusage = new CpuUsageAttrib();
	Tango::UserDefaultAttrProp	cpuusage_prop;
	cpuusage_prop.set_description("CPU usage on the host running this TANGO device");
	cpuusage_prop.set_label("CPU Usage");
	cpuusage_prop.set_unit("%");
	//	standard_unit	not set for CpuUsage
	//	display_unit	not set for CpuUsage
	cpuusage_prop.set_format("%8d");
	//	max_value	not set for CpuUsage
	//	min_value	not set for CpuUsage
	//	max_alarm	not set for CpuUsage
	//	min_alarm	not set for CpuUsage
	//	max_warning	not set for CpuUsage
	//	min_warning	not set for CpuUsage
	//	delta_t	not set for CpuUsage
	//	delta_val	not set for CpuUsage
	
	cpuusage->set_default_properties(cpuusage_prop);
	//	Not Polled
	cpuusage->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(cpuusage);

	//	Attribute : FreeMemory
	FreeMemoryAttrib	*freememory = new FreeMemoryAttrib();
	Tango::UserDefaultAttrProp	freememory_prop;
	freememory_prop.set_description("Amount of free memory on the host running this TANGO device");
	freememory_prop.set_label("Free Mem.");
	freememory_prop.set_unit("bytes");
	//	standard_unit	not set for FreeMemory
	//	display_unit	not set for FreeMemory
	freememory_prop.set_format("%8d");
	//	max_value	not set for FreeMemory
	//	min_value	not set for FreeMemory
	//	max_alarm	not set for FreeMemory
	//	min_alarm	not set for FreeMemory
	//	max_warning	not set for FreeMemory
	//	min_warning	not set for FreeMemory
	//	delta_t	not set for FreeMemory
	//	delta_val	not set for FreeMemory
	
	freememory->set_default_properties(freememory_prop);
	//	Not Polled
	freememory->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(freememory);

	//	Attribute : RamFsUsage
	RamFsUsageAttrib	*ramfsusage = new RamFsUsageAttrib();
	Tango::UserDefaultAttrProp	ramfsusage_prop;
	ramfsusage_prop.set_description("Amount of ram-fs allocated bytes on the host running this TANGO device ");
	ramfsusage_prop.set_label("Ram-fs Usage");
	ramfsusage_prop.set_unit("bytes");
	//	standard_unit	not set for RamFsUsage
	//	display_unit	not set for RamFsUsage
	ramfsusage_prop.set_format("%8d");
	//	max_value	not set for RamFsUsage
	//	min_value	not set for RamFsUsage
	//	max_alarm	not set for RamFsUsage
	//	min_alarm	not set for RamFsUsage
	//	max_warning	not set for RamFsUsage
	//	min_warning	not set for RamFsUsage
	//	delta_t	not set for RamFsUsage
	//	delta_val	not set for RamFsUsage
	
	ramfsusage->set_default_properties(ramfsusage_prop);
	//	Not Polled
	ramfsusage->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ramfsusage);

	//	Attribute : UseLiberaSAData
	UseLiberaSADataAttrib	*useliberasadata = new UseLiberaSADataAttrib();
	Tango::UserDefaultAttrProp	useliberasadata_prop;
	useliberasadata_prop.set_description("If set to true, the X & Z SA postions are retreived from the Libera FPGA.\nOtherwise, they are computed by the Tango device using the button values.\n ");
	useliberasadata_prop.set_label("Use Libera SA Data");
	//	unit	not set for UseLiberaSAData
	//	standard_unit	not set for UseLiberaSAData
	//	display_unit	not set for UseLiberaSAData
	//	format	not set for UseLiberaSAData
	//	max_value	not set for UseLiberaSAData
	//	min_value	not set for UseLiberaSAData
	//	max_alarm	not set for UseLiberaSAData
	//	min_alarm	not set for UseLiberaSAData
	//	max_warning	not set for UseLiberaSAData
	//	min_warning	not set for UseLiberaSAData
	//	delta_t	not set for UseLiberaSAData
	//	delta_val	not set for UseLiberaSAData
	
	useliberasadata->set_default_properties(useliberasadata_prop);
	//	Not Polled
	useliberasadata->set_disp_level(Tango::EXPERT);
	useliberasadata->set_memorized();
	useliberasadata->set_memorized_init(true);
	att_list.push_back(useliberasadata);

	//	Attribute : InterlockEnabled
	InterlockEnabledAttrib	*interlockenabled = new InterlockEnabledAttrib();
	Tango::UserDefaultAttrProp	interlockenabled_prop;
	interlockenabled_prop.set_description("Enables / disables the Interlock detection.");
	interlockenabled_prop.set_label("Interlock Enabled");
	interlockenabled_prop.set_unit("n/a");
	interlockenabled_prop.set_standard_unit("n/a");
	interlockenabled_prop.set_display_unit("n/a");
	//	format	not set for InterlockEnabled
	//	max_value	not set for InterlockEnabled
	//	min_value	not set for InterlockEnabled
	//	max_alarm	not set for InterlockEnabled
	//	min_alarm	not set for InterlockEnabled
	//	max_warning	not set for InterlockEnabled
	//	min_warning	not set for InterlockEnabled
	//	delta_t	not set for InterlockEnabled
	//	delta_val	not set for InterlockEnabled
	
	interlockenabled->set_default_properties(interlockenabled_prop);
	//	Not Polled
	interlockenabled->set_disp_level(Tango::OPERATOR);
	interlockenabled->set_memorized();
	interlockenabled->set_memorized_init(true);
	att_list.push_back(interlockenabled);

	//	Attribute : InterlockGainDependentEnabled
	InterlockGainDependentEnabledAttrib	*interlockgaindependentenabled = new InterlockGainDependentEnabledAttrib();
	Tango::UserDefaultAttrProp	interlockgaindependentenabled_prop;
	interlockgaindependentenabled_prop.set_description("Enables / disables gain dependent mode of Interlock operation.");
	interlockgaindependentenabled_prop.set_label("Interlock Gain Dependence Enabled");
	interlockgaindependentenabled_prop.set_unit("n/a");
	interlockgaindependentenabled_prop.set_standard_unit("n/a");
	interlockgaindependentenabled_prop.set_display_unit("n/a");
	//	format	not set for InterlockGainDependentEnabled
	//	max_value	not set for InterlockGainDependentEnabled
	//	min_value	not set for InterlockGainDependentEnabled
	//	max_alarm	not set for InterlockGainDependentEnabled
	//	min_alarm	not set for InterlockGainDependentEnabled
	//	max_warning	not set for InterlockGainDependentEnabled
	//	min_warning	not set for InterlockGainDependentEnabled
	//	delta_t	not set for InterlockGainDependentEnabled
	//	delta_val	not set for InterlockGainDependentEnabled
	
	interlockgaindependentenabled->set_default_properties(interlockgaindependentenabled_prop);
	//	Not Polled
	interlockgaindependentenabled->set_disp_level(Tango::OPERATOR);
	interlockgaindependentenabled->set_memorized();
	interlockgaindependentenabled->set_memorized_init(true);
	att_list.push_back(interlockgaindependentenabled);

	//	Attribute : InterlockOverflowThreshold
	InterlockOverflowThresholdAttrib	*interlockoverflowthreshold = new InterlockOverflowThresholdAttrib();
	Tango::UserDefaultAttrProp	interlockoverflowthreshold_prop;
	interlockoverflowthreshold_prop.set_description("ADC saturation threshold.");
	interlockoverflowthreshold_prop.set_label("interlock overflow");
	interlockoverflowthreshold_prop.set_unit("a.u.");
	//	standard_unit	not set for InterlockOverflowThreshold
	//	display_unit	not set for InterlockOverflowThreshold
	interlockoverflowthreshold_prop.set_format("%5d");
	interlockoverflowthreshold_prop.set_max_value("32766");
	interlockoverflowthreshold_prop.set_min_value("0");
	//	max_alarm	not set for InterlockOverflowThreshold
	//	min_alarm	not set for InterlockOverflowThreshold
	//	max_warning	not set for InterlockOverflowThreshold
	//	min_warning	not set for InterlockOverflowThreshold
	//	delta_t	not set for InterlockOverflowThreshold
	//	delta_val	not set for InterlockOverflowThreshold
	
	interlockoverflowthreshold->set_default_properties(interlockoverflowthreshold_prop);
	//	Not Polled
	interlockoverflowthreshold->set_disp_level(Tango::OPERATOR);
	interlockoverflowthreshold->set_memorized();
	interlockoverflowthreshold->set_memorized_init(true);
	att_list.push_back(interlockoverflowthreshold);

	//	Attribute : InterlockOverflowDuration
	InterlockOverflowDurationAttrib	*interlockoverflowduration = new InterlockOverflowDurationAttrib();
	Tango::UserDefaultAttrProp	interlockoverflowduration_prop;
	interlockoverflowduration_prop.set_description("Duration of allowed ADC saturation (in ADC samples).");
	interlockoverflowduration_prop.set_label("interlock overflow duration");
	interlockoverflowduration_prop.set_unit("a.u.");
	//	standard_unit	not set for InterlockOverflowDuration
	//	display_unit	not set for InterlockOverflowDuration
	interlockoverflowduration_prop.set_format("%5d");
	interlockoverflowduration_prop.set_max_value("1023");
	interlockoverflowduration_prop.set_min_value("0");
	//	max_alarm	not set for InterlockOverflowDuration
	//	min_alarm	not set for InterlockOverflowDuration
	//	max_warning	not set for InterlockOverflowDuration
	//	min_warning	not set for InterlockOverflowDuration
	//	delta_t	not set for InterlockOverflowDuration
	//	delta_val	not set for InterlockOverflowDuration
	
	interlockoverflowduration->set_default_properties(interlockoverflowduration_prop);
	//	Not Polled
	interlockoverflowduration->set_disp_level(Tango::OPERATOR);
	interlockoverflowduration->set_memorized();
	interlockoverflowduration->set_memorized_init(true);
	att_list.push_back(interlockoverflowduration);

	//	Attribute : InterlockGainDependentThreshold
	InterlockGainDependentThresholdAttrib	*interlockgaindependentthreshold = new InterlockGainDependentThresholdAttrib();
	Tango::UserDefaultAttrProp	interlockgaindependentthreshold_prop;
	interlockgaindependentthreshold_prop.set_description("Sets the threshold for gain dependent mode of Interlock \noperation.");
	interlockgaindependentthreshold_prop.set_label("interlock gain limit");
	interlockgaindependentthreshold_prop.set_unit("a.u.");
	//	standard_unit	not set for InterlockGainDependentThreshold
	interlockgaindependentthreshold_prop.set_display_unit("%5d");
	//	format	not set for InterlockGainDependentThreshold
	interlockgaindependentthreshold_prop.set_max_value("0");
	interlockgaindependentthreshold_prop.set_min_value("-80");
	//	max_alarm	not set for InterlockGainDependentThreshold
	//	min_alarm	not set for InterlockGainDependentThreshold
	//	max_warning	not set for InterlockGainDependentThreshold
	//	min_warning	not set for InterlockGainDependentThreshold
	//	delta_t	not set for InterlockGainDependentThreshold
	//	delta_val	not set for InterlockGainDependentThreshold
	
	interlockgaindependentthreshold->set_default_properties(interlockgaindependentthreshold_prop);
	//	Not Polled
	interlockgaindependentthreshold->set_disp_level(Tango::OPERATOR);
	interlockgaindependentthreshold->set_memorized();
	interlockgaindependentthreshold->set_memorized_init(true);
	att_list.push_back(interlockgaindependentthreshold);

	//	Attribute : Kx
	KxAttrib	*kx = new KxAttrib();
	Tango::UserDefaultAttrProp	kx_prop;
	kx_prop.set_description("Sets the Kx for X position calculation. Default setting is 10 mm \n(=10000000 nm).");
	kx_prop.set_label("X position coefficient");
	kx_prop.set_unit("a.u.");
	//	standard_unit	not set for Kx
	//	display_unit	not set for Kx
	kx_prop.set_format("%8.2f");
	kx_prop.set_max_value("50");
	kx_prop.set_min_value("0.0000001");
	//	max_alarm	not set for Kx
	//	min_alarm	not set for Kx
	//	max_warning	not set for Kx
	//	min_warning	not set for Kx
	//	delta_t	not set for Kx
	//	delta_val	not set for Kx
	
	kx->set_default_properties(kx_prop);
	//	Not Polled
	kx->set_disp_level(Tango::OPERATOR);
	kx->set_memorized();
	kx->set_memorized_init(true);
	att_list.push_back(kx);

	//	Attribute : Ky
	KyAttrib	*ky = new KyAttrib();
	Tango::UserDefaultAttrProp	ky_prop;
	ky_prop.set_description("Sets the Ky for Y position calculation. Default setting is 10 mm \n(=10000000 nm).");
	ky_prop.set_label("Y position coefficient");
	ky_prop.set_unit("a.u.");
	//	standard_unit	not set for Ky
	//	display_unit	not set for Ky
	ky_prop.set_format("%8.2f");
	ky_prop.set_max_value("50");
	ky_prop.set_min_value("0.0000001");
	//	max_alarm	not set for Ky
	//	min_alarm	not set for Ky
	//	max_warning	not set for Ky
	//	min_warning	not set for Ky
	//	delta_t	not set for Ky
	//	delta_val	not set for Ky
	
	ky->set_default_properties(ky_prop);
	//	Not Polled
	ky->set_disp_level(Tango::OPERATOR);
	ky->set_memorized();
	ky->set_memorized_init(true);
	att_list.push_back(ky);

	//	Attribute : XOffset
	XOffsetAttrib	*xoffset = new XOffsetAttrib();
	Tango::UserDefaultAttrProp	xoffset_prop;
	xoffset_prop.set_description("Sets the offset for X position in nm. Default value is 0 nm.");
	xoffset_prop.set_label("X position offset");
	xoffset_prop.set_unit("mm");
	//	standard_unit	not set for XOffset
	//	display_unit	not set for XOffset
	xoffset_prop.set_format("%8.4f");
	//	max_value	not set for XOffset
	//	min_value	not set for XOffset
	//	max_alarm	not set for XOffset
	//	min_alarm	not set for XOffset
	//	max_warning	not set for XOffset
	//	min_warning	not set for XOffset
	//	delta_t	not set for XOffset
	//	delta_val	not set for XOffset
	
	xoffset->set_default_properties(xoffset_prop);
	//	Not Polled
	xoffset->set_disp_level(Tango::OPERATOR);
	xoffset->set_memorized();
	xoffset->set_memorized_init(true);
	att_list.push_back(xoffset);

	//	Attribute : YOffset
	YOffsetAttrib	*yoffset = new YOffsetAttrib();
	Tango::UserDefaultAttrProp	yoffset_prop;
	yoffset_prop.set_description("Sets the offset for Y position in nm. Default value is 0 nm.");
	yoffset_prop.set_label("Y position offset");
	yoffset_prop.set_unit("mm");
	//	standard_unit	not set for YOffset
	//	display_unit	not set for YOffset
	yoffset_prop.set_format("%8.4f");
	//	max_value	not set for YOffset
	//	min_value	not set for YOffset
	//	max_alarm	not set for YOffset
	//	min_alarm	not set for YOffset
	//	max_warning	not set for YOffset
	//	min_warning	not set for YOffset
	//	delta_t	not set for YOffset
	//	delta_val	not set for YOffset
	
	yoffset->set_default_properties(yoffset_prop);
	//	Not Polled
	yoffset->set_disp_level(Tango::OPERATOR);
	yoffset->set_memorized();
	yoffset->set_memorized_init(true);
	att_list.push_back(yoffset);

	//	Attribute : XPosDD
	XPosDDAttrib	*xposdd = new XPosDDAttrib();
	Tango::UserDefaultAttrProp	xposdd_prop;
	xposdd_prop.set_description("Turn by turn data: X Pos.");
	xposdd_prop.set_label("DD X Pos.");
	xposdd_prop.set_unit("mm");
	xposdd_prop.set_standard_unit("mm");
	xposdd_prop.set_display_unit("mm");
	xposdd_prop.set_format("%8.4f");
	//	max_value	not set for XPosDD
	//	min_value	not set for XPosDD
	//	max_alarm	not set for XPosDD
	//	min_alarm	not set for XPosDD
	//	max_warning	not set for XPosDD
	//	min_warning	not set for XPosDD
	//	delta_t	not set for XPosDD
	//	delta_val	not set for XPosDD
	
	xposdd->set_default_properties(xposdd_prop);
	//	Not Polled
	xposdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xposdd);

	//	Attribute : YPosDD
	YPosDDAttrib	*yposdd = new YPosDDAttrib();
	Tango::UserDefaultAttrProp	yposdd_prop;
	yposdd_prop.set_description("Turn by turn data: Y Pos.");
	yposdd_prop.set_label("DD Y Pos.");
	yposdd_prop.set_unit("mm");
	yposdd_prop.set_standard_unit("mm");
	yposdd_prop.set_display_unit("mm");
	yposdd_prop.set_format("%8.4f");
	//	max_value	not set for YPosDD
	//	min_value	not set for YPosDD
	//	max_alarm	not set for YPosDD
	//	min_alarm	not set for YPosDD
	//	max_warning	not set for YPosDD
	//	min_warning	not set for YPosDD
	//	delta_t	not set for YPosDD
	//	delta_val	not set for YPosDD
	
	yposdd->set_default_properties(yposdd_prop);
	//	Not Polled
	yposdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(yposdd);

	//	Attribute : QuadDD
	QuadDDAttrib	*quaddd = new QuadDDAttrib();
	Tango::UserDefaultAttrProp	quaddd_prop;
	quaddd_prop.set_description("Turn by turn data: Quad");
	quaddd_prop.set_label("DD Quad");
	quaddd_prop.set_unit("a.u.");
	quaddd_prop.set_standard_unit("a.u.");
	quaddd_prop.set_display_unit("a.u.");
	quaddd_prop.set_format("%8.4f");
	//	max_value	not set for QuadDD
	//	min_value	not set for QuadDD
	//	max_alarm	not set for QuadDD
	//	min_alarm	not set for QuadDD
	//	max_warning	not set for QuadDD
	//	min_warning	not set for QuadDD
	//	delta_t	not set for QuadDD
	//	delta_val	not set for QuadDD
	
	quaddd->set_default_properties(quaddd_prop);
	//	Not Polled
	quaddd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(quaddd);

	//	Attribute : SumDD
	SumDDAttrib	*sumdd = new SumDDAttrib();
	Tango::UserDefaultAttrProp	sumdd_prop;
	sumdd_prop.set_description("Turn by turn data: Sum");
	sumdd_prop.set_label("DD Sum");
	sumdd_prop.set_unit("mm");
	sumdd_prop.set_standard_unit("mm");
	sumdd_prop.set_display_unit("mm");
	sumdd_prop.set_format("%10.0f");
	//	max_value	not set for SumDD
	//	min_value	not set for SumDD
	//	max_alarm	not set for SumDD
	//	min_alarm	not set for SumDD
	//	max_warning	not set for SumDD
	//	min_warning	not set for SumDD
	//	delta_t	not set for SumDD
	//	delta_val	not set for SumDD
	
	sumdd->set_default_properties(sumdd_prop);
	//	Not Polled
	sumdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(sumdd);

	//	Attribute : VaDD
	VaDDAttrib	*vadd = new VaDDAttrib();
	Tango::UserDefaultAttrProp	vadd_prop;
	vadd_prop.set_description("Turn by turn data: Va");
	vadd_prop.set_label("DD Va");
	vadd_prop.set_unit("a.u.");
	vadd_prop.set_standard_unit("a.u.");
	vadd_prop.set_display_unit("a.u.");
	vadd_prop.set_format("%10.0f");
	//	max_value	not set for VaDD
	//	min_value	not set for VaDD
	//	max_alarm	not set for VaDD
	//	min_alarm	not set for VaDD
	//	max_warning	not set for VaDD
	//	min_warning	not set for VaDD
	//	delta_t	not set for VaDD
	//	delta_val	not set for VaDD
	
	vadd->set_default_properties(vadd_prop);
	//	Not Polled
	vadd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vadd);

	//	Attribute : VbDD
	VbDDAttrib	*vbdd = new VbDDAttrib();
	Tango::UserDefaultAttrProp	vbdd_prop;
	vbdd_prop.set_description("Turn by turn data: Vb");
	vbdd_prop.set_label("DD Vb");
	vbdd_prop.set_unit("a.u.");
	vbdd_prop.set_standard_unit("a.u.");
	vbdd_prop.set_display_unit("a.u.");
	vbdd_prop.set_format("%10.0f");
	//	max_value	not set for VbDD
	//	min_value	not set for VbDD
	//	max_alarm	not set for VbDD
	//	min_alarm	not set for VbDD
	//	max_warning	not set for VbDD
	//	min_warning	not set for VbDD
	//	delta_t	not set for VbDD
	//	delta_val	not set for VbDD
	
	vbdd->set_default_properties(vbdd_prop);
	//	Not Polled
	vbdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vbdd);

	//	Attribute : VcDD
	VcDDAttrib	*vcdd = new VcDDAttrib();
	Tango::UserDefaultAttrProp	vcdd_prop;
	vcdd_prop.set_description("Turn by turn data: Vc");
	vcdd_prop.set_label("DD Vc");
	vcdd_prop.set_unit("a.u.");
	vcdd_prop.set_standard_unit("a.u.");
	vcdd_prop.set_display_unit("a.u.");
	vcdd_prop.set_format("%10.0f");
	//	max_value	not set for VcDD
	//	min_value	not set for VcDD
	//	max_alarm	not set for VcDD
	//	min_alarm	not set for VcDD
	//	max_warning	not set for VcDD
	//	min_warning	not set for VcDD
	//	delta_t	not set for VcDD
	//	delta_val	not set for VcDD
	
	vcdd->set_default_properties(vcdd_prop);
	//	Not Polled
	vcdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vcdd);

	//	Attribute : VdDD
	VdDDAttrib	*vddd = new VdDDAttrib();
	Tango::UserDefaultAttrProp	vddd_prop;
	vddd_prop.set_description("Turn by turn data: Vd");
	vddd_prop.set_label("DD Vd");
	vddd_prop.set_unit("a.u.");
	vddd_prop.set_standard_unit("a.u.");
	vddd_prop.set_display_unit("a.u.");
	vddd_prop.set_format("%10.0f");
	//	max_value	not set for VdDD
	//	min_value	not set for VdDD
	//	max_alarm	not set for VdDD
	//	min_alarm	not set for VdDD
	//	max_warning	not set for VdDD
	//	min_warning	not set for VdDD
	//	delta_t	not set for VdDD
	//	delta_val	not set for VdDD
	
	vddd->set_default_properties(vddd_prop);
	//	Not Polled
	vddd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vddd);

	//	Attribute : XPosSAHistory
	XPosSAHistoryAttrib	*xpossahistory = new XPosSAHistoryAttrib();
	Tango::UserDefaultAttrProp	xpossahistory_prop;
	xpossahistory_prop.set_description("Slow Acquisition: X scrolling window of last NumSamples \n(512) sa samples");
	xpossahistory_prop.set_label("SA X Pos. History");
	xpossahistory_prop.set_unit("mm");
	xpossahistory_prop.set_standard_unit("mm");
	xpossahistory_prop.set_display_unit("mm");
	xpossahistory_prop.set_format("%8.4f");
	//	max_value	not set for XPosSAHistory
	//	min_value	not set for XPosSAHistory
	//	max_alarm	not set for XPosSAHistory
	//	min_alarm	not set for XPosSAHistory
	//	max_warning	not set for XPosSAHistory
	//	min_warning	not set for XPosSAHistory
	//	delta_t	not set for XPosSAHistory
	//	delta_val	not set for XPosSAHistory
	
	xpossahistory->set_default_properties(xpossahistory_prop);
	//	Not Polled
	xpossahistory->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xpossahistory);

	//	Attribute : YPosSAHistory
	YPosSAHistoryAttrib	*ypossahistory = new YPosSAHistoryAttrib();
	Tango::UserDefaultAttrProp	ypossahistory_prop;
	ypossahistory_prop.set_description("Slow Acquisition: Y scrolling window of last NumSamples \n(512) sa samples");
	ypossahistory_prop.set_label("SA Y Pos. History");
	ypossahistory_prop.set_unit("mm");
	ypossahistory_prop.set_standard_unit("mm");
	ypossahistory_prop.set_display_unit("mm");
	ypossahistory_prop.set_format("%8.4f");
	//	max_value	not set for YPosSAHistory
	//	min_value	not set for YPosSAHistory
	//	max_alarm	not set for YPosSAHistory
	//	min_alarm	not set for YPosSAHistory
	//	max_warning	not set for YPosSAHistory
	//	min_warning	not set for YPosSAHistory
	//	delta_t	not set for YPosSAHistory
	//	delta_val	not set for YPosSAHistory
	
	ypossahistory->set_default_properties(ypossahistory_prop);
	//	Not Polled
	ypossahistory->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ypossahistory);

	//	Attribute : SumSAHistory
	SumSAHistoryAttrib	*sumsahistory = new SumSAHistoryAttrib();
	Tango::UserDefaultAttrProp	sumsahistory_prop;
	sumsahistory_prop.set_description("Slow Acquisition: Sum scrolling window of last \nNumSamples (512) sa samples");
	sumsahistory_prop.set_label("SA Sum. History");
	sumsahistory_prop.set_unit("a.u.");
	sumsahistory_prop.set_standard_unit("a.u.");
	sumsahistory_prop.set_display_unit("a.u.");
	sumsahistory_prop.set_format("%8.4f");
	//	max_value	not set for SumSAHistory
	//	min_value	not set for SumSAHistory
	//	max_alarm	not set for SumSAHistory
	//	min_alarm	not set for SumSAHistory
	//	max_warning	not set for SumSAHistory
	//	min_warning	not set for SumSAHistory
	//	delta_t	not set for SumSAHistory
	//	delta_val	not set for SumSAHistory
	
	sumsahistory->set_default_properties(sumsahistory_prop);
	//	Not Polled
	sumsahistory->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(sumsahistory);

	//	Attribute : XPosPM
	XPosPMAttrib	*xpospm = new XPosPMAttrib();
	Tango::UserDefaultAttrProp	xpospm_prop;
	xpospm_prop.set_description("Post Mortem : X pos.");
	xpospm_prop.set_label("X Post Mortem Data");
	xpospm_prop.set_unit("mm");
	xpospm_prop.set_standard_unit("mm");
	xpospm_prop.set_display_unit("mm");
	xpospm_prop.set_format("%8.4f");
	//	max_value	not set for XPosPM
	//	min_value	not set for XPosPM
	//	max_alarm	not set for XPosPM
	//	min_alarm	not set for XPosPM
	//	max_warning	not set for XPosPM
	//	min_warning	not set for XPosPM
	//	delta_t	not set for XPosPM
	//	delta_val	not set for XPosPM
	
	xpospm->set_default_properties(xpospm_prop);
	//	Not Polled
	xpospm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(xpospm);

	//	Attribute : YPosPM
	YPosPMAttrib	*ypospm = new YPosPMAttrib();
	Tango::UserDefaultAttrProp	ypospm_prop;
	ypospm_prop.set_description("Post Mortem : Y pos.");
	ypospm_prop.set_label("Y Post Mortem Data");
	ypospm_prop.set_unit("mm");
	ypospm_prop.set_standard_unit("mm");
	ypospm_prop.set_display_unit("mm");
	ypospm_prop.set_format("%8.4f");
	//	max_value	not set for YPosPM
	//	min_value	not set for YPosPM
	//	max_alarm	not set for YPosPM
	//	min_alarm	not set for YPosPM
	//	max_warning	not set for YPosPM
	//	min_warning	not set for YPosPM
	//	delta_t	not set for YPosPM
	//	delta_val	not set for YPosPM
	
	ypospm->set_default_properties(ypospm_prop);
	//	Not Polled
	ypospm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ypospm);

	//	Attribute : QuadPM
	QuadPMAttrib	*quadpm = new QuadPMAttrib();
	Tango::UserDefaultAttrProp	quadpm_prop;
	quadpm_prop.set_description("Post Mortem : Quad");
	quadpm_prop.set_label("Quad Post Mortem Data");
	quadpm_prop.set_unit("a.u");
	quadpm_prop.set_standard_unit("a.u");
	quadpm_prop.set_display_unit("a.u");
	quadpm_prop.set_format("%8.4f");
	//	max_value	not set for QuadPM
	//	min_value	not set for QuadPM
	//	max_alarm	not set for QuadPM
	//	min_alarm	not set for QuadPM
	//	max_warning	not set for QuadPM
	//	min_warning	not set for QuadPM
	//	delta_t	not set for QuadPM
	//	delta_val	not set for QuadPM
	
	quadpm->set_default_properties(quadpm_prop);
	//	Not Polled
	quadpm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(quadpm);

	//	Attribute : SumPM
	SumPMAttrib	*sumpm = new SumPMAttrib();
	Tango::UserDefaultAttrProp	sumpm_prop;
	sumpm_prop.set_description("Post Mortem : Sum");
	sumpm_prop.set_label("Sum Post Mortem Data");
	sumpm_prop.set_unit("a.u");
	sumpm_prop.set_standard_unit("a.u");
	sumpm_prop.set_display_unit("a.u");
	sumpm_prop.set_format("%10.0f");
	//	max_value	not set for SumPM
	//	min_value	not set for SumPM
	//	max_alarm	not set for SumPM
	//	min_alarm	not set for SumPM
	//	max_warning	not set for SumPM
	//	min_warning	not set for SumPM
	//	delta_t	not set for SumPM
	//	delta_val	not set for SumPM
	
	sumpm->set_default_properties(sumpm_prop);
	//	Not Polled
	sumpm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(sumpm);

	//	Attribute : VaPM
	VaPMAttrib	*vapm = new VaPMAttrib();
	Tango::UserDefaultAttrProp	vapm_prop;
	vapm_prop.set_description("Post Mortem : Va");
	vapm_prop.set_label("Va Post Mortem Data");
	vapm_prop.set_unit("a.u.");
	vapm_prop.set_standard_unit("a.u.");
	vapm_prop.set_display_unit("a.u.");
	vapm_prop.set_format("%10.0f");
	//	max_value	not set for VaPM
	//	min_value	not set for VaPM
	//	max_alarm	not set for VaPM
	//	min_alarm	not set for VaPM
	//	max_warning	not set for VaPM
	//	min_warning	not set for VaPM
	//	delta_t	not set for VaPM
	//	delta_val	not set for VaPM
	
	vapm->set_default_properties(vapm_prop);
	//	Not Polled
	vapm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vapm);

	//	Attribute : VbPM
	VbPMAttrib	*vbpm = new VbPMAttrib();
	Tango::UserDefaultAttrProp	vbpm_prop;
	vbpm_prop.set_description("Post Mortem : Vb");
	vbpm_prop.set_label("Vb Post Mortem Data");
	vbpm_prop.set_unit("a.u.");
	vbpm_prop.set_standard_unit("a.u.");
	vbpm_prop.set_display_unit("a.u.");
	vbpm_prop.set_format("%10.0f");
	//	max_value	not set for VbPM
	//	min_value	not set for VbPM
	//	max_alarm	not set for VbPM
	//	min_alarm	not set for VbPM
	//	max_warning	not set for VbPM
	//	min_warning	not set for VbPM
	//	delta_t	not set for VbPM
	//	delta_val	not set for VbPM
	
	vbpm->set_default_properties(vbpm_prop);
	//	Not Polled
	vbpm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vbpm);

	//	Attribute : VcPM
	VcPMAttrib	*vcpm = new VcPMAttrib();
	Tango::UserDefaultAttrProp	vcpm_prop;
	vcpm_prop.set_description("Post Mortem : Vc");
	vcpm_prop.set_label("Post Mortem : Vc");
	vcpm_prop.set_unit("a.u.");
	vcpm_prop.set_standard_unit("a.u.");
	vcpm_prop.set_display_unit("a.u.");
	vcpm_prop.set_format("%10.0f");
	//	max_value	not set for VcPM
	//	min_value	not set for VcPM
	//	max_alarm	not set for VcPM
	//	min_alarm	not set for VcPM
	//	max_warning	not set for VcPM
	//	min_warning	not set for VcPM
	//	delta_t	not set for VcPM
	//	delta_val	not set for VcPM
	
	vcpm->set_default_properties(vcpm_prop);
	//	Not Polled
	vcpm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vcpm);

	//	Attribute : VdPM
	VdPMAttrib	*vdpm = new VdPMAttrib();
	Tango::UserDefaultAttrProp	vdpm_prop;
	vdpm_prop.set_description("Post Mortem : Vd");
	vdpm_prop.set_label("Vd Post Mortem Data");
	vdpm_prop.set_unit("a.u.");
	vdpm_prop.set_standard_unit("a.u.");
	vdpm_prop.set_display_unit("a.u.");
	vdpm_prop.set_format("%10.0f");
	//	max_value	not set for VdPM
	//	min_value	not set for VdPM
	//	max_alarm	not set for VdPM
	//	min_alarm	not set for VdPM
	//	max_warning	not set for VdPM
	//	min_warning	not set for VdPM
	//	delta_t	not set for VdPM
	//	delta_val	not set for VdPM
	
	vdpm->set_default_properties(vdpm_prop);
	//	Not Polled
	vdpm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(vdpm);

	//	Attribute : ADCChannelA
	ADCChannelAAttrib	*adcchannela = new ADCChannelAAttrib();
	Tango::UserDefaultAttrProp	adcchannela_prop;
	adcchannela_prop.set_description("ADC values for pickup A");
	adcchannela_prop.set_label("ADC Channel A");
	adcchannela_prop.set_unit("a.u");
	adcchannela_prop.set_standard_unit("a.u");
	adcchannela_prop.set_display_unit("a.u");
	adcchannela_prop.set_format("%8d");
	//	max_value	not set for ADCChannelA
	//	min_value	not set for ADCChannelA
	//	max_alarm	not set for ADCChannelA
	//	min_alarm	not set for ADCChannelA
	//	max_warning	not set for ADCChannelA
	//	min_warning	not set for ADCChannelA
	//	delta_t	not set for ADCChannelA
	//	delta_val	not set for ADCChannelA
	
	adcchannela->set_default_properties(adcchannela_prop);
	//	Not Polled
	adcchannela->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(adcchannela);

	//	Attribute : ADCChannelB
	ADCChannelBAttrib	*adcchannelb = new ADCChannelBAttrib();
	Tango::UserDefaultAttrProp	adcchannelb_prop;
	adcchannelb_prop.set_description("ADC values for pickup B");
	adcchannelb_prop.set_label("ADC Channel B");
	adcchannelb_prop.set_unit("a.u");
	adcchannelb_prop.set_standard_unit("a.u");
	adcchannelb_prop.set_display_unit("a.u");
	adcchannelb_prop.set_format("%8d");
	//	max_value	not set for ADCChannelB
	//	min_value	not set for ADCChannelB
	//	max_alarm	not set for ADCChannelB
	//	min_alarm	not set for ADCChannelB
	//	max_warning	not set for ADCChannelB
	//	min_warning	not set for ADCChannelB
	//	delta_t	not set for ADCChannelB
	//	delta_val	not set for ADCChannelB
	
	adcchannelb->set_default_properties(adcchannelb_prop);
	//	Not Polled
	adcchannelb->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(adcchannelb);

	//	Attribute : ADCChannelC
	ADCChannelCAttrib	*adcchannelc = new ADCChannelCAttrib();
	Tango::UserDefaultAttrProp	adcchannelc_prop;
	adcchannelc_prop.set_description("ADC values for pickup C");
	adcchannelc_prop.set_label("ADC Channel C");
	adcchannelc_prop.set_unit("a.u");
	adcchannelc_prop.set_standard_unit("a.u");
	adcchannelc_prop.set_display_unit("a.u");
	adcchannelc_prop.set_format("%8d");
	//	max_value	not set for ADCChannelC
	//	min_value	not set for ADCChannelC
	//	max_alarm	not set for ADCChannelC
	//	min_alarm	not set for ADCChannelC
	//	max_warning	not set for ADCChannelC
	//	min_warning	not set for ADCChannelC
	//	delta_t	not set for ADCChannelC
	//	delta_val	not set for ADCChannelC
	
	adcchannelc->set_default_properties(adcchannelc_prop);
	//	Not Polled
	adcchannelc->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(adcchannelc);

	//	Attribute : ADCChannelD
	ADCChannelDAttrib	*adcchanneld = new ADCChannelDAttrib();
	Tango::UserDefaultAttrProp	adcchanneld_prop;
	adcchanneld_prop.set_description("ADC values for pickup D");
	adcchanneld_prop.set_label("ADC Channel D");
	adcchanneld_prop.set_unit("a.u");
	adcchanneld_prop.set_standard_unit("a.u");
	adcchanneld_prop.set_display_unit("a.u");
	adcchanneld_prop.set_format("%8d");
	//	max_value	not set for ADCChannelD
	//	min_value	not set for ADCChannelD
	//	max_alarm	not set for ADCChannelD
	//	min_alarm	not set for ADCChannelD
	//	max_warning	not set for ADCChannelD
	//	min_warning	not set for ADCChannelD
	//	delta_t	not set for ADCChannelD
	//	delta_val	not set for ADCChannelD
	
	adcchanneld->set_default_properties(adcchanneld_prop);
	//	Not Polled
	adcchanneld->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(adcchanneld);

	//	Attribute : IaDD
	IaDDAttrib	*iadd = new IaDDAttrib();
	Tango::UserDefaultAttrProp	iadd_prop;
	iadd_prop.set_description("Turn by turn data: Ia");
	iadd_prop.set_label("DD Ia");
	iadd_prop.set_unit("a.u.");
	//	standard_unit	not set for IaDD
	//	display_unit	not set for IaDD
	iadd_prop.set_format("%10.0f");
	//	max_value	not set for IaDD
	//	min_value	not set for IaDD
	//	max_alarm	not set for IaDD
	//	min_alarm	not set for IaDD
	//	max_warning	not set for IaDD
	//	min_warning	not set for IaDD
	//	delta_t	not set for IaDD
	//	delta_val	not set for IaDD
	
	iadd->set_default_properties(iadd_prop);
	//	Not Polled
	iadd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(iadd);

	//	Attribute : IbDD
	IbDDAttrib	*ibdd = new IbDDAttrib();
	Tango::UserDefaultAttrProp	ibdd_prop;
	ibdd_prop.set_description("Turn by turn data: Ib");
	ibdd_prop.set_label("DD Ib");
	ibdd_prop.set_unit("a.u.");
	//	standard_unit	not set for IbDD
	//	display_unit	not set for IbDD
	ibdd_prop.set_format("%10.0f");
	//	max_value	not set for IbDD
	//	min_value	not set for IbDD
	//	max_alarm	not set for IbDD
	//	min_alarm	not set for IbDD
	//	max_warning	not set for IbDD
	//	min_warning	not set for IbDD
	//	delta_t	not set for IbDD
	//	delta_val	not set for IbDD
	
	ibdd->set_default_properties(ibdd_prop);
	//	Not Polled
	ibdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ibdd);

	//	Attribute : IcDD
	IcDDAttrib	*icdd = new IcDDAttrib();
	Tango::UserDefaultAttrProp	icdd_prop;
	icdd_prop.set_description("Turn by turn data: Ic");
	icdd_prop.set_label("DD Ic");
	icdd_prop.set_unit("a.u.");
	//	standard_unit	not set for IcDD
	//	display_unit	not set for IcDD
	icdd_prop.set_format("%10.0f");
	//	max_value	not set for IcDD
	//	min_value	not set for IcDD
	//	max_alarm	not set for IcDD
	//	min_alarm	not set for IcDD
	//	max_warning	not set for IcDD
	//	min_warning	not set for IcDD
	//	delta_t	not set for IcDD
	//	delta_val	not set for IcDD
	
	icdd->set_default_properties(icdd_prop);
	//	Not Polled
	icdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(icdd);

	//	Attribute : IdDD
	IdDDAttrib	*iddd = new IdDDAttrib();
	Tango::UserDefaultAttrProp	iddd_prop;
	iddd_prop.set_description("Turn by turn data: Id");
	iddd_prop.set_label("DD Id");
	iddd_prop.set_unit("a.u.");
	//	standard_unit	not set for IdDD
	//	display_unit	not set for IdDD
	iddd_prop.set_format("%10.0f");
	//	max_value	not set for IdDD
	//	min_value	not set for IdDD
	//	max_alarm	not set for IdDD
	//	min_alarm	not set for IdDD
	//	max_warning	not set for IdDD
	//	min_warning	not set for IdDD
	//	delta_t	not set for IdDD
	//	delta_val	not set for IdDD
	
	iddd->set_default_properties(iddd_prop);
	//	Not Polled
	iddd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(iddd);

	//	Attribute : QaDD
	QaDDAttrib	*qadd = new QaDDAttrib();
	Tango::UserDefaultAttrProp	qadd_prop;
	qadd_prop.set_description("Turn by turn data: Qa");
	qadd_prop.set_label("DD Qa");
	qadd_prop.set_unit("a.u.");
	//	standard_unit	not set for QaDD
	//	display_unit	not set for QaDD
	qadd_prop.set_format("%10.0f");
	//	max_value	not set for QaDD
	//	min_value	not set for QaDD
	//	max_alarm	not set for QaDD
	//	min_alarm	not set for QaDD
	//	max_warning	not set for QaDD
	//	min_warning	not set for QaDD
	//	delta_t	not set for QaDD
	//	delta_val	not set for QaDD
	
	qadd->set_default_properties(qadd_prop);
	//	Not Polled
	qadd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(qadd);

	//	Attribute : QbDD
	QbDDAttrib	*qbdd = new QbDDAttrib();
	Tango::UserDefaultAttrProp	qbdd_prop;
	qbdd_prop.set_description("Turn by turn data: Qb");
	qbdd_prop.set_label("DD Qb");
	qbdd_prop.set_unit("a.u.");
	//	standard_unit	not set for QbDD
	//	display_unit	not set for QbDD
	qbdd_prop.set_format("%10.0f");
	//	max_value	not set for QbDD
	//	min_value	not set for QbDD
	//	max_alarm	not set for QbDD
	//	min_alarm	not set for QbDD
	//	max_warning	not set for QbDD
	//	min_warning	not set for QbDD
	//	delta_t	not set for QbDD
	//	delta_val	not set for QbDD
	
	qbdd->set_default_properties(qbdd_prop);
	//	Not Polled
	qbdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(qbdd);

	//	Attribute : QcDD
	QcDDAttrib	*qcdd = new QcDDAttrib();
	Tango::UserDefaultAttrProp	qcdd_prop;
	qcdd_prop.set_description("Turn by turn data: Qc");
	qcdd_prop.set_label("DD Qc");
	qcdd_prop.set_unit("a.u.");
	//	standard_unit	not set for QcDD
	//	display_unit	not set for QcDD
	qcdd_prop.set_format("%10.0f");
	//	max_value	not set for QcDD
	//	min_value	not set for QcDD
	//	max_alarm	not set for QcDD
	//	min_alarm	not set for QcDD
	//	max_warning	not set for QcDD
	//	min_warning	not set for QcDD
	//	delta_t	not set for QcDD
	//	delta_val	not set for QcDD
	
	qcdd->set_default_properties(qcdd_prop);
	//	Not Polled
	qcdd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(qcdd);

	//	Attribute : QdDD
	QdDDAttrib	*qddd = new QdDDAttrib();
	Tango::UserDefaultAttrProp	qddd_prop;
	qddd_prop.set_description("Turn by turn data: Qd");
	qddd_prop.set_label("DD Qd");
	qddd_prop.set_unit("a.u.");
	//	standard_unit	not set for QdDD
	//	display_unit	not set for QdDD
	qddd_prop.set_format("%10.0f");
	//	max_value	not set for QdDD
	//	min_value	not set for QdDD
	//	max_alarm	not set for QdDD
	//	min_alarm	not set for QdDD
	//	max_warning	not set for QdDD
	//	min_warning	not set for QdDD
	//	delta_t	not set for QdDD
	//	delta_val	not set for QdDD
	
	qddd->set_default_properties(qddd_prop);
	//	Not Polled
	qddd->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(qddd);

	//	Attribute : UserData
	UserDataAttrib	*userdata = new UserDataAttrib();
	Tango::UserDefaultAttrProp	userdata_prop;
	userdata_prop.set_description("User defined data");
	//	label	not set for UserData
	//	unit	not set for UserData
	//	standard_unit	not set for UserData
	//	display_unit	not set for UserData
	//	format	not set for UserData
	//	max_value	not set for UserData
	//	min_value	not set for UserData
	//	max_alarm	not set for UserData
	//	min_alarm	not set for UserData
	//	max_warning	not set for UserData
	//	min_warning	not set for UserData
	//	delta_t	not set for UserData
	//	delta_val	not set for UserData
	
	userdata->set_default_properties(userdata_prop);
	//	Not Polled
	userdata->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(userdata);

	//	Attribute : logs
	logsAttrib	*logs = new logsAttrib();
	Tango::UserDefaultAttrProp	logs_prop;
	//	description	not set for logs
	//	label	not set for logs
	//	unit	not set for logs
	//	standard_unit	not set for logs
	//	display_unit	not set for logs
	//	format	not set for logs
	//	max_value	not set for logs
	//	min_value	not set for logs
	//	max_alarm	not set for logs
	//	min_alarm	not set for logs
	//	max_warning	not set for logs
	//	min_warning	not set for logs
	//	delta_t	not set for logs
	//	delta_val	not set for logs
	
	logs->set_default_properties(logs_prop);
	//	Not Polled
	logs->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(logs);

	//	Create a list of static attributes
	create_static_attribute_list(get_class_attr()->get_attr_list());
	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::attribute_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::attribute_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::command_factory()
 *	Description : Create the command object(s)
 *                and store them in the command list
 */
//--------------------------------------------------------
void LiberaBrilliancePlusClass::command_factory()
{
	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::command_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::command_factory_before


	//	Command GetParameters
	GetParametersClass	*pGetParametersCmd =
		new GetParametersClass("GetParameters",
			Tango::DEV_VOID, Tango::DEVVAR_DOUBLESTRINGARRAY,
			"N/A",
			"The BPM gain and offsets",
			Tango::OPERATOR);
	command_list.push_back(pGetParametersCmd);

	//	Command UnfreezeDDBuffer
	UnfreezeDDBufferClass	*pUnfreezeDDBufferCmd =
		new UnfreezeDDBufferClass("UnfreezeDDBuffer",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pUnfreezeDDBufferCmd);

	//	Command EnableDDBufferFreezing
	EnableDDBufferFreezingClass	*pEnableDDBufferFreezingCmd =
		new EnableDDBufferFreezingClass("EnableDDBufferFreezing",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pEnableDDBufferFreezingCmd);

	//	Command DisableDDBufferFreezing
	DisableDDBufferFreezingClass	*pDisableDDBufferFreezingCmd =
		new DisableDDBufferFreezingClass("DisableDDBufferFreezing",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pDisableDDBufferFreezingCmd);

	//	Command EnableDD
	EnableDDClass	*pEnableDDCmd =
		new EnableDDClass("EnableDD",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pEnableDDCmd);

	//	Command DisableDD
	DisableDDClass	*pDisableDDCmd =
		new DisableDDClass("DisableDD",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pDisableDDCmd);

	//	Command EnableSA
	EnableSAClass	*pEnableSACmd =
		new EnableSAClass("EnableSA",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pEnableSACmd);

	//	Command DisableSA
	DisableSAClass	*pDisableSACmd =
		new DisableSAClass("DisableSA",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pDisableSACmd);

	//	Command ResetPMNotification
	ResetPMNotificationClass	*pResetPMNotificationCmd =
		new ResetPMNotificationClass("ResetPMNotification",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pResetPMNotificationCmd);

	//	Command ResetInterlockNotification
	ResetInterlockNotificationClass	*pResetInterlockNotificationCmd =
		new ResetInterlockNotificationClass("ResetInterlockNotification",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pResetInterlockNotificationCmd);

	//	Command SetInterlockConfiguration
	SetInterlockConfigurationClass	*pSetInterlockConfigurationCmd =
		new SetInterlockConfigurationClass("SetInterlockConfiguration",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pSetInterlockConfigurationCmd);

	//	Command EnableADC
	EnableADCClass	*pEnableADCCmd =
		new EnableADCClass("EnableADC",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pEnableADCCmd);

	//	Command DisableADC
	DisableADCClass	*pDisableADCCmd =
		new DisableADCClass("DisableADC",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pDisableADCCmd);

	//	Command SetTimeOnNextTrigger
	SetTimeOnNextTriggerClass	*pSetTimeOnNextTriggerCmd =
		new SetTimeOnNextTriggerClass("SetTimeOnNextTrigger",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pSetTimeOnNextTriggerCmd);

	//	Command ReadFAData
	ReadFADataClass	*pReadFADataCmd =
		new ReadFADataClass("ReadFAData",
			Tango::DEVVAR_LONGARRAY, Tango::DEVVAR_LONGARRAY,
			"The reading parameters: [0]:offset in FA data block, [1]:size of elems, [2]:num of elems",
			"The data [as an array of bytes]",
			Tango::OPERATOR);
	command_list.push_back(pReadFADataCmd);

	//	Command WriteFAData
	WriteFADataClass	*pWriteFADataCmd =
		new WriteFADataClass("WriteFAData",
			Tango::DEVVAR_LONGARRAY, Tango::DEV_VOID,
			"The writting parameters: [0]:offset in FA data block, bytes[1]:size of elems, [2]:num of elems, [3, ...]: actual to data to be written",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pWriteFADataCmd);

	//	Command SaveDSCParameters
	SaveDSCParametersClass	*pSaveDSCParametersCmd =
		new SaveDSCParametersClass("SaveDSCParameters",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pSaveDSCParametersCmd);

	//	Command ReloadSystemProperties
	ReloadSystemPropertiesClass	*pReloadSystemPropertiesCmd =
		new ReloadSystemPropertiesClass("ReloadSystemProperties",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"n/a",
			"n/a",
			Tango::OPERATOR);
	command_list.push_back(pReloadSystemPropertiesCmd);

	//	Command SetRefIncoherence
	SetRefIncoherenceClass	*pSetRefIncoherenceCmd =
		new SetRefIncoherenceClass("SetRefIncoherence",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pSetRefIncoherenceCmd);

	//	Command MagicCommand
	MagicCommandClass	*pMagicCommandCmd =
		new MagicCommandClass("MagicCommand",
			Tango::DEV_STRING, Tango::DEVVAR_STRINGARRAY,
			"absolute path of the node name",
			"value of specified node(s)",
			Tango::EXPERT);
	command_list.push_back(pMagicCommandCmd);

	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::command_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::command_factory_after
}

//===================================================================
//	Dynamic attributes related methods
//===================================================================

//--------------------------------------------------------
/**
 * method : 		LiberaBrilliancePlusClass::create_static_attribute_list
 * description : 	Create the a list of static attributes
 *
 * @param	att_list	the ceated attribute list 
 */
//--------------------------------------------------------
void LiberaBrilliancePlusClass::create_static_attribute_list(vector<Tango::Attr *> &att_list)
{
	for (unsigned long i=0 ; i<att_list.size() ; i++)
	{
		string att_name(att_list[i]->get_name());
		transform(att_name.begin(), att_name.end(), att_name.begin(), ::tolower);
		defaultAttList.push_back(att_name);
	}

	cout2 << defaultAttList.size() << " attributes in default list" << endl;

	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::create_static_att_list) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::create_static_att_list
}


//--------------------------------------------------------
/**
 * method : 		LiberaBrilliancePlusClass::erase_dynamic_attributes
 * description : 	delete the dynamic attributes if any.
 *
 * @param	devlist_ptr	the device list pointer
 * @param	list of all attributes
 */
//--------------------------------------------------------
void LiberaBrilliancePlusClass::erase_dynamic_attributes(const Tango::DevVarStringArray *devlist_ptr, vector<Tango::Attr *> &att_list)
{
	Tango::Util *tg = Tango::Util::instance();

	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{	
		Tango::DeviceImpl *dev_impl = tg->get_device_by_name(((string)(*devlist_ptr)[i]).c_str());
		LiberaBrilliancePlus *dev = static_cast<LiberaBrilliancePlus *> (dev_impl);
		
		vector<Tango::Attribute *> &dev_att_list = dev->get_device_attr()->get_attribute_list();
		vector<Tango::Attribute *>::iterator ite_att;
		for (ite_att=dev_att_list.begin() ; ite_att != dev_att_list.end() ; ++ite_att)
		{
			string att_name((*ite_att)->get_name_lower());
			if ((att_name == "state") || (att_name == "status"))
				continue;
			vector<string>::iterator ite_str = find(defaultAttList.begin(), defaultAttList.end(), att_name);
			if (ite_str == defaultAttList.end())
			{
				cout2 << att_name << " is a UNWANTED dynamic attribute for device " << (*devlist_ptr)[i] << endl;
				Tango::Attribute &att = dev->get_device_attr()->get_attr_by_name(att_name.c_str());
				dev->remove_attribute(att_list[att.get_attr_idx()], true, false);
				--ite_att;
			}
		}
	}
	/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::erase_dynamic_attributes) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::erase_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Method      : LiberaBrilliancePlusClass::get_attr_by_name()
 *	Description : returns Tango::Attr * object found by name
 */
//--------------------------------------------------------
Tango::Attr *LiberaBrilliancePlusClass::get_attr_object_by_name(vector<Tango::Attr *> &att_list, string attname)
{
	vector<Tango::Attr *>::iterator it;
	for (it=att_list.begin() ; it<att_list.end() ; it++)
		if ((*it)->get_name()==attname)
			return (*it);
	//	Attr does not exist
	return NULL;
}


/*----- PROTECTED REGION ID(LiberaBrilliancePlusClass::Additional Methods) ENABLED START -----*/

/*----- PROTECTED REGION END -----*/	//	LiberaBrilliancePlusClass::Additional Methods
} //	namespace
